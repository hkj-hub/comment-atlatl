/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/coarena.js":
/*!********************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/coarena.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coarena: () => (/* binding */ Coarena)\n/* harmony export */ });\nclass Coarena {\n    constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array();\n        this.size = 0;\n    }\n    set(handle, data) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n        if (this.data[i] == null)\n            this.size += 1;\n        this.data[i] = data;\n    }\n    len() {\n        return this.size;\n    }\n    delete(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null)\n                this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n    clear() {\n        this.data = new Array();\n    }\n    get(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        }\n        else {\n            return null;\n        }\n    }\n    forEach(f) {\n        for (const elt of this.data) {\n            if (elt != null)\n                f(elt);\n        }\n    }\n    getAll() {\n        return this.data.filter((elt) => elt != null);\n    }\n    index(handle) {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we don’t really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n//# sourceMappingURL=coarena.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2NvYXJlbmEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGNvYXJlbmEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIENvYXJlbmEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZjb252ID0gbmV3IEZsb2F0NjRBcnJheSgxKTtcbiAgICAgICAgdGhpcy51Y29udiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLmZjb252LmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheSgpO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cbiAgICBzZXQoaGFuZGxlLCBkYXRhKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5pbmRleChoYW5kbGUpO1xuICAgICAgICB3aGlsZSAodGhpcy5kYXRhLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNpemUgKz0gMTtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gZGF0YTtcbiAgICB9XG4gICAgbGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cbiAgICBkZWxldGUoaGFuZGxlKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5pbmRleChoYW5kbGUpO1xuICAgICAgICBpZiAoaSA8IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgLT0gMTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheSgpO1xuICAgIH1cbiAgICBnZXQoaGFuZGxlKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5pbmRleChoYW5kbGUpO1xuICAgICAgICBpZiAoaSA8IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbHQgb2YgdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoZWx0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZihlbHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5maWx0ZXIoKGVsdCkgPT4gZWx0ICE9IG51bGwpO1xuICAgIH1cbiAgICBpbmRleChoYW5kbGUpIHtcbiAgICAgICAgLy8vIEV4dHJhY3RzIHRoZSBpbmRleCBwYXJ0IG9mIGEgaGFuZGxlICh0aGUgbG93ZXIgMzIgYml0cykuXG4gICAgICAgIC8vLyBUaGlzIGlzIGRvbmUgYnkgZmlyc3QgaW5qZWN0aW5nIHRoZSBoYW5kbGUgaW50byBhbiBGbG9hdDY0QXJyYXlcbiAgICAgICAgLy8vIHdoaWNoIGlzIGl0c2VsZiBpbmplY3RlZCBpbnRvIGFuIFVpbnQzMkFycmF5IChhdCBjb25zdHJ1Y3Rpb24gdGltZSkuXG4gICAgICAgIC8vLyBUaGUgMC10aCB2YWx1ZSBvZiB0aGUgVWludDMyQXJyYXkgd2lsbCBiZWNvbWUgdGhlIGBudW1iZXJgIGludGVnZXJcbiAgICAgICAgLy8vIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBsb3dlciAzMiBiaXRzLlxuICAgICAgICAvLy8gQWxzbyBgdGhpcy51Y29udlsxXWAgdGhlbiBjb250YWlucyB0aGUgZ2VuZXJhdGlvbiBudW1iZXIgYXMgYSBgbnVtYmVyYCxcbiAgICAgICAgLy8vIHdoaWNoIHdlIGRvbuKAmXQgcmVhbGx5IG5lZWQuXG4gICAgICAgIHRoaXMuZmNvbnZbMF0gPSBoYW5kbGU7XG4gICAgICAgIHJldHVybiB0aGlzLnVjb252WzBdO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvYXJlbmEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/coarena.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/control/character_controller.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/control/character_controller.js ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCollision: () => (/* binding */ CharacterCollision),\n/* harmony export */   KinematicCharacterController: () => (/* binding */ KinematicCharacterController)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nclass CharacterCollision {\n}\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nclass KinematicCharacterController {\n    constructor(offset, params, bodies, colliders, queries) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n    up() {\n        return this.raw.up();\n    }\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n    setUp(vector) {\n        let rawVect = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n    applyImpulsesToDynamicBodies() {\n        return this._applyImpulsesToDynamicBodies;\n    }\n    setApplyImpulsesToDynamicBodies(enabled) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    characterMass() {\n        return this._characterMass;\n    }\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isn’t attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    setCharacterMass(mass) {\n        this._characterMass = mass;\n    }\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    offset() {\n        return this.raw.offset();\n    }\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    setOffset(value) {\n        this.raw.setOffset(value);\n    }\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    normalNudgeFactor() {\n        return this.raw.normalNudgeFactor();\n    }\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    setNormalNudgeFactor(value) {\n        this.raw.setNormalNudgeFactor(value);\n    }\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    slideEnabled() {\n        return this.raw.slideEnabled();\n    }\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    setSlideEnabled(enabled) {\n        this.raw.setSlideEnabled(enabled);\n    }\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    autostepMaxHeight() {\n        return this.raw.autostepMaxHeight();\n    }\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    autostepMinWidth() {\n        return this.raw.autostepMinWidth();\n    }\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    autostepIncludesDynamicBodies() {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    autostepEnabled() {\n        return this.raw.autostepEnabled();\n    }\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n    /**\n     * The maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    maxSlopeClimbAngle() {\n        return this.raw.maxSlopeClimbAngle();\n    }\n    /**\n     * Sets the maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    setMaxSlopeClimbAngle(angle) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n    /**\n     * The minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    minSlopeSlideAngle() {\n        return this.raw.minSlopeSlideAngle();\n    }\n    /**\n     * Sets the minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    setMinSlopeSlideAngle(angle) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    snapToGroundDistance() {\n        return this.raw.snapToGroundDistance();\n    }\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    enableSnapToGround(distance) {\n        this.raw.enableSnapToGround(distance);\n    }\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    snapToGroundEnabled() {\n        return this.raw.snapToGroundEnabled();\n    }\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    computeColliderMovement(collider, desiredTranslationDelta, filterFlags, filterGroups, filterPredicate) {\n        let rawTranslationDelta = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, collider.handle, rawTranslationDelta, this._applyImpulsesToDynamicBodies, this._characterMass, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n        rawTranslationDelta.free();\n    }\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    computedMovement() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.computedMovement());\n    }\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    computedGrounded() {\n        return this.raw.computedGrounded();\n    }\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    numComputedCollisions() {\n        return this.raw.numComputedCollisions();\n    }\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    computedCollision(i, out) {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        }\n        else {\n            let c = this.rawCharacterCollision;\n            out = out !== null && out !== void 0 ? out : new CharacterCollision();\n            out.translationDeltaApplied = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.translationDeltaApplied());\n            out.translationDeltaRemaining = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.translationDeltaRemaining());\n            out.toi = c.toi();\n            out.witness1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n//# sourceMappingURL=character_controller.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2NvbnRyb2wvY2hhcmFjdGVyX2NvbnRyb2xsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnRjtBQUM1QztBQUNwQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUVBQStCO0FBQ3RELHlDQUF5Qyx1REFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNENBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRDQUFTO0FBQ25ELDRDQUE0Qyw0Q0FBUztBQUNyRDtBQUNBLDJCQUEyQiw0Q0FBUztBQUNwQywyQkFBMkIsNENBQVM7QUFDcEMsMEJBQTBCLDRDQUFTO0FBQ25DLDBCQUEwQiw0Q0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0QiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxcY29udHJvbFxcY2hhcmFjdGVyX2NvbnRyb2xsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF3S2luZW1hdGljQ2hhcmFjdGVyQ29udHJvbGxlciwgUmF3Q2hhcmFjdGVyQ29sbGlzaW9uIH0gZnJvbSBcIi4uL3Jhd1wiO1xuaW1wb3J0IHsgVmVjdG9yT3BzIH0gZnJvbSBcIi4uL21hdGhcIjtcbi8qKlxuICogQSBjb2xsaXNpb24gYmV0d2VlbiB0aGUgY2hhcmFjdGVyIGFuZCBhbiBvYnN0YWNsZSBoaXQgb24gaXRzIHBhdGguXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGFyYWN0ZXJDb2xsaXNpb24ge1xufVxuLyoqXG4gKiBBIGNoYXJhY3RlciBjb250cm9sbGVyIGZvciBjb250cm9sbGluZyBraW5lbWF0aWMgYm9kaWVzIGFuZCBwYXJlbnRsZXNzIGNvbGxpZGVycyBieSBoaXR0aW5nXG4gKiBhbmQgc2xpZGluZyBhZ2FpbnN0IG9ic3RhY2xlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEtpbmVtYXRpY0NoYXJhY3RlckNvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9mZnNldCwgcGFyYW1zLCBib2RpZXMsIGNvbGxpZGVycywgcXVlcmllcykge1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5ib2RpZXMgPSBib2RpZXM7XG4gICAgICAgIHRoaXMuY29sbGlkZXJzID0gY29sbGlkZXJzO1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBxdWVyaWVzO1xuICAgICAgICB0aGlzLnJhdyA9IG5ldyBSYXdLaW5lbWF0aWNDaGFyYWN0ZXJDb250cm9sbGVyKG9mZnNldCk7XG4gICAgICAgIHRoaXMucmF3Q2hhcmFjdGVyQ29sbGlzaW9uID0gbmV3IFJhd0NoYXJhY3RlckNvbGxpc2lvbigpO1xuICAgICAgICB0aGlzLl9hcHBseUltcHVsc2VzVG9EeW5hbWljQm9kaWVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NoYXJhY3Rlck1hc3MgPSBudWxsO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKCEhdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LmZyZWUoKTtcbiAgICAgICAgICAgIHRoaXMucmF3Q2hhcmFjdGVyQ29sbGlzaW9uLmZyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYXdDaGFyYWN0ZXJDb2xsaXNpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkaXJlY3Rpb24gdGhhdCBnb2VzIFwidXBcIi4gVXNlZCB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIGZsb29yIGlzLCBhbmQgdGhlIGZsb29y4oCZcyBhbmdsZS5cbiAgICAgKi9cbiAgICB1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3LnVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRpcmVjdGlvbiB0aGF0IGdvZXMgXCJ1cFwiLiBVc2VkIHRvIGRldGVybWluZSB3aGVyZSB0aGUgZmxvb3IgaXMsIGFuZCB0aGUgZmxvb3LigJlzIGFuZ2xlLlxuICAgICAqL1xuICAgIHNldFVwKHZlY3Rvcikge1xuICAgICAgICBsZXQgcmF3VmVjdCA9IFZlY3Rvck9wcy5pbnRvUmF3KHZlY3Rvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5zZXRVcChyYXdWZWN0KTtcbiAgICAgICAgcmF3VmVjdC5mcmVlKCk7XG4gICAgfVxuICAgIGFwcGx5SW1wdWxzZXNUb0R5bmFtaWNCb2RpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseUltcHVsc2VzVG9EeW5hbWljQm9kaWVzO1xuICAgIH1cbiAgICBzZXRBcHBseUltcHVsc2VzVG9EeW5hbWljQm9kaWVzKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlJbXB1bHNlc1RvRHluYW1pY0JvZGllcyA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1c3RvbSB2YWx1ZSBvZiB0aGUgY2hhcmFjdGVyIG1hc3MsIGlmIGl0IHdhcyBzZXQgYnkgYHRoaXMuc2V0Q2hhcmFjdGVyTWFzc2AuXG4gICAgICovXG4gICAgY2hhcmFjdGVyTWFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJhY3Rlck1hc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWFzcyBvZiB0aGUgY2hhcmFjdGVyIHRvIGJlIHVzZWQgZm9yIGltcHVsc2UgcmVzb2x1dGlvbiBpZiBgc2VsZi5hcHBseUltcHVsc2VzVG9EeW5hbWljQm9kaWVzYFxuICAgICAqIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBJZiBubyBjaGFyYWN0ZXIgbWFzcyBpcyBzZXQgZXhwbGljaXRseSAob3IgaWYgaXQgaXMgc2V0IHRvIGBudWxsYCkgaXQgaXMgYXV0b21hdGljYWxseSBhc3N1bWVkIHRvIGJlIGVxdWFsXG4gICAgICogdG8gdGhlIG1hc3Mgb2YgdGhlIHJpZ2lkLWJvZHkgdGhlIGNoYXJhY3RlciBjb2xsaWRlciBpcyBhdHRhY2hlZCB0bzsgb3IgZXF1YWwgdG8gMCBpZiB0aGUgY2hhcmFjdGVyIGNvbGxpZGVyXG4gICAgICogaXNu4oCZdCBhdHRhY2hlZCB0byBhbnkgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXNzIC0gVGhlIG1hc3MgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldENoYXJhY3Rlck1hc3MobWFzcykge1xuICAgICAgICB0aGlzLl9jaGFyYWN0ZXJNYXNzID0gbWFzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzbWFsbCBnYXAgdG8gcHJlc2VydmUgYmV0d2VlbiB0aGUgY2hhcmFjdGVyIGFuZCBpdHMgc3Vycm91bmRpbmdzLlxuICAgICAqXG4gICAgICogVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHRvbyBsYXJnZSB0byBhdm9pZCB2aXN1YWwgYXJ0aWZhY3RzLCBidXQgc2hvdWxkbuKAmXQgYmUgdG9vIHNtYWxsXG4gICAgICogKG11c3Qgbm90IGJlIHplcm8pIHRvIGltcHJvdmUgbnVtZXJpY2FsIHN0YWJpbGl0eSBvZiB0aGUgY2hhcmFjdGVyIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcub2Zmc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBzbWFsbCBnYXAgdG8gcHJlc2VydmUgYmV0d2VlbiB0aGUgY2hhcmFjdGVyIGFuZCBpdHMgc3Vycm91bmRpbmdzLlxuICAgICAqXG4gICAgICogVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHRvbyBsYXJnZSB0byBhdm9pZCB2aXN1YWwgYXJ0aWZhY3RzLCBidXQgc2hvdWxkbuKAmXQgYmUgdG9vIHNtYWxsXG4gICAgICogKG11c3Qgbm90IGJlIHplcm8pIHRvIGltcHJvdmUgbnVtZXJpY2FsIHN0YWJpbGl0eSBvZiB0aGUgY2hhcmFjdGVyIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgc2V0T2Zmc2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3LnNldE9mZnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIC8vLyBJbmNyZWFzZSB0aGlzIG51bWJlciBpZiB5b3VyIGNoYXJhY3RlciBhcHBlYXJzIHRvIGdldCBzdHVjayB3aGVuIHNsaWRpbmcgYWdhaW5zdCBzdXJmYWNlcy5cbiAgICAvLy9cbiAgICAvLy8gVGhpcyBpcyBhIHNtYWxsIGRpc3RhbmNlIGFwcGxpZWQgdG8gdGhlIG1vdmVtZW50IHRvd2FyZCB0aGUgY29udGFjdCBub3JtYWxzIG9mIHNoYXBlcyBoaXRcbiAgICAvLy8gYnkgdGhlIGNoYXJhY3RlciBjb250cm9sbGVyLiBUaGlzIGhlbHBzIHNoYXBlLWNhc3Rpbmcgbm90IGdldHRpbmcgc3R1Y2sgaW4gYW4gYWx3YXlzLXBlbmV0cmF0aW5nXG4gICAgLy8vIHN0YXRlIGR1cmluZyB0aGUgc2xpZGluZyBjYWxjdWxhdGlvbi5cbiAgICAvLy9cbiAgICAvLy8gVGhpcyB2YWx1ZSBzaG91bGQgcmVtYWluIGZhaXJseSBzbWFsbCBzaW5jZSBpdCBjYW4gaW50cm9kdWNlIGFydGlmaWNpYWwgXCJidW1wc1wiIHdoZW4gc2xpZGluZ1xuICAgIC8vLyBhbG9uZyBhIGZsYXQgc3VyZmFjZS5cbiAgICBub3JtYWxOdWRnZUZhY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3Lm5vcm1hbE51ZGdlRmFjdG9yKCk7XG4gICAgfVxuICAgIC8vLyBJbmNyZWFzZSB0aGlzIG51bWJlciBpZiB5b3VyIGNoYXJhY3RlciBhcHBlYXJzIHRvIGdldCBzdHVjayB3aGVuIHNsaWRpbmcgYWdhaW5zdCBzdXJmYWNlcy5cbiAgICAvLy9cbiAgICAvLy8gVGhpcyBpcyBhIHNtYWxsIGRpc3RhbmNlIGFwcGxpZWQgdG8gdGhlIG1vdmVtZW50IHRvd2FyZCB0aGUgY29udGFjdCBub3JtYWxzIG9mIHNoYXBlcyBoaXRcbiAgICAvLy8gYnkgdGhlIGNoYXJhY3RlciBjb250cm9sbGVyLiBUaGlzIGhlbHBzIHNoYXBlLWNhc3Rpbmcgbm90IGdldHRpbmcgc3R1Y2sgaW4gYW4gYWx3YXlzLXBlbmV0cmF0aW5nXG4gICAgLy8vIHN0YXRlIGR1cmluZyB0aGUgc2xpZGluZyBjYWxjdWxhdGlvbi5cbiAgICAvLy9cbiAgICAvLy8gVGhpcyB2YWx1ZSBzaG91bGQgcmVtYWluIGZhaXJseSBzbWFsbCBzaW5jZSBpdCBjYW4gaW50cm9kdWNlIGFydGlmaWNpYWwgXCJidW1wc1wiIHdoZW4gc2xpZGluZ1xuICAgIC8vLyBhbG9uZyBhIGZsYXQgc3VyZmFjZS5cbiAgICBzZXROb3JtYWxOdWRnZUZhY3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnJhdy5zZXROb3JtYWxOdWRnZUZhY3Rvcih2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHNsaWRpbmcgYWdhaW5zdCBvYnN0YWNsZXMgZW5hYmxlZD9cbiAgICAgKi9cbiAgICBzbGlkZUVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5zbGlkZUVuYWJsZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgc2xpZGluZyBhZ2FpbnN0IG9ic3RhY2xlcy5cbiAgICAgKi9cbiAgICBzZXRTbGlkZUVuYWJsZWQoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnJhdy5zZXRTbGlkZUVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIHN0ZXAgaGVpZ2h0IGEgY2hhcmFjdGVyIGNhbiBhdXRvbWF0aWNhbGx5IHN0ZXAgb3Zlci5cbiAgICAgKi9cbiAgICBhdXRvc3RlcE1heEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3LmF1dG9zdGVwTWF4SGVpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIHdpZHRoIG9mIGZyZWUgc3BhY2UgdGhhdCBtdXN0IGJlIGF2YWlsYWJsZSBhZnRlciBzdGVwcGluZyBvbiBhIHN0YWlyLlxuICAgICAqL1xuICAgIGF1dG9zdGVwTWluV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5hdXRvc3RlcE1pbldpZHRoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbiB0aGUgY2hhcmFjdGVyIGF1dG9tYXRpY2FsbHkgc3RlcCBvdmVyIGR5bmFtaWMgYm9kaWVzIHRvbz9cbiAgICAgKi9cbiAgICBhdXRvc3RlcEluY2x1ZGVzRHluYW1pY0JvZGllcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3LmF1dG9zdGVwSW5jbHVkZXNEeW5hbWljQm9kaWVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIGF1dG9tYXRpY2FsbHkgc3RlcHBpbmcgb3ZlciBzbWFsbCBvYmplY3RzIGVuYWJsZWQ/XG4gICAgICovXG4gICAgYXV0b3N0ZXBFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcuYXV0b3N0ZXBFbmFibGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZWQgYXV0b21hdGljYWxseSBzdGVwcGluZyBvdmVyIHNtYWxsIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWF4SGVpZ2h0IC0gVGhlIG1heGltdW0gc3RlcCBoZWlnaHQgYSBjaGFyYWN0ZXIgY2FuIGF1dG9tYXRpY2FsbHkgc3RlcCBvdmVyLlxuICAgICAqIEBwYXJhbSBtaW5XaWR0aCAtIFRoZSBtaW5pbXVtIHdpZHRoIG9mIGZyZWUgc3BhY2UgdGhhdCBtdXN0IGJlIGF2YWlsYWJsZSBhZnRlciBzdGVwcGluZyBvbiBhIHN0YWlyLlxuICAgICAqIEBwYXJhbSBpbmNsdWRlRHluYW1pY0JvZGllcyAtIENhbiB0aGUgY2hhcmFjdGVyIGF1dG9tYXRpY2FsbHkgc3RlcCBvdmVyIGR5bmFtaWMgYm9kaWVzIHRvbz9cbiAgICAgKi9cbiAgICBlbmFibGVBdXRvc3RlcChtYXhIZWlnaHQsIG1pbldpZHRoLCBpbmNsdWRlRHluYW1pY0JvZGllcykge1xuICAgICAgICB0aGlzLnJhdy5lbmFibGVBdXRvc3RlcChtYXhIZWlnaHQsIG1pbldpZHRoLCBpbmNsdWRlRHluYW1pY0JvZGllcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgYXV0b21hdGljYWxseSBzdGVwcGluZyBvdmVyIHNtYWxsIG9iamVjdHMuXG4gICAgICovXG4gICAgZGlzYWJsZUF1dG9zdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcuZGlzYWJsZUF1dG9zdGVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIGFuZ2xlIChyYWRpYW5zKSBiZXR3ZWVuIHRoZSBmbG9vcuKAmXMgbm9ybWFsIGFuZCB0aGUgYHVwYCB2ZWN0b3IgdGhhdCB0aGVcbiAgICAgKiBjaGFyYWN0ZXIgaXMgYWJsZSB0byBjbGltYi5cbiAgICAgKi9cbiAgICBtYXhTbG9wZUNsaW1iQW5nbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5tYXhTbG9wZUNsaW1iQW5nbGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWF4aW11bSBhbmdsZSAocmFkaWFucykgYmV0d2VlbiB0aGUgZmxvb3LigJlzIG5vcm1hbCBhbmQgdGhlIGB1cGAgdmVjdG9yIHRoYXQgdGhlXG4gICAgICogY2hhcmFjdGVyIGlzIGFibGUgdG8gY2xpbWIuXG4gICAgICovXG4gICAgc2V0TWF4U2xvcGVDbGltYkFuZ2xlKGFuZ2xlKSB7XG4gICAgICAgIHRoaXMucmF3LnNldE1heFNsb3BlQ2xpbWJBbmdsZShhbmdsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIGFuZ2xlIChyYWRpYW5zKSBiZXR3ZWVuIHRoZSBmbG9vcuKAmXMgbm9ybWFsIGFuZCB0aGUgYHVwYCB2ZWN0b3IgYmVmb3JlIHRoZVxuICAgICAqIGNoYXJhY3RlciBzdGFydHMgdG8gc2xpZGUgZG93biBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIG1pblNsb3BlU2xpZGVBbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3Lm1pblNsb3BlU2xpZGVBbmdsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtaW5pbXVtIGFuZ2xlIChyYWRpYW5zKSBiZXR3ZWVuIHRoZSBmbG9vcuKAmXMgbm9ybWFsIGFuZCB0aGUgYHVwYCB2ZWN0b3IgYmVmb3JlIHRoZVxuICAgICAqIGNoYXJhY3RlciBzdGFydHMgdG8gc2xpZGUgZG93biBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIHNldE1pblNsb3BlU2xpZGVBbmdsZShhbmdsZSkge1xuICAgICAgICB0aGlzLnJhdy5zZXRNaW5TbG9wZVNsaWRlQW5nbGUoYW5nbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBzbmFwLXRvLWdyb3VuZCBpcyBlbmFibGVkLCBzaG91bGQgdGhlIGNoYXJhY3RlciBiZSBhdXRvbWF0aWNhbGx5IHNuYXBwZWQgdG8gdGhlIGdyb3VuZCBpZlxuICAgICAqIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBncm91bmQgYW5kIGl0cyBmZWV0IGFyZSBzbWFsbGVyIHRoYW4gdGhlIHNwZWNpZmllZCB0aHJlc2hvbGQ/XG4gICAgICovXG4gICAgc25hcFRvR3JvdW5kRGlzdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5zbmFwVG9Hcm91bmREaXN0YW5jZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGF1dG9tYXRpY2FsbHkgc25hcHBpbmcgdGhlIGNoYXJhY3RlciB0byB0aGUgZ3JvdW5kIGlmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuXG4gICAgICogdGhlIGdyb3VuZCBhbmQgaXRzIGZlZXQgYXJlIHNtYWxsZXIgdGhhbiB0aGUgc3BlY2lmaWVkIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBlbmFibGVTbmFwVG9Hcm91bmQoZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5yYXcuZW5hYmxlU25hcFRvR3JvdW5kKGRpc3RhbmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYXV0b21hdGljYWxseSBzbmFwcGluZyB0aGUgY2hhcmFjdGVyIHRvIHRoZSBncm91bmQuXG4gICAgICovXG4gICAgZGlzYWJsZVNuYXBUb0dyb3VuZCgpIHtcbiAgICAgICAgdGhpcy5yYXcuZGlzYWJsZVNuYXBUb0dyb3VuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyBhdXRvbWF0aWNhbGx5IHNuYXBwaW5nIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIGdyb3VuZCBlbmFibGVkP1xuICAgICAqL1xuICAgIHNuYXBUb0dyb3VuZEVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5zbmFwVG9Hcm91bmRFbmFibGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtb3ZlbWVudCB0aGUgZ2l2ZW4gY29sbGlkZXIgaXMgYWJsZSB0byBleGVjdXRlIGFmdGVyIGhpdHRpbmcgYW5kIHNsaWRpbmcgb24gb2JzdGFjbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVyIC0gVGhlIGNvbGxpZGVyIHRvIG1vdmUuXG4gICAgICogQHBhcmFtIGRlc2lyZWRUcmFuc2xhdGlvbkRlbHRhIC0gVGhlIGRlc2lyZWQgY29sbGlkZXIgbW92ZW1lbnQuXG4gICAgICogQHBhcmFtIGZpbHRlckZsYWdzIC0gRmxhZ3MgZm9yIGV4Y2x1ZGluZyB3aG9sZSBzdWJzZXRzIG9mIGNvbGxpZGVycyBmcm9tIHRoZSBvYnN0YWNsZXMgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBmaWx0ZXJHcm91cHMgLSBHcm91cHMgZm9yIGV4Y2x1ZGluZyBjb2xsaWRlcnMgd2l0aCBpbmNvbXBhdGlibGUgY29sbGlzaW9uIGdyb3VwcyBmcm9tIHRoZSBvYnN0YWNsZXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBmaWx0ZXJQcmVkaWNhdGUgLSBBbnkgY29sbGlkZXIgZm9yIHdoaWNoIHRoaXMgY2xvc3VyZSByZXR1cm5zIGBmYWxzZWAgd2lsbCBiZSBleGNsdWRlZCBmcm9tIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvYnN0YWNsZXMgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAqL1xuICAgIGNvbXB1dGVDb2xsaWRlck1vdmVtZW50KGNvbGxpZGVyLCBkZXNpcmVkVHJhbnNsYXRpb25EZWx0YSwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyUHJlZGljYXRlKSB7XG4gICAgICAgIGxldCByYXdUcmFuc2xhdGlvbkRlbHRhID0gVmVjdG9yT3BzLmludG9SYXcoZGVzaXJlZFRyYW5zbGF0aW9uRGVsdGEpO1xuICAgICAgICB0aGlzLnJhdy5jb21wdXRlQ29sbGlkZXJNb3ZlbWVudCh0aGlzLnBhcmFtcy5kdCwgdGhpcy5ib2RpZXMucmF3LCB0aGlzLmNvbGxpZGVycy5yYXcsIHRoaXMucXVlcmllcy5yYXcsIGNvbGxpZGVyLmhhbmRsZSwgcmF3VHJhbnNsYXRpb25EZWx0YSwgdGhpcy5fYXBwbHlJbXB1bHNlc1RvRHluYW1pY0JvZGllcywgdGhpcy5fY2hhcmFjdGVyTWFzcywgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgdGhpcy5jb2xsaWRlcnMuY2FzdENsb3N1cmUoZmlsdGVyUHJlZGljYXRlKSk7XG4gICAgICAgIHJhd1RyYW5zbGF0aW9uRGVsdGEuZnJlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbW92ZW1lbnQgY29tcHV0ZWQgYnkgdGhlIGxhc3QgY2FsbCB0byBgdGhpcy5jb21wdXRlQ29sbGlkZXJNb3ZlbWVudGAuXG4gICAgICovXG4gICAgY29tcHV0ZWRNb3ZlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3LmNvbXB1dGVkTW92ZW1lbnQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgb2YgZ3JvdW5kIGRldGVjdGlvbiBjb21wdXRlZCBieSB0aGUgbGFzdCBjYWxsIHRvIGB0aGlzLmNvbXB1dGVDb2xsaWRlck1vdmVtZW50YC5cbiAgICAgKi9cbiAgICBjb21wdXRlZEdyb3VuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcuY29tcHV0ZWRHcm91bmRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGNvbGxpc2lvbnMgYWdhaW5zdCBvYnN0YWNsZXMgZGV0ZWN0ZWQgYWxvbmcgdGhlIHBhdGggb2YgdGhlIGxhc3QgY2FsbFxuICAgICAqIHRvIGB0aGlzLmNvbXB1dGVDb2xsaWRlck1vdmVtZW50YC5cbiAgICAgKi9cbiAgICBudW1Db21wdXRlZENvbGxpc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5udW1Db21wdXRlZENvbGxpc2lvbnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29sbGlzaW9uIGFnYWluc3Qgb25lIG9mIHRoZSBvYnN0YWNsZXMgZGV0ZWN0ZWQgYWxvbmcgdGhlIHBhdGggb2YgdGhlIGxhc3RcbiAgICAgKiBjYWxsIHRvIGB0aGlzLmNvbXB1dGVDb2xsaWRlck1vdmVtZW50YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpIC0gVGhlIGktdGggY29sbGlzaW9uIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIG91dCAtIElmIHRoaXMgYXJndW1lbnQgaXMgc2V0LCBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIHRoZSBjb2xsaXNpb24gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgY29tcHV0ZWRDb2xsaXNpb24oaSwgb3V0KSB7XG4gICAgICAgIGlmICghdGhpcy5yYXcuY29tcHV0ZWRDb2xsaXNpb24oaSwgdGhpcy5yYXdDaGFyYWN0ZXJDb2xsaXNpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjID0gdGhpcy5yYXdDaGFyYWN0ZXJDb2xsaXNpb247XG4gICAgICAgICAgICBvdXQgPSBvdXQgIT09IG51bGwgJiYgb3V0ICE9PSB2b2lkIDAgPyBvdXQgOiBuZXcgQ2hhcmFjdGVyQ29sbGlzaW9uKCk7XG4gICAgICAgICAgICBvdXQudHJhbnNsYXRpb25EZWx0YUFwcGxpZWQgPSBWZWN0b3JPcHMuZnJvbVJhdyhjLnRyYW5zbGF0aW9uRGVsdGFBcHBsaWVkKCkpO1xuICAgICAgICAgICAgb3V0LnRyYW5zbGF0aW9uRGVsdGFSZW1haW5pbmcgPSBWZWN0b3JPcHMuZnJvbVJhdyhjLnRyYW5zbGF0aW9uRGVsdGFSZW1haW5pbmcoKSk7XG4gICAgICAgICAgICBvdXQudG9pID0gYy50b2koKTtcbiAgICAgICAgICAgIG91dC53aXRuZXNzMSA9IFZlY3Rvck9wcy5mcm9tUmF3KGMud29ybGRXaXRuZXNzMSgpKTtcbiAgICAgICAgICAgIG91dC53aXRuZXNzMiA9IFZlY3Rvck9wcy5mcm9tUmF3KGMud29ybGRXaXRuZXNzMigpKTtcbiAgICAgICAgICAgIG91dC5ub3JtYWwxID0gVmVjdG9yT3BzLmZyb21SYXcoYy53b3JsZE5vcm1hbDEoKSk7XG4gICAgICAgICAgICBvdXQubm9ybWFsMiA9IFZlY3Rvck9wcy5mcm9tUmF3KGMud29ybGROb3JtYWwyKCkpO1xuICAgICAgICAgICAgb3V0LmNvbGxpZGVyID0gdGhpcy5jb2xsaWRlcnMuZ2V0KGMuaGFuZGxlKCkpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJhY3Rlcl9jb250cm9sbGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/control/character_controller.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/control/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/control/index.js ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _character_controller__WEBPACK_IMPORTED_MODULE_0__.CharacterCollision),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _character_controller__WEBPACK_IMPORTED_MODULE_0__.KinematicCharacterController)\n/* harmony export */ });\n/* harmony import */ var _character_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character_controller */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/control/character_controller.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_character_controller__WEBPACK_IMPORTED_MODULE_0__]);\n_character_controller__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2NvbnRyb2wvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXVDO0FBQ3ZDLGlDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGNvbnRyb2xcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2NoYXJhY3Rlcl9jb250cm9sbGVyXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/control/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CCDSolver: () => (/* binding */ CCDSolver)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nclass CCDSolver {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawCCDSolver();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=ccd_solver.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL2NjZF9zb2x2ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4Qiw4Q0FBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0MiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxcZHluYW1pY3NcXGNjZF9zb2x2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF3Q0NEU29sdmVyIH0gZnJvbSBcIi4uL3Jhd1wiO1xuLyoqXG4gKiBUaGUgQ0NEIHNvbHZlciByZXNwb25zaWJsZSBmb3IgcmVzb2x2aW5nIENvbnRpbnVvdXMgQ29sbGlzaW9uIERldGVjdGlvbi5cbiAqXG4gKiBUbyBhdm9pZCBsZWFraW5nIFdBU00gcmVzb3VyY2VzLCB0aGlzIE1VU1QgYmUgZnJlZWQgbWFudWFsbHkgd2l0aCBgY2NkU29sdmVyLmZyZWUoKWBcbiAqIG9uY2UgeW91IGFyZSBkb25lIHVzaW5nIGl0LlxuICovXG5leHBvcnQgY2xhc3MgQ0NEU29sdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXcgfHwgbmV3IFJhd0NDRFNvbHZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBXQVNNIG1lbW9yeSBvY2N1cGllZCBieSB0aGlzIG5hcnJvdy1waGFzZS5cbiAgICAgKi9cbiAgICBmcmVlKCkge1xuICAgICAgICBpZiAoISF0aGlzLnJhdykge1xuICAgICAgICAgICAgdGhpcy5yYXcuZnJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmF3ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNjZF9zb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoefficientCombineRule: () => (/* binding */ CoefficientCombineRule)\n/* harmony export */ });\n/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nvar CoefficientCombineRule;\n(function (CoefficientCombineRule) {\n    CoefficientCombineRule[CoefficientCombineRule[\"Average\"] = 0] = \"Average\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Min\"] = 1] = \"Min\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Multiply\"] = 2] = \"Multiply\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Max\"] = 3] = \"Max\";\n})(CoefficientCombineRule || (CoefficientCombineRule = {}));\n//# sourceMappingURL=coefficient_combine_rule.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL2NvZWZmaWNpZW50X2NvbWJpbmVfcnVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RDtBQUN6RCIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxkeW5hbWljc1xcY29lZmZpY2llbnRfY29tYmluZV9ydWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBydWxlIGFwcGxpZWQgdG8gY29tYmluZSBjb2VmZmljaWVudHMuXG4gKlxuICogVXNlIHRoaXMgd2hlbiBjb25maWd1cmluZyB0aGUgYENvbGxpZGVyRGVzY2AgdG8gc3BlY2lmeVxuICogaG93IGZyaWN0aW9uIGFuZCByZXN0aXR1dGlvbiBjb2VmZmljaWVudCBzaG91bGQgYmUgY29tYmluZWRcbiAqIGluIGEgY29udGFjdC5cbiAqL1xuZXhwb3J0IHZhciBDb2VmZmljaWVudENvbWJpbmVSdWxlO1xuKGZ1bmN0aW9uIChDb2VmZmljaWVudENvbWJpbmVSdWxlKSB7XG4gICAgQ29lZmZpY2llbnRDb21iaW5lUnVsZVtDb2VmZmljaWVudENvbWJpbmVSdWxlW1wiQXZlcmFnZVwiXSA9IDBdID0gXCJBdmVyYWdlXCI7XG4gICAgQ29lZmZpY2llbnRDb21iaW5lUnVsZVtDb2VmZmljaWVudENvbWJpbmVSdWxlW1wiTWluXCJdID0gMV0gPSBcIk1pblwiO1xuICAgIENvZWZmaWNpZW50Q29tYmluZVJ1bGVbQ29lZmZpY2llbnRDb21iaW5lUnVsZVtcIk11bHRpcGx5XCJdID0gMl0gPSBcIk11bHRpcGx5XCI7XG4gICAgQ29lZmZpY2llbnRDb21iaW5lUnVsZVtDb2VmZmljaWVudENvbWJpbmVSdWxlW1wiTWF4XCJdID0gM10gPSBcIk1heFwiO1xufSkoQ29lZmZpY2llbnRDb21iaW5lUnVsZSB8fCAoQ29lZmZpY2llbnRDb21iaW5lUnVsZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2VmZmljaWVudF9jb21iaW5lX3J1bGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedImpulseJoint: () => (/* binding */ FixedImpulseJoint),\n/* harmony export */   ImpulseJoint: () => (/* binding */ ImpulseJoint),\n/* harmony export */   JointAxesMask: () => (/* binding */ JointAxesMask),\n/* harmony export */   JointData: () => (/* binding */ JointData),\n/* harmony export */   JointType: () => (/* binding */ JointType),\n/* harmony export */   MotorModel: () => (/* binding */ MotorModel),\n/* harmony export */   PrismaticImpulseJoint: () => (/* binding */ PrismaticImpulseJoint),\n/* harmony export */   RevoluteImpulseJoint: () => (/* binding */ RevoluteImpulseJoint),\n/* harmony export */   RopeImpulseJoint: () => (/* binding */ RopeImpulseJoint),\n/* harmony export */   SpringImpulseJoint: () => (/* binding */ SpringImpulseJoint),\n/* harmony export */   UnitImpulseJoint: () => (/* binding */ UnitImpulseJoint)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nvar JointType;\n(function (JointType) {\n    JointType[JointType[\"Revolute\"] = 0] = \"Revolute\";\n    JointType[JointType[\"Fixed\"] = 1] = \"Fixed\";\n    JointType[JointType[\"Prismatic\"] = 2] = \"Prismatic\";\n    JointType[JointType[\"Rope\"] = 3] = \"Rope\";\n    JointType[JointType[\"Spring\"] = 4] = \"Spring\";\n})(JointType || (JointType = {}));\nvar MotorModel;\n(function (MotorModel) {\n    MotorModel[MotorModel[\"AccelerationBased\"] = 0] = \"AccelerationBased\";\n    MotorModel[MotorModel[\"ForceBased\"] = 1] = \"ForceBased\";\n})(MotorModel || (MotorModel = {}));\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.LinX || JointAxesMask.LinY\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nvar JointAxesMask;\n(function (JointAxesMask) {\n    JointAxesMask[JointAxesMask[\"LinX\"] = 1] = \"LinX\";\n    JointAxesMask[JointAxesMask[\"LinY\"] = 2] = \"LinY\";\n    JointAxesMask[JointAxesMask[\"LinZ\"] = 4] = \"LinZ\";\n    JointAxesMask[JointAxesMask[\"AngX\"] = 8] = \"AngX\";\n    JointAxesMask[JointAxesMask[\"AngY\"] = 16] = \"AngY\";\n    JointAxesMask[JointAxesMask[\"AngZ\"] = 32] = \"AngZ\";\n})(JointAxesMask || (JointAxesMask = {}));\nclass ImpulseJoint {\n    constructor(rawSet, bodySet, handle) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, bodySet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Spring:\n                return new SpringImpulseJoint(rawSet, bodySet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Rope:\n                return new RopeImpulseJoint(rawSet, bodySet, handle);\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n    /** @internal */\n    finalizeDeserialization(bodySet) {\n        this.bodySet = bodySet;\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    body1() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    body2() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n    /**\n     * The type of this joint given as a string.\n     */\n    type() {\n        return this.rawSet.jointType(this.handle);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    anchor1() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    anchor2() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    setAnchor1(newPos) {\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    setAnchor2(newPos) {\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nclass UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * Are the limits enabled for this joint?\n     */\n    limitsEnabled() {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n    /**\n     * The min limit of this joint.\n     */\n    limitsMin() {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n    /**\n     * The max limit of this joint.\n     */\n    limitsMax() {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joint’s free coordinate.\n     * @param max - The maximum bound of this joint’s free coordinate.\n     */\n    setLimits(min, max) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n    configureMotorModel(model) {\n        this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    }\n    configureMotorVelocity(targetVel, factor) {\n        this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    }\n    configureMotorPosition(targetPos, stiffness, damping) {\n        this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    }\n    configureMotor(targetPos, targetVel, stiffness, damping) {\n        this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    }\n}\nclass FixedImpulseJoint extends ImpulseJoint {\n}\nclass RopeImpulseJoint extends ImpulseJoint {\n}\nclass SpringImpulseJoint extends ImpulseJoint {\n}\nclass PrismaticImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis.LinX;\n    }\n}\nclass RevoluteImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis.AngX;\n    }\n}\nclass JointData {\n    constructor() { }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    static fixed(anchor1, frame1, anchor2, frame2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = rest_length;\n        res.stiffness = stiffness;\n        res.damping = damping;\n        res.jointType = JointType.Spring;\n        return res;\n    }\n    static rope(length, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = length;\n        res.jointType = JointType.Rope;\n        return res;\n    }\n    // #if DIM2\n    /**\n     * Create a new joint descriptor that builds revolute joints.\n     *\n     * A revolute joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    static revolute(anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static prismatic(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n    // #endif\n    intoRaw() {\n        let rawA1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.anchor1);\n        let rawA2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(this.frame1);\n                let rawFra2 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(this.frame2);\n                result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Spring:\n                result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint.spring(this.length, this.stiffness, this.damping, rawA1, rawA2);\n                break;\n            case JointType.Rope:\n                result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint.rope(this.length, rawA1, rawA2);\n                break;\n            case JointType.Prismatic:\n                rawAx = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.axis);\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n                // #if DIM2\n                result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);\n                // #endif\n                rawAx.free();\n                break;\n            // #if DIM2\n            case JointType.Revolute:\n                result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint.revolute(rawA1, rawA2);\n                break;\n            // #endif\n        }\n        rawA1.free();\n        rawA2.free();\n        return result;\n    }\n}\n//# sourceMappingURL=impulse_joint.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL2ltcHVsc2Vfam9pbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUN4QjtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUNoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFZO0FBQzdCO0FBQ0EsaUJBQWlCLDhDQUFZO0FBQzdCO0FBQ0EsaUJBQWlCLDhDQUFZO0FBQzdCO0FBQ0EsaUJBQWlCLDhDQUFZO0FBQzdCO0FBQ0EsaUJBQWlCLDhDQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxlQUFlLDhDQUFZO0FBQzNCO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSw4Q0FBWTtBQUMzQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFTO0FBQzdCLG9CQUFvQiw0Q0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBVztBQUN6Qyw4QkFBOEIsOENBQVc7QUFDekMseUJBQXlCLGlEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFlO0FBQ3hDO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWU7QUFDeEM7QUFDQTtBQUNBLHdCQUF3Qiw0Q0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUMiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxcZHluYW1pY3NcXGltcHVsc2Vfam9pbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yT3BzLCBSb3RhdGlvbk9wcyB9IGZyb20gXCIuLi9tYXRoXCI7XG5pbXBvcnQgeyBSYXdHZW5lcmljSm9pbnQsIFJhd0pvaW50QXhpcywgUmF3Sm9pbnRUeXBlLCB9IGZyb20gXCIuLi9yYXdcIjtcbi8qKlxuICogQW4gZW51bSBncm91cGluZyBhbGwgcG9zc2libGUgdHlwZXMgb2Ygam9pbnRzOlxuICpcbiAqIC0gYFJldm9sdXRlYDogQSByZXZvbHV0ZSBqb2ludCB0aGF0IHJlbW92ZXMgYWxsIGRlZ3JlZXMgb2YgZnJlZWRvbSBiZXR3ZWVuIHRoZSBhZmZlY3RlZFxuICogICAgICAgICAgICAgICBib2RpZXMgZXhjZXB0IGZvciB0aGUgcm90YXRpb24gYWxvbmcgb25lIGF4aXMuXG4gKiAtIGBGaXhlZGA6IEEgZml4ZWQgam9pbnQgdGhhdCByZW1vdmVzIGFsbCByZWxhdGl2ZSBkZWdyZWVzIG9mIGZyZWVkb20gYmV0d2VlbiB0aGUgYWZmZWN0ZWQgYm9kaWVzLlxuICogLSBgUHJpc21hdGljYDogQSBwcmlzbWF0aWMgam9pbnQgdGhhdCByZW1vdmVzIGFsbCBkZWdyZWVzIG9mIGZyZWVkb20gYmV0d2VlbiB0aGUgYWZmZWN0ZWRcbiAqICAgICAgICAgICAgICAgIGJvZGllcyBleGNlcHQgZm9yIHRoZSB0cmFuc2xhdGlvbiBhbG9uZyBvbmUgYXhpcy5cbiAqIC0gYFNwaGVyaWNhbGA6ICgzRCBvbmx5KSBBIHNwaGVyaWNhbCBqb2ludCB0aGF0IHJlbW92ZXMgYWxsIHJlbGF0aXZlIGxpbmVhciBkZWdyZWVzIG9mIGZyZWVkb20gYmV0d2VlbiB0aGUgYWZmZWN0ZWQgYm9kaWVzLlxuICogLSBgR2VuZXJpY2A6ICgzRCBvbmx5KSBBIGpvaW50IHdpdGggY3VzdG9taXphYmxlIGRlZ3JlZXMgb2YgZnJlZWRvbSwgYWxsb3dpbmcgYW55IG9mIHRoZSA2IGF4ZXMgdG8gYmUgbG9ja2VkLlxuICovXG5leHBvcnQgdmFyIEpvaW50VHlwZTtcbihmdW5jdGlvbiAoSm9pbnRUeXBlKSB7XG4gICAgSm9pbnRUeXBlW0pvaW50VHlwZVtcIlJldm9sdXRlXCJdID0gMF0gPSBcIlJldm9sdXRlXCI7XG4gICAgSm9pbnRUeXBlW0pvaW50VHlwZVtcIkZpeGVkXCJdID0gMV0gPSBcIkZpeGVkXCI7XG4gICAgSm9pbnRUeXBlW0pvaW50VHlwZVtcIlByaXNtYXRpY1wiXSA9IDJdID0gXCJQcmlzbWF0aWNcIjtcbiAgICBKb2ludFR5cGVbSm9pbnRUeXBlW1wiUm9wZVwiXSA9IDNdID0gXCJSb3BlXCI7XG4gICAgSm9pbnRUeXBlW0pvaW50VHlwZVtcIlNwcmluZ1wiXSA9IDRdID0gXCJTcHJpbmdcIjtcbn0pKEpvaW50VHlwZSB8fCAoSm9pbnRUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgTW90b3JNb2RlbDtcbihmdW5jdGlvbiAoTW90b3JNb2RlbCkge1xuICAgIE1vdG9yTW9kZWxbTW90b3JNb2RlbFtcIkFjY2VsZXJhdGlvbkJhc2VkXCJdID0gMF0gPSBcIkFjY2VsZXJhdGlvbkJhc2VkXCI7XG4gICAgTW90b3JNb2RlbFtNb3Rvck1vZGVsW1wiRm9yY2VCYXNlZFwiXSA9IDFdID0gXCJGb3JjZUJhc2VkXCI7XG59KShNb3Rvck1vZGVsIHx8IChNb3Rvck1vZGVsID0ge30pKTtcbi8qKlxuICogQW4gZW51bSByZXByZXNlbnRpbmcgdGhlIHBvc3NpYmxlIGpvaW50IGF4ZXMgb2YgYSBnZW5lcmljIGpvaW50LlxuICogVGhleSBjYW4gYmUgT1JlZCB0b2dldGhlciwgbGlrZTpcbiAqIEpvaW50QXhlc01hc2suTGluWCB8fCBKb2ludEF4ZXNNYXNrLkxpbllcbiAqIHRvIGdldCBhIGpvaW50IHRoYXQgaXMgb25seSBmcmVlIGluIHRoZSBYIGFuZCBZIHRyYW5zbGF0aW9uYWwgKHBvc2l0aW9uYWwpIGF4ZXMuXG4gKlxuICogUG9zc2libGUgZnJlZSBheGVzIGFyZTpcbiAqXG4gKiAtIGBYYDogWCB0cmFuc2xhdGlvbiBheGlzXG4gKiAtIGBZYDogWSB0cmFuc2xhdGlvbiBheGlzXG4gKiAtIGBaYDogWiB0cmFuc2xhdGlvbiBheGlzXG4gKiAtIGBBbmdYYDogWCBhbmd1bGFyIHJvdGF0aW9uIGF4aXNcbiAqIC0gYEFuZ1lgOiBZIGFuZ3VsYXIgcm90YXRpb25zIGF4aXNcbiAqIC0gYEFuZ1pgOiBaIGFuZ3VsYXIgcm90YXRpb24gYXhpc1xuICovXG5leHBvcnQgdmFyIEpvaW50QXhlc01hc2s7XG4oZnVuY3Rpb24gKEpvaW50QXhlc01hc2spIHtcbiAgICBKb2ludEF4ZXNNYXNrW0pvaW50QXhlc01hc2tbXCJMaW5YXCJdID0gMV0gPSBcIkxpblhcIjtcbiAgICBKb2ludEF4ZXNNYXNrW0pvaW50QXhlc01hc2tbXCJMaW5ZXCJdID0gMl0gPSBcIkxpbllcIjtcbiAgICBKb2ludEF4ZXNNYXNrW0pvaW50QXhlc01hc2tbXCJMaW5aXCJdID0gNF0gPSBcIkxpblpcIjtcbiAgICBKb2ludEF4ZXNNYXNrW0pvaW50QXhlc01hc2tbXCJBbmdYXCJdID0gOF0gPSBcIkFuZ1hcIjtcbiAgICBKb2ludEF4ZXNNYXNrW0pvaW50QXhlc01hc2tbXCJBbmdZXCJdID0gMTZdID0gXCJBbmdZXCI7XG4gICAgSm9pbnRBeGVzTWFza1tKb2ludEF4ZXNNYXNrW1wiQW5nWlwiXSA9IDMyXSA9IFwiQW5nWlwiO1xufSkoSm9pbnRBeGVzTWFzayB8fCAoSm9pbnRBeGVzTWFzayA9IHt9KSk7XG5leHBvcnQgY2xhc3MgSW1wdWxzZUpvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihyYXdTZXQsIGJvZHlTZXQsIGhhbmRsZSkge1xuICAgICAgICB0aGlzLnJhd1NldCA9IHJhd1NldDtcbiAgICAgICAgdGhpcy5ib2R5U2V0ID0gYm9keVNldDtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBoYW5kbGU7XG4gICAgfVxuICAgIHN0YXRpYyBuZXdUeXBlZChyYXdTZXQsIGJvZHlTZXQsIGhhbmRsZSkge1xuICAgICAgICBzd2l0Y2ggKHJhd1NldC5qb2ludFR5cGUoaGFuZGxlKSkge1xuICAgICAgICAgICAgY2FzZSBSYXdKb2ludFR5cGUuUmV2b2x1dGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXZvbHV0ZUltcHVsc2VKb2ludChyYXdTZXQsIGJvZHlTZXQsIGhhbmRsZSk7XG4gICAgICAgICAgICBjYXNlIFJhd0pvaW50VHlwZS5QcmlzbWF0aWM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmlzbWF0aWNJbXB1bHNlSm9pbnQocmF3U2V0LCBib2R5U2V0LCBoYW5kbGUpO1xuICAgICAgICAgICAgY2FzZSBSYXdKb2ludFR5cGUuRml4ZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEltcHVsc2VKb2ludChyYXdTZXQsIGJvZHlTZXQsIGhhbmRsZSk7XG4gICAgICAgICAgICBjYXNlIFJhd0pvaW50VHlwZS5TcHJpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTcHJpbmdJbXB1bHNlSm9pbnQocmF3U2V0LCBib2R5U2V0LCBoYW5kbGUpO1xuICAgICAgICAgICAgY2FzZSBSYXdKb2ludFR5cGUuUm9wZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJvcGVJbXB1bHNlSm9pbnQocmF3U2V0LCBib2R5U2V0LCBoYW5kbGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltcHVsc2VKb2ludChyYXdTZXQsIGJvZHlTZXQsIGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZpbmFsaXplRGVzZXJpYWxpemF0aW9uKGJvZHlTZXQpIHtcbiAgICAgICAgdGhpcy5ib2R5U2V0ID0gYm9keVNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgam9pbnQgaXMgc3RpbGwgdmFsaWQgKGkuZS4gdGhhdCBpdCBoYXNcbiAgICAgKiBub3QgYmVlbiBkZWxldGVkIGZyb20gdGhlIGpvaW50IHNldCB5ZXQpLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5jb250YWlucyh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCByaWdpZC1ib2R5IHRoaXMgam9pbnQgaXQgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgYm9keTEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHlTZXQuZ2V0KHRoaXMucmF3U2V0LmpvaW50Qm9keUhhbmRsZTEodGhpcy5oYW5kbGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZCByaWdpZC1ib2R5IHRoaXMgam9pbnQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgYm9keTIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHlTZXQuZ2V0KHRoaXMucmF3U2V0LmpvaW50Qm9keUhhbmRsZTIodGhpcy5oYW5kbGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBqb2ludCBnaXZlbiBhcyBhIHN0cmluZy5cbiAgICAgKi9cbiAgICB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQuam9pbnRUeXBlKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhpcyBqb2ludC5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCBhbmNob3IgZ2l2ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbiBwb2ludCBvbiB0aGVcbiAgICAgKiBsb2NhbCBmcmFtZSBvZiB0aGUgZmlyc3QgcmlnaWQtYm9keSBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAgKi9cbiAgICBhbmNob3IxKCkge1xuICAgICAgICByZXR1cm4gVmVjdG9yT3BzLmZyb21SYXcodGhpcy5yYXdTZXQuam9pbnRBbmNob3IxKHRoaXMuaGFuZGxlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGlzIGpvaW50LlxuICAgICAqXG4gICAgICogVGhlIHNlY29uZCBhbmNob3IgZ2l2ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbiBwb2ludCBvbiB0aGVcbiAgICAgKiBsb2NhbCBmcmFtZSBvZiB0aGUgc2Vjb25kIHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgYW5jaG9yMigpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3U2V0LmpvaW50QW5jaG9yMih0aGlzLmhhbmRsZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgYW5jaG9yIG9mIHRoaXMgam9pbnQuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgYW5jaG9yIGdpdmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgYXBwbGljYXRpb24gcG9pbnQgb24gdGhlXG4gICAgICogbG9jYWwgZnJhbWUgb2YgdGhlIGZpcnN0IHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgc2V0QW5jaG9yMShuZXdQb3MpIHtcbiAgICAgICAgY29uc3QgcmF3UG9pbnQgPSBWZWN0b3JPcHMuaW50b1JhdyhuZXdQb3MpO1xuICAgICAgICB0aGlzLnJhd1NldC5qb2ludFNldEFuY2hvcjEodGhpcy5oYW5kbGUsIHJhd1BvaW50KTtcbiAgICAgICAgcmF3UG9pbnQuZnJlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGlzIGpvaW50LlxuICAgICAqXG4gICAgICogVGhlIHNlY29uZCBhbmNob3IgZ2l2ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbiBwb2ludCBvbiB0aGVcbiAgICAgKiBsb2NhbCBmcmFtZSBvZiB0aGUgc2Vjb25kIHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgc2V0QW5jaG9yMihuZXdQb3MpIHtcbiAgICAgICAgY29uc3QgcmF3UG9pbnQgPSBWZWN0b3JPcHMuaW50b1JhdyhuZXdQb3MpO1xuICAgICAgICB0aGlzLnJhd1NldC5qb2ludFNldEFuY2hvcjIodGhpcy5oYW5kbGUsIHJhd1BvaW50KTtcbiAgICAgICAgcmF3UG9pbnQuZnJlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGV0aGVyIGNvbnRhY3RzIGFyZSBjb21wdXRlZCBiZXR3ZWVuIGNvbGxpZGVycyBhdHRhY2hlZFxuICAgICAqIHRvIHRoZSByaWdpZC1ib2RpZXMgbGlua2VkIGJ5IHRoaXMgam9pbnQuXG4gICAgICovXG4gICAgc2V0Q29udGFjdHNFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yYXdTZXQuam9pbnRTZXRDb250YWN0c0VuYWJsZWQodGhpcy5oYW5kbGUsIGVuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgY29udGFjdHMgYXJlIGVuYWJsZWQgYmV0d2VlbiBjb2xsaWRlcnMgYXR0YWNoZWRcbiAgICAgKiB0byB0aGUgcmlnaWQtYm9kaWVzIGxpbmtlZCBieSB0aGlzIGpvaW50LlxuICAgICAqL1xuICAgIGNvbnRhY3RzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LmpvaW50Q29udGFjdHNFbmFibGVkKHRoaXMuaGFuZGxlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5pdEltcHVsc2VKb2ludCBleHRlbmRzIEltcHVsc2VKb2ludCB7XG4gICAgLyoqXG4gICAgICogQXJlIHRoZSBsaW1pdHMgZW5hYmxlZCBmb3IgdGhpcyBqb2ludD9cbiAgICAgKi9cbiAgICBsaW1pdHNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQuam9pbnRMaW1pdHNFbmFibGVkKHRoaXMuaGFuZGxlLCB0aGlzLnJhd0F4aXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtaW4gbGltaXQgb2YgdGhpcyBqb2ludC5cbiAgICAgKi9cbiAgICBsaW1pdHNNaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5qb2ludExpbWl0c01pbih0aGlzLmhhbmRsZSwgdGhpcy5yYXdBeGlzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4IGxpbWl0IG9mIHRoaXMgam9pbnQuXG4gICAgICovXG4gICAgbGltaXRzTWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQuam9pbnRMaW1pdHNNYXgodGhpcy5oYW5kbGUsIHRoaXMucmF3QXhpcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGltaXRzIG9mIHRoaXMgam9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluIC0gVGhlIG1pbmltdW0gYm91bmQgb2YgdGhpcyBqb2ludOKAmXMgZnJlZSBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSBtYXggLSBUaGUgbWF4aW11bSBib3VuZCBvZiB0aGlzIGpvaW504oCZcyBmcmVlIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgc2V0TGltaXRzKG1pbiwgbWF4KSB7XG4gICAgICAgIHRoaXMucmF3U2V0LmpvaW50U2V0TGltaXRzKHRoaXMuaGFuZGxlLCB0aGlzLnJhd0F4aXMoKSwgbWluLCBtYXgpO1xuICAgIH1cbiAgICBjb25maWd1cmVNb3Rvck1vZGVsKG1vZGVsKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LmpvaW50Q29uZmlndXJlTW90b3JNb2RlbCh0aGlzLmhhbmRsZSwgdGhpcy5yYXdBeGlzKCksIG1vZGVsKTtcbiAgICB9XG4gICAgY29uZmlndXJlTW90b3JWZWxvY2l0eSh0YXJnZXRWZWwsIGZhY3Rvcikge1xuICAgICAgICB0aGlzLnJhd1NldC5qb2ludENvbmZpZ3VyZU1vdG9yVmVsb2NpdHkodGhpcy5oYW5kbGUsIHRoaXMucmF3QXhpcygpLCB0YXJnZXRWZWwsIGZhY3Rvcik7XG4gICAgfVxuICAgIGNvbmZpZ3VyZU1vdG9yUG9zaXRpb24odGFyZ2V0UG9zLCBzdGlmZm5lc3MsIGRhbXBpbmcpIHtcbiAgICAgICAgdGhpcy5yYXdTZXQuam9pbnRDb25maWd1cmVNb3RvclBvc2l0aW9uKHRoaXMuaGFuZGxlLCB0aGlzLnJhd0F4aXMoKSwgdGFyZ2V0UG9zLCBzdGlmZm5lc3MsIGRhbXBpbmcpO1xuICAgIH1cbiAgICBjb25maWd1cmVNb3Rvcih0YXJnZXRQb3MsIHRhcmdldFZlbCwgc3RpZmZuZXNzLCBkYW1waW5nKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LmpvaW50Q29uZmlndXJlTW90b3IodGhpcy5oYW5kbGUsIHRoaXMucmF3QXhpcygpLCB0YXJnZXRQb3MsIHRhcmdldFZlbCwgc3RpZmZuZXNzLCBkYW1waW5nKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRml4ZWRJbXB1bHNlSm9pbnQgZXh0ZW5kcyBJbXB1bHNlSm9pbnQge1xufVxuZXhwb3J0IGNsYXNzIFJvcGVJbXB1bHNlSm9pbnQgZXh0ZW5kcyBJbXB1bHNlSm9pbnQge1xufVxuZXhwb3J0IGNsYXNzIFNwcmluZ0ltcHVsc2VKb2ludCBleHRlbmRzIEltcHVsc2VKb2ludCB7XG59XG5leHBvcnQgY2xhc3MgUHJpc21hdGljSW1wdWxzZUpvaW50IGV4dGVuZHMgVW5pdEltcHVsc2VKb2ludCB7XG4gICAgcmF3QXhpcygpIHtcbiAgICAgICAgcmV0dXJuIFJhd0pvaW50QXhpcy5MaW5YO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZXZvbHV0ZUltcHVsc2VKb2ludCBleHRlbmRzIFVuaXRJbXB1bHNlSm9pbnQge1xuICAgIHJhd0F4aXMoKSB7XG4gICAgICAgIHJldHVybiBSYXdKb2ludEF4aXMuQW5nWDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSm9pbnREYXRhIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgam9pbnQgZGVzY3JpcHRvciB0aGF0IGJ1aWxkcyBhIEZpeGVkIGpvaW50LlxuICAgICAqXG4gICAgICogQSBmaXhlZCBqb2ludCByZW1vdmVzIGFsbCB0aGUgZGVncmVlcyBvZiBmcmVlZG9tIGJldHdlZW4gdGhlIGFmZmVjdGVkIGJvZGllcywgZW5zdXJpbmcgdGhlaXJcbiAgICAgKiBhbmNob3IgYW5kIGxvY2FsIGZyYW1lcyBjb2luY2lkZSBpbiB3b3JsZC1zcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbmNob3IxIC0gUG9pbnQgd2hlcmUgdGhlIGpvaW50IGlzIGF0dGFjaGVkIG9uIHRoZSBmaXJzdCByaWdpZC1ib2R5IGFmZmVjdGVkIGJ5IHRoaXMgam9pbnQuIEV4cHJlc3NlZCBpbiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgIGxvY2FsLXNwYWNlIG9mIHRoZSByaWdpZC1ib2R5LlxuICAgICAqIEBwYXJhbSBmcmFtZTEgLSBUaGUgcmVmZXJlbmNlIG9yaWVudGF0aW9uIG9mIHRoZSBqb2ludCB3cnQuIHRoZSBmaXJzdCByaWdpZC1ib2R5LlxuICAgICAqIEBwYXJhbSBhbmNob3IyIC0gUG9pbnQgd2hlcmUgdGhlIGpvaW50IGlzIGF0dGFjaGVkIG9uIHRoZSBzZWNvbmQgcmlnaWQtYm9keSBhZmZlY3RlZCBieSB0aGlzIGpvaW50LiBFeHByZXNzZWQgaW4gdGhlXG4gICAgICogICAgICAgICAgICAgICAgICBsb2NhbC1zcGFjZSBvZiB0aGUgcmlnaWQtYm9keS5cbiAgICAgKiBAcGFyYW0gZnJhbWUyIC0gVGhlIHJlZmVyZW5jZSBvcmllbnRhdGlvbiBvZiB0aGUgam9pbnQgd3J0LiB0aGUgc2Vjb25kIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgc3RhdGljIGZpeGVkKGFuY2hvcjEsIGZyYW1lMSwgYW5jaG9yMiwgZnJhbWUyKSB7XG4gICAgICAgIGxldCByZXMgPSBuZXcgSm9pbnREYXRhKCk7XG4gICAgICAgIHJlcy5hbmNob3IxID0gYW5jaG9yMTtcbiAgICAgICAgcmVzLmFuY2hvcjIgPSBhbmNob3IyO1xuICAgICAgICByZXMuZnJhbWUxID0gZnJhbWUxO1xuICAgICAgICByZXMuZnJhbWUyID0gZnJhbWUyO1xuICAgICAgICByZXMuam9pbnRUeXBlID0gSm9pbnRUeXBlLkZpeGVkO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgc3ByaW5nKHJlc3RfbGVuZ3RoLCBzdGlmZm5lc3MsIGRhbXBpbmcsIGFuY2hvcjEsIGFuY2hvcjIpIHtcbiAgICAgICAgbGV0IHJlcyA9IG5ldyBKb2ludERhdGEoKTtcbiAgICAgICAgcmVzLmFuY2hvcjEgPSBhbmNob3IxO1xuICAgICAgICByZXMuYW5jaG9yMiA9IGFuY2hvcjI7XG4gICAgICAgIHJlcy5sZW5ndGggPSByZXN0X2xlbmd0aDtcbiAgICAgICAgcmVzLnN0aWZmbmVzcyA9IHN0aWZmbmVzcztcbiAgICAgICAgcmVzLmRhbXBpbmcgPSBkYW1waW5nO1xuICAgICAgICByZXMuam9pbnRUeXBlID0gSm9pbnRUeXBlLlNwcmluZztcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIHJvcGUobGVuZ3RoLCBhbmNob3IxLCBhbmNob3IyKSB7XG4gICAgICAgIGxldCByZXMgPSBuZXcgSm9pbnREYXRhKCk7XG4gICAgICAgIHJlcy5hbmNob3IxID0gYW5jaG9yMTtcbiAgICAgICAgcmVzLmFuY2hvcjIgPSBhbmNob3IyO1xuICAgICAgICByZXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICByZXMuam9pbnRUeXBlID0gSm9pbnRUeXBlLlJvcGU7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGpvaW50IGRlc2NyaXB0b3IgdGhhdCBidWlsZHMgcmV2b2x1dGUgam9pbnRzLlxuICAgICAqXG4gICAgICogQSByZXZvbHV0ZSBqb2ludCBhbGxvd3MgdGhyZWUgcmVsYXRpdmUgcm90YXRpb25hbCBkZWdyZWVzIG9mIGZyZWVkb21cbiAgICAgKiBieSBwcmV2ZW50aW5nIGFueSByZWxhdGl2ZSB0cmFuc2xhdGlvbiBiZXR3ZWVuIHRoZSBhbmNob3JzIG9mIHRoZVxuICAgICAqIHR3byBhdHRhY2hlZCByaWdpZC1ib2RpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5jaG9yMSAtIFBvaW50IHdoZXJlIHRoZSBqb2ludCBpcyBhdHRhY2hlZCBvbiB0aGUgZmlyc3QgcmlnaWQtYm9keSBhZmZlY3RlZCBieSB0aGlzIGpvaW50LiBFeHByZXNzZWQgaW4gdGhlXG4gICAgICogICAgICAgICAgICAgICAgICBsb2NhbC1zcGFjZSBvZiB0aGUgcmlnaWQtYm9keS5cbiAgICAgKiBAcGFyYW0gYW5jaG9yMiAtIFBvaW50IHdoZXJlIHRoZSBqb2ludCBpcyBhdHRhY2hlZCBvbiB0aGUgc2Vjb25kIHJpZ2lkLWJvZHkgYWZmZWN0ZWQgYnkgdGhpcyBqb2ludC4gRXhwcmVzc2VkIGluIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgbG9jYWwtc3BhY2Ugb2YgdGhlIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgc3RhdGljIHJldm9sdXRlKGFuY2hvcjEsIGFuY2hvcjIpIHtcbiAgICAgICAgbGV0IHJlcyA9IG5ldyBKb2ludERhdGEoKTtcbiAgICAgICAgcmVzLmFuY2hvcjEgPSBhbmNob3IxO1xuICAgICAgICByZXMuYW5jaG9yMiA9IGFuY2hvcjI7XG4gICAgICAgIHJlcy5qb2ludFR5cGUgPSBKb2ludFR5cGUuUmV2b2x1dGU7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgam9pbnQgZGVzY3JpcHRvciB0aGF0IGJ1aWxkcyBhIFByaXNtYXRpYyBqb2ludC5cbiAgICAgKlxuICAgICAqIEEgcHJpc21hdGljIGpvaW50IHJlbW92ZXMgYWxsIHRoZSBkZWdyZWVzIG9mIGZyZWVkb20gYmV0d2VlbiB0aGVcbiAgICAgKiBhZmZlY3RlZCBib2RpZXMsIGV4Y2VwdCBmb3IgdGhlIHRyYW5zbGF0aW9uIGFsb25nIG9uZSBheGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFuY2hvcjEgLSBQb2ludCB3aGVyZSB0aGUgam9pbnQgaXMgYXR0YWNoZWQgb24gdGhlIGZpcnN0IHJpZ2lkLWJvZHkgYWZmZWN0ZWQgYnkgdGhpcyBqb2ludC4gRXhwcmVzc2VkIGluIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgbG9jYWwtc3BhY2Ugb2YgdGhlIHJpZ2lkLWJvZHkuXG4gICAgICogQHBhcmFtIGFuY2hvcjIgLSBQb2ludCB3aGVyZSB0aGUgam9pbnQgaXMgYXR0YWNoZWQgb24gdGhlIHNlY29uZCByaWdpZC1ib2R5IGFmZmVjdGVkIGJ5IHRoaXMgam9pbnQuIEV4cHJlc3NlZCBpbiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgIGxvY2FsLXNwYWNlIG9mIHRoZSByaWdpZC1ib2R5LlxuICAgICAqIEBwYXJhbSBheGlzIC0gQXhpcyBvZiB0aGUgam9pbnQsIGV4cHJlc3NlZCBpbiB0aGUgbG9jYWwtc3BhY2Ugb2YgdGhlIHJpZ2lkLWJvZGllcyBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAgKi9cbiAgICBzdGF0aWMgcHJpc21hdGljKGFuY2hvcjEsIGFuY2hvcjIsIGF4aXMpIHtcbiAgICAgICAgbGV0IHJlcyA9IG5ldyBKb2ludERhdGEoKTtcbiAgICAgICAgcmVzLmFuY2hvcjEgPSBhbmNob3IxO1xuICAgICAgICByZXMuYW5jaG9yMiA9IGFuY2hvcjI7XG4gICAgICAgIHJlcy5heGlzID0gYXhpcztcbiAgICAgICAgcmVzLmpvaW50VHlwZSA9IEpvaW50VHlwZS5QcmlzbWF0aWM7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8vICNlbmRpZlxuICAgIGludG9SYXcoKSB7XG4gICAgICAgIGxldCByYXdBMSA9IFZlY3Rvck9wcy5pbnRvUmF3KHRoaXMuYW5jaG9yMSk7XG4gICAgICAgIGxldCByYXdBMiA9IFZlY3Rvck9wcy5pbnRvUmF3KHRoaXMuYW5jaG9yMik7XG4gICAgICAgIGxldCByYXdBeDtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGxpbWl0c0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGxpbWl0c01pbiA9IDAuMDtcbiAgICAgICAgbGV0IGxpbWl0c01heCA9IDAuMDtcbiAgICAgICAgc3dpdGNoICh0aGlzLmpvaW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBKb2ludFR5cGUuRml4ZWQ6XG4gICAgICAgICAgICAgICAgbGV0IHJhd0ZyYTEgPSBSb3RhdGlvbk9wcy5pbnRvUmF3KHRoaXMuZnJhbWUxKTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3RnJhMiA9IFJvdGF0aW9uT3BzLmludG9SYXcodGhpcy5mcmFtZTIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFJhd0dlbmVyaWNKb2ludC5maXhlZChyYXdBMSwgcmF3RnJhMSwgcmF3QTIsIHJhd0ZyYTIpO1xuICAgICAgICAgICAgICAgIHJhd0ZyYTEuZnJlZSgpO1xuICAgICAgICAgICAgICAgIHJhd0ZyYTIuZnJlZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBKb2ludFR5cGUuU3ByaW5nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFJhd0dlbmVyaWNKb2ludC5zcHJpbmcodGhpcy5sZW5ndGgsIHRoaXMuc3RpZmZuZXNzLCB0aGlzLmRhbXBpbmcsIHJhd0ExLCByYXdBMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5Sb3BlOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFJhd0dlbmVyaWNKb2ludC5yb3BlKHRoaXMubGVuZ3RoLCByYXdBMSwgcmF3QTIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBKb2ludFR5cGUuUHJpc21hdGljOlxuICAgICAgICAgICAgICAgIHJhd0F4ID0gVmVjdG9yT3BzLmludG9SYXcodGhpcy5heGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoISF0aGlzLmxpbWl0c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGltaXRzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0c01pbiA9IHRoaXMubGltaXRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBsaW1pdHNNYXggPSB0aGlzLmxpbWl0c1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBSYXdHZW5lcmljSm9pbnQucHJpc21hdGljKHJhd0ExLCByYXdBMiwgcmF3QXgsIGxpbWl0c0VuYWJsZWQsIGxpbWl0c01pbiwgbGltaXRzTWF4KTtcbiAgICAgICAgICAgICAgICAvLyAjZW5kaWZcbiAgICAgICAgICAgICAgICByYXdBeC5mcmVlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyAjaWYgRElNMlxuICAgICAgICAgICAgY2FzZSBKb2ludFR5cGUuUmV2b2x1dGU6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gUmF3R2VuZXJpY0pvaW50LnJldm9sdXRlKHJhd0ExLCByYXdBMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyAjZW5kaWZcbiAgICAgICAgfVxuICAgICAgICByYXdBMS5mcmVlKCk7XG4gICAgICAgIHJhd0EyLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbXB1bHNlX2pvaW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImpulseJointSet: () => (/* binding */ ImpulseJointSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impulse_joint */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nclass ImpulseJointSet {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawImpulseJointSet();\n        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(bodies, desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = _impulse_joint__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wakeUp) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=impulse_joint_set.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL2ltcHVsc2Vfam9pbnRfc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEM7QUFDUDtBQUNXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw4QkFBOEIsb0RBQWtCO0FBQ2hELHVCQUF1Qiw2Q0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0RBQVk7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkMiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxcZHluYW1pY3NcXGltcHVsc2Vfam9pbnRfc2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJhd0ltcHVsc2VKb2ludFNldCB9IGZyb20gXCIuLi9yYXdcIjtcbmltcG9ydCB7IENvYXJlbmEgfSBmcm9tIFwiLi4vY29hcmVuYVwiO1xuaW1wb3J0IHsgSW1wdWxzZUpvaW50LCB9IGZyb20gXCIuL2ltcHVsc2Vfam9pbnRcIjtcbi8qKlxuICogQSBzZXQgb2Ygam9pbnRzLlxuICpcbiAqIFRvIGF2b2lkIGxlYWtpbmcgV0FTTSByZXNvdXJjZXMsIHRoaXMgTVVTVCBiZSBmcmVlZCBtYW51YWxseSB3aXRoIGBqb2ludFNldC5mcmVlKClgXG4gKiBvbmNlIHlvdSBhcmUgZG9uZSB1c2luZyBpdCAoYW5kIGFsbCB0aGUgam9pbnRzIGl0IGNyZWF0ZWQpLlxuICovXG5leHBvcnQgY2xhc3MgSW1wdWxzZUpvaW50U2V0IHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXcgfHwgbmV3IFJhd0ltcHVsc2VKb2ludFNldCgpO1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBDb2FyZW5hKCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1hcCB3aXRoIHRoZSBleGlzdGluZyBlbGVtZW50cywgaWYgYW55LlxuICAgICAgICBpZiAocmF3KSB7XG4gICAgICAgICAgICByYXcuZm9yRWFjaEpvaW50SGFuZGxlKChoYW5kbGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXQoaGFuZGxlLCBJbXB1bHNlSm9pbnQubmV3VHlwZWQocmF3LCBudWxsLCBoYW5kbGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGhlIFdBU00gbWVtb3J5IG9jY3VwaWVkIGJ5IHRoaXMgam9pbnQgc2V0LlxuICAgICAqL1xuICAgIGZyZWUoKSB7XG4gICAgICAgIGlmICghIXRoaXMucmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5mcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghIXRoaXMubWFwKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZmluYWxpemVEZXNlcmlhbGl6YXRpb24oYm9kaWVzKSB7XG4gICAgICAgIHRoaXMubWFwLmZvckVhY2goKGpvaW50KSA9PiBqb2ludC5maW5hbGl6ZURlc2VyaWFsaXphdGlvbihib2RpZXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBqb2ludCBhbmQgcmV0dXJuIGl0cyBpbnRlZ2VyIGhhbmRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBib2RpZXMgLSBUaGUgc2V0IG9mIHJpZ2lkLWJvZGllcyBjb250YWluaW5nIHRoZSBib2RpZXMgdGhlIGpvaW50IGlzIGF0dGFjaGVkIHRvLlxuICAgICAqIEBwYXJhbSBkZXNjIC0gVGhlIGpvaW50J3MgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gcGFyZW50MSAtIFRoZSBoYW5kbGUgb2YgdGhlIGZpcnN0IHJpZ2lkLWJvZHkgdGhpcyBqb2ludCBpcyBhdHRhY2hlZCB0by5cbiAgICAgKiBAcGFyYW0gcGFyZW50MiAtIFRoZSBoYW5kbGUgb2YgdGhlIHNlY29uZCByaWdpZC1ib2R5IHRoaXMgam9pbnQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICogQHBhcmFtIHdha2VVcCAtIFNob3VsZCB0aGUgYXR0YWNoZWQgcmlnaWQtYm9kaWVzIGJlIGF3YWtlbmVkP1xuICAgICAqL1xuICAgIGNyZWF0ZUpvaW50KGJvZGllcywgZGVzYywgcGFyZW50MSwgcGFyZW50Miwgd2FrZVVwKSB7XG4gICAgICAgIGNvbnN0IHJhd1BhcmFtcyA9IGRlc2MuaW50b1JhdygpO1xuICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLnJhdy5jcmVhdGVKb2ludChyYXdQYXJhbXMsIHBhcmVudDEsIHBhcmVudDIsIHdha2VVcCk7XG4gICAgICAgIHJhd1BhcmFtcy5mcmVlKCk7XG4gICAgICAgIGxldCBqb2ludCA9IEltcHVsc2VKb2ludC5uZXdUeXBlZCh0aGlzLnJhdywgYm9kaWVzLCBoYW5kbGUpO1xuICAgICAgICB0aGlzLm1hcC5zZXQoaGFuZGxlLCBqb2ludCk7XG4gICAgICAgIHJldHVybiBqb2ludDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgam9pbnQgZnJvbSB0aGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgaW50ZWdlciBoYW5kbGUgb2YgdGhlIGpvaW50LlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBJZiBgdHJ1ZWAsIHRoZSByaWdpZC1ib2RpZXMgYXR0YWNoZWQgYnkgdGhlIHJlbW92ZWQgam9pbnQgd2lsbCBiZSB3b2tlbi11cCBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIHJlbW92ZShoYW5kbGUsIHdha2VVcCkge1xuICAgICAgICB0aGlzLnJhdy5yZW1vdmUoaGFuZGxlLCB3YWtlVXApO1xuICAgICAgICB0aGlzLnVubWFwKGhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBnaXZlbiBjbG9zdXJlIHdpdGggdGhlIGludGVnZXIgaGFuZGxlIG9mIGVhY2ggaW1wdWxzZSBqb2ludCBhdHRhY2hlZCB0byB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZiAtIFRoZSBjbG9zdXJlIGNhbGxlZCB3aXRoIHRoZSBpbnRlZ2VyIGhhbmRsZSBvZiBlYWNoIGltcHVsc2Ugam9pbnQgYXR0YWNoZWQgdG8gdGhlIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgZm9yRWFjaEpvaW50SGFuZGxlQXR0YWNoZWRUb1JpZ2lkQm9keShoYW5kbGUsIGYpIHtcbiAgICAgICAgdGhpcy5yYXcuZm9yRWFjaEpvaW50QXR0YWNoZWRUb1JpZ2lkQm9keShoYW5kbGUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiwgZG8gbm90IGNhbGwgZGlyZWN0bHkuXG4gICAgICogQHBhcmFtIGhhbmRsZVxuICAgICAqL1xuICAgIHVubWFwKGhhbmRsZSkge1xuICAgICAgICB0aGlzLm1hcC5kZWxldGUoaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBqb2ludHMgb24gdGhpcyBzZXQuXG4gICAgICovXG4gICAgbGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAubGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhpcyBzZXQgY29udGFpbiBhIGpvaW50IHdpdGggdGhlIGdpdmVuIGhhbmRsZT9cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgam9pbnQgaGFuZGxlIHRvIGNoZWNrLlxuICAgICAqL1xuICAgIGNvbnRhaW5zKGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoaGFuZGxlKSAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBqb2ludCB3aXRoIHRoZSBnaXZlbiBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiBubyBqb2ludCB3aXRoIHRoZSBzcGVjaWZpZWQgaGFuZGxlIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgaW50ZWdlciBoYW5kbGUgb2YgdGhlIGpvaW50IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIGdldChoYW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChoYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBjbG9zdXJlIHRvIGVhY2ggam9pbnQgY29udGFpbmVkIGJ5IHRoaXMgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGYgLSBUaGUgY2xvc3VyZSB0byBhcHBseS5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgdGhpcy5tYXAuZm9yRWFjaChmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgam9pbnRzIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgam9pbnQgbGlzdC5cbiAgICAgKi9cbiAgICBnZXRBbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRBbGwoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbXB1bHNlX2pvaW50X3NldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/index.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _ccd_solver__WEBPACK_IMPORTED_MODULE_8__.CCDSolver),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _coefficient_combine_rule__WEBPACK_IMPORTED_MODULE_7__.CoefficientCombineRule),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.FixedMultibodyJoint),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _integration_parameters__WEBPACK_IMPORTED_MODULE_2__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _island_manager__WEBPACK_IMPORTED_MODULE_9__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointType),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__.MultibodyJointSet),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.PrismaticMultibodyJoint),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.RopeImpulseJoint),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.SpringImpulseJoint),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.UnitMultibodyJoint)\n/* harmony export */ });\n/* harmony import */ var _rigid_body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rigid_body */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/rigid_body.js\");\n/* harmony import */ var _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rigid_body_set */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js\");\n/* harmony import */ var _integration_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./integration_parameters */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js\");\n/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impulse_joint */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js\");\n/* harmony import */ var _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impulse_joint_set */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js\");\n/* harmony import */ var _multibody_joint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multibody_joint */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js\");\n/* harmony import */ var _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./multibody_joint_set */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js\");\n/* harmony import */ var _coefficient_combine_rule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coefficient_combine_rule */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js\");\n/* harmony import */ var _ccd_solver__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ccd_solver */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js\");\n/* harmony import */ var _island_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./island_manager */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/island_manager.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rigid_body__WEBPACK_IMPORTED_MODULE_0__, _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__, _integration_parameters__WEBPACK_IMPORTED_MODULE_2__, _impulse_joint__WEBPACK_IMPORTED_MODULE_3__, _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__, _multibody_joint__WEBPACK_IMPORTED_MODULE_5__, _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__, _ccd_solver__WEBPACK_IMPORTED_MODULE_8__, _island_manager__WEBPACK_IMPORTED_MODULE_9__]);\n([_rigid_body__WEBPACK_IMPORTED_MODULE_0__, _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__, _integration_parameters__WEBPACK_IMPORTED_MODULE_2__, _impulse_joint__WEBPACK_IMPORTED_MODULE_3__, _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__, _multibody_joint__WEBPACK_IMPORTED_MODULE_5__, _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__, _ccd_solver__WEBPACK_IMPORTED_MODULE_8__, _island_manager__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUNJO0FBQ1E7QUFDVDtBQUNJO0FBQ0Y7QUFDSTtBQUNLO0FBQ2Q7QUFDSTtBQUNqQyxpQyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxkeW5hbWljc1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vcmlnaWRfYm9keVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcmlnaWRfYm9keV9zZXRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ludGVncmF0aW9uX3BhcmFtZXRlcnNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ltcHVsc2Vfam9pbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ltcHVsc2Vfam9pbnRfc2V0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tdWx0aWJvZHlfam9pbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL211bHRpYm9keV9qb2ludF9zZXRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvZWZmaWNpZW50X2NvbWJpbmVfcnVsZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vY2NkX3NvbHZlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaXNsYW5kX21hbmFnZXJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js ***!
  \********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegrationParameters: () => (/* binding */ IntegrationParameters)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nclass IntegrationParameters {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawIntegrationParameters();\n    }\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt() {\n        return this.raw.dt;\n    }\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get contact_erp() {\n        return this.raw.contact_erp;\n    }\n    get lengthUnit() {\n        return this.raw.lengthUnit;\n    }\n    /**\n     * Normalized amount of penetration the engine won’t attempt to correct (default: `0.001m`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedAllowedLinearError() {\n        return this.raw.normalizedAllowedLinearError;\n    }\n    /**\n     * The maximal normalized distance separating two objects that will generate predictive contacts (default: `0.002`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedPredictionDistance() {\n        return this.raw.normalizedPredictionDistance;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.raw.numSolverIterations;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.raw.numAdditionalFrictionIterations;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.raw.numInternalPgsIterations;\n    }\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize() {\n        return this.raw.minIslandSize;\n    }\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps() {\n        return this.raw.maxCcdSubsteps;\n    }\n    set dt(value) {\n        this.raw.dt = value;\n    }\n    set contact_natural_frequency(value) {\n        this.raw.contact_natural_frequency = value;\n    }\n    set lengthUnit(value) {\n        this.raw.lengthUnit = value;\n    }\n    set normalizedAllowedLinearError(value) {\n        this.raw.normalizedAllowedLinearError = value;\n    }\n    set normalizedPredictionDistance(value) {\n        this.raw.normalizedPredictionDistance = value;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    set numSolverIterations(value) {\n        this.raw.numSolverIterations = value;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    set numAdditionalFrictionIterations(value) {\n        this.raw.numAdditionalFrictionIterations = value;\n    }\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    set numInternalPgsIterations(value) {\n        this.raw.numInternalPgsIterations = value;\n    }\n    set minIslandSize(value) {\n        this.raw.minIslandSize = value;\n    }\n    set maxCcdSubsteps(value) {\n        this.raw.maxCcdSubsteps = value;\n    }\n    switchToStandardPgsSolver() {\n        this.raw.switchToStandardPgsSolver();\n    }\n    switchToSmallStepsPgsSolver() {\n        this.raw.switchToSmallStepsPgsSolver();\n    }\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n}\n//# sourceMappingURL=integration_parameters.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL2ludGVncmF0aW9uX3BhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBa0Q7QUFDM0M7QUFDUDtBQUNBLDhCQUE4QiwwREFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRCIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxkeW5hbWljc1xcaW50ZWdyYXRpb25fcGFyYW1ldGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXdJbnRlZ3JhdGlvblBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vcmF3XCI7XG5leHBvcnQgY2xhc3MgSW50ZWdyYXRpb25QYXJhbWV0ZXJzIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXcgfHwgbmV3IFJhd0ludGVncmF0aW9uUGFyYW1ldGVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGcmVlIHRoZSBXQVNNIG1lbW9yeSB1c2VkIGJ5IHRoZXNlIGludGVncmF0aW9uIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKCEhdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LmZyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVzdGVwIGxlbmd0aCAoZGVmYXVsdDogYDEuMCAvIDYwLjBgKVxuICAgICAqL1xuICAgIGdldCBkdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3LmR0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgRXJyb3IgUmVkdWN0aW9uIFBhcmFtZXRlciBpbiBgWzAsIDFdYCBpcyB0aGUgcHJvcG9ydGlvbiBvZlxuICAgICAqIHRoZSBwb3NpdGlvbmFsIGVycm9yIHRvIGJlIGNvcnJlY3RlZCBhdCBlYWNoIHRpbWUgc3RlcCAoZGVmYXVsdDogYDAuMmApLlxuICAgICAqL1xuICAgIGdldCBjb250YWN0X2VycCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3LmNvbnRhY3RfZXJwO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoVW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3Lmxlbmd0aFVuaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZWQgYW1vdW50IG9mIHBlbmV0cmF0aW9uIHRoZSBlbmdpbmUgd29u4oCZdCBhdHRlbXB0IHRvIGNvcnJlY3QgKGRlZmF1bHQ6IGAwLjAwMW1gKS5cbiAgICAgKlxuICAgICAqIFRoaXMgdGhyZXNob2xkIGNvbnNpZGVyZWQgYnkgdGhlIHBoeXNpY3MgZW5naW5lIGlzIHRoaXMgdmFsdWUgbXVsdGlwbGllZCBieSB0aGUgYGxlbmd0aFVuaXRgLlxuICAgICAqL1xuICAgIGdldCBub3JtYWxpemVkQWxsb3dlZExpbmVhckVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcubm9ybWFsaXplZEFsbG93ZWRMaW5lYXJFcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltYWwgbm9ybWFsaXplZCBkaXN0YW5jZSBzZXBhcmF0aW5nIHR3byBvYmplY3RzIHRoYXQgd2lsbCBnZW5lcmF0ZSBwcmVkaWN0aXZlIGNvbnRhY3RzIChkZWZhdWx0OiBgMC4wMDJgKS5cbiAgICAgKlxuICAgICAqIFRoaXMgdGhyZXNob2xkIGNvbnNpZGVyZWQgYnkgdGhlIHBoeXNpY3MgZW5naW5lIGlzIHRoaXMgdmFsdWUgbXVsdGlwbGllZCBieSB0aGUgYGxlbmd0aFVuaXRgLlxuICAgICAqL1xuICAgIGdldCBub3JtYWxpemVkUHJlZGljdGlvbkRpc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcubm9ybWFsaXplZFByZWRpY3Rpb25EaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBzb2x2ZXIgaXRlcmF0aW9ucyBydW4gYnkgdGhlIGNvbnN0cmFpbnRzIHNvbHZlciBmb3IgY2FsY3VsYXRpbmcgZm9yY2VzIChkZWZhdWx0OiBgNGApLlxuICAgICAqL1xuICAgIGdldCBudW1Tb2x2ZXJJdGVyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcubnVtU29sdmVySXRlcmF0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGFkZGl0aW9uIGZyaWN0aW9uIHJlc29sdXRpb24gaXRlcmF0aW9uIHJ1biBkdXJpbmcgdGhlIGxhc3Qgc29sdmVyIHN1Yi1zdGVwIChkZWZhdWx0OiBgNGApLlxuICAgICAqL1xuICAgIGdldCBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcubnVtQWRkaXRpb25hbEZyaWN0aW9uSXRlcmF0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGludGVybmFsIFByb2plY3QgR2F1c3MgU2VpZGVsIChQR1MpIGl0ZXJhdGlvbnMgcnVuIGF0IGVhY2ggc29sdmVyIGl0ZXJhdGlvbiAoZGVmYXVsdDogYDFgKS5cbiAgICAgKi9cbiAgICBnZXQgbnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcubnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIG51bWJlciBvZiBkeW5hbWljIGJvZGllcyBpbiBlYWNoIGFjdGl2ZSBpc2xhbmQgKGRlZmF1bHQ6IGAxMjhgKS5cbiAgICAgKi9cbiAgICBnZXQgbWluSXNsYW5kU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3Lm1pbklzbGFuZFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIHN1YnN0ZXBzIHBlcmZvcm1lZCBieSB0aGUgIHNvbHZlciAoZGVmYXVsdDogYDFgKS5cbiAgICAgKi9cbiAgICBnZXQgbWF4Q2NkU3Vic3RlcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5tYXhDY2RTdWJzdGVwcztcbiAgICB9XG4gICAgc2V0IGR0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3LmR0ID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBjb250YWN0X25hdHVyYWxfZnJlcXVlbmN5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3LmNvbnRhY3RfbmF0dXJhbF9mcmVxdWVuY3kgPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGxlbmd0aFVuaXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXcubGVuZ3RoVW5pdCA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXQgbm9ybWFsaXplZEFsbG93ZWRMaW5lYXJFcnJvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnJhdy5ub3JtYWxpemVkQWxsb3dlZExpbmVhckVycm9yID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBub3JtYWxpemVkUHJlZGljdGlvbkRpc3RhbmNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3Lm5vcm1hbGl6ZWRQcmVkaWN0aW9uRGlzdGFuY2UgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHNvbHZlciBpdGVyYXRpb25zIHJ1biBieSB0aGUgY29uc3RyYWludHMgc29sdmVyIGZvciBjYWxjdWxhdGluZyBmb3JjZXMgKGRlZmF1bHQ6IGA0YCkuXG4gICAgICovXG4gICAgc2V0IG51bVNvbHZlckl0ZXJhdGlvbnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXcubnVtU29sdmVySXRlcmF0aW9ucyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgYWRkaXRpb24gZnJpY3Rpb24gcmVzb2x1dGlvbiBpdGVyYXRpb24gcnVuIGR1cmluZyB0aGUgbGFzdCBzb2x2ZXIgc3ViLXN0ZXAgKGRlZmF1bHQ6IGA0YCkuXG4gICAgICovXG4gICAgc2V0IG51bUFkZGl0aW9uYWxGcmljdGlvbkl0ZXJhdGlvbnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXcubnVtQWRkaXRpb25hbEZyaWN0aW9uSXRlcmF0aW9ucyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgaW50ZXJuYWwgUHJvamVjdCBHYXVzcyBTZWlkZWwgKFBHUykgaXRlcmF0aW9ucyBydW4gYXQgZWFjaCBzb2x2ZXIgaXRlcmF0aW9uIChkZWZhdWx0OiBgMWApLlxuICAgICAqL1xuICAgIHNldCBudW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yYXcubnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBtaW5Jc2xhbmRTaXplKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3Lm1pbklzbGFuZFNpemUgPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IG1heENjZFN1YnN0ZXBzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmF3Lm1heENjZFN1YnN0ZXBzID0gdmFsdWU7XG4gICAgfVxuICAgIHN3aXRjaFRvU3RhbmRhcmRQZ3NTb2x2ZXIoKSB7XG4gICAgICAgIHRoaXMucmF3LnN3aXRjaFRvU3RhbmRhcmRQZ3NTb2x2ZXIoKTtcbiAgICB9XG4gICAgc3dpdGNoVG9TbWFsbFN0ZXBzUGdzU29sdmVyKCkge1xuICAgICAgICB0aGlzLnJhdy5zd2l0Y2hUb1NtYWxsU3RlcHNQZ3NTb2x2ZXIoKTtcbiAgICB9XG4gICAgc3dpdGNoVG9TbWFsbFN0ZXBzUGdzU29sdmVyV2l0aG91dFdhcm1zdGFydCgpIHtcbiAgICAgICAgdGhpcy5yYXcuc3dpdGNoVG9TbWFsbFN0ZXBzUGdzU29sdmVyV2l0aG91dFdhcm1zdGFydCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVncmF0aW9uX3BhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/island_manager.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/island_manager.js ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IslandManager: () => (/* binding */ IslandManager)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nclass IslandManager {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawIslandManager();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBodyHandle(f) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n//# sourceMappingURL=island_manager.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL2lzbGFuZF9tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw4QkFBOEIsa0RBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGR5bmFtaWNzXFxpc2xhbmRfbWFuYWdlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXdJc2xhbmRNYW5hZ2VyIH0gZnJvbSBcIi4uL3Jhd1wiO1xuLyoqXG4gKiBUaGUgQ0NEIHNvbHZlciByZXNwb25zaWJsZSBmb3IgcmVzb2x2aW5nIENvbnRpbnVvdXMgQ29sbGlzaW9uIERldGVjdGlvbi5cbiAqXG4gKiBUbyBhdm9pZCBsZWFraW5nIFdBU00gcmVzb3VyY2VzLCB0aGlzIE1VU1QgYmUgZnJlZWQgbWFudWFsbHkgd2l0aCBgY2NkU29sdmVyLmZyZWUoKWBcbiAqIG9uY2UgeW91IGFyZSBkb25lIHVzaW5nIGl0LlxuICovXG5leHBvcnQgY2xhc3MgSXNsYW5kTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocmF3KSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3IHx8IG5ldyBSYXdJc2xhbmRNYW5hZ2VyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGhlIFdBU00gbWVtb3J5IG9jY3VwaWVkIGJ5IHRoaXMgbmFycm93LXBoYXNlLlxuICAgICAqL1xuICAgIGZyZWUoKSB7XG4gICAgICAgIGlmICghIXRoaXMucmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5mcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGNsb3N1cmUgdG8gdGhlIGhhbmRsZSBvZiBlYWNoIGFjdGl2ZSByaWdpZC1ib2RpZXMgY29udGFpbmVkIGJ5IHRoaXMgc2V0LlxuICAgICAqXG4gICAgICogQSByaWdpZC1ib2R5IGlzIGFjdGl2ZSBpZiBpdCBpcyBub3Qgc2xlZXBpbmcsIGkuZS4sIGlmIGl0IG1vdmVkIHJlY2VudGx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGYgLSBUaGUgY2xvc3VyZSB0byBhcHBseS5cbiAgICAgKi9cbiAgICBmb3JFYWNoQWN0aXZlUmlnaWRCb2R5SGFuZGxlKGYpIHtcbiAgICAgICAgdGhpcy5yYXcuZm9yRWFjaEFjdGl2ZVJpZ2lkQm9keUhhbmRsZShmKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc2xhbmRfbWFuYWdlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/island_manager.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedMultibodyJoint: () => (/* binding */ FixedMultibodyJoint),\n/* harmony export */   MultibodyJoint: () => (/* binding */ MultibodyJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* binding */ PrismaticMultibodyJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* binding */ RevoluteMultibodyJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* binding */ UnitMultibodyJoint)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nclass MultibodyJoint {\n    constructor(rawSet, handle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    //\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nclass UnitMultibodyJoint extends MultibodyJoint {\n}\nclass FixedMultibodyJoint extends MultibodyJoint {\n}\nclass PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis.LinX;\n    }\n}\nclass RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis.AngX;\n    }\n}\n//# sourceMappingURL=multibody_joint.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL211bHRpYm9keV9qb2ludC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDOUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0EsZUFBZSw4Q0FBWTtBQUMzQjtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsOENBQVk7QUFDM0I7QUFDQTtBQUNBLDJDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGR5bmFtaWNzXFxtdWx0aWJvZHlfam9pbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF3Sm9pbnRBeGlzLCBSYXdKb2ludFR5cGUsIH0gZnJvbSBcIi4uL3Jhd1wiO1xuZXhwb3J0IGNsYXNzIE11bHRpYm9keUpvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihyYXdTZXQsIGhhbmRsZSkge1xuICAgICAgICB0aGlzLnJhd1NldCA9IHJhd1NldDtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBoYW5kbGU7XG4gICAgfVxuICAgIHN0YXRpYyBuZXdUeXBlZChyYXdTZXQsIGhhbmRsZSkge1xuICAgICAgICBzd2l0Y2ggKHJhd1NldC5qb2ludFR5cGUoaGFuZGxlKSkge1xuICAgICAgICAgICAgY2FzZSBSYXdKb2ludFR5cGUuUmV2b2x1dGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXZvbHV0ZU11bHRpYm9keUpvaW50KHJhd1NldCwgaGFuZGxlKTtcbiAgICAgICAgICAgIGNhc2UgUmF3Sm9pbnRUeXBlLlByaXNtYXRpYzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByaXNtYXRpY011bHRpYm9keUpvaW50KHJhd1NldCwgaGFuZGxlKTtcbiAgICAgICAgICAgIGNhc2UgUmF3Sm9pbnRUeXBlLkZpeGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRml4ZWRNdWx0aWJvZHlKb2ludChyYXdTZXQsIGhhbmRsZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlib2R5Sm9pbnQocmF3U2V0LCBoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIGpvaW50IGlzIHN0aWxsIHZhbGlkIChpLmUuIHRoYXQgaXQgaGFzXG4gICAgICogbm90IGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBqb2ludCBzZXQgeWV0KS5cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQuY29udGFpbnModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvLyAvKipcbiAgICAvLyAgKiBUaGUgdW5pcXVlIGludGVnZXIgaWRlbnRpZmllciBvZiB0aGUgZmlyc3QgcmlnaWQtYm9keSB0aGlzIGpvaW50IGl0IGF0dGFjaGVkIHRvLlxuICAgIC8vICAqL1xuICAgIC8vIHB1YmxpYyBib2R5SGFuZGxlMSgpOiBSaWdpZEJvZHlIYW5kbGUge1xuICAgIC8vICAgICByZXR1cm4gdGhpcy5yYXdTZXQuam9pbnRCb2R5SGFuZGxlMSh0aGlzLmhhbmRsZSk7XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gLyoqXG4gICAgLy8gICogVGhlIHVuaXF1ZSBpbnRlZ2VyIGlkZW50aWZpZXIgb2YgdGhlIHNlY29uZCByaWdpZC1ib2R5IHRoaXMgam9pbnQgaXMgYXR0YWNoZWQgdG8uXG4gICAgLy8gICovXG4gICAgLy8gcHVibGljIGJvZHlIYW5kbGUyKCk6IFJpZ2lkQm9keUhhbmRsZSB7XG4gICAgLy8gICAgIHJldHVybiB0aGlzLnJhd1NldC5qb2ludEJvZHlIYW5kbGUyKHRoaXMuaGFuZGxlKTtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyAvKipcbiAgICAvLyAgKiBUaGUgdHlwZSBvZiB0aGlzIGpvaW50IGdpdmVuIGFzIGEgc3RyaW5nLlxuICAgIC8vICAqL1xuICAgIC8vIHB1YmxpYyB0eXBlKCk6IEpvaW50VHlwZSB7XG4gICAgLy8gICAgIHJldHVybiB0aGlzLnJhd1NldC5qb2ludFR5cGUodGhpcy5oYW5kbGUpO1xuICAgIC8vIH1cbiAgICAvL1xuICAgIC8vXG4gICAgLy9cbiAgICAvLyAvKipcbiAgICAvLyAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGlzIGpvaW50LlxuICAgIC8vICAqXG4gICAgLy8gICogVGhlIGZpcnN0IGFuY2hvciBnaXZlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50cyBhcHBsaWNhdGlvbiBwb2ludCBvbiB0aGVcbiAgICAvLyAgKiBsb2NhbCBmcmFtZSBvZiB0aGUgZmlyc3QgcmlnaWQtYm9keSBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAvLyAgKi9cbiAgICAvLyBwdWJsaWMgYW5jaG9yMSgpOiBWZWN0b3Ige1xuICAgIC8vICAgICByZXR1cm4gVmVjdG9yT3BzLmZyb21SYXcodGhpcy5yYXdTZXQuam9pbnRBbmNob3IxKHRoaXMuaGFuZGxlKSk7XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gLyoqXG4gICAgLy8gICogVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgYW5jaG9yIG9mIHRoaXMgam9pbnQuXG4gICAgLy8gICpcbiAgICAvLyAgKiBUaGUgc2Vjb25kIGFuY2hvciBnaXZlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50cyBhcHBsaWNhdGlvbiBwb2ludCBvbiB0aGVcbiAgICAvLyAgKiBsb2NhbCBmcmFtZSBvZiB0aGUgc2Vjb25kIHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgLy8gICovXG4gICAgLy8gcHVibGljIGFuY2hvcjIoKTogVmVjdG9yIHtcbiAgICAvLyAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3U2V0LmpvaW50QW5jaG9yMih0aGlzLmhhbmRsZSkpO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGV0aGVyIGNvbnRhY3RzIGFyZSBjb21wdXRlZCBiZXR3ZWVuIGNvbGxpZGVycyBhdHRhY2hlZFxuICAgICAqIHRvIHRoZSByaWdpZC1ib2RpZXMgbGlua2VkIGJ5IHRoaXMgam9pbnQuXG4gICAgICovXG4gICAgc2V0Q29udGFjdHNFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yYXdTZXQuam9pbnRTZXRDb250YWN0c0VuYWJsZWQodGhpcy5oYW5kbGUsIGVuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgY29udGFjdHMgYXJlIGVuYWJsZWQgYmV0d2VlbiBjb2xsaWRlcnMgYXR0YWNoZWRcbiAgICAgKiB0byB0aGUgcmlnaWQtYm9kaWVzIGxpbmtlZCBieSB0aGlzIGpvaW50LlxuICAgICAqL1xuICAgIGNvbnRhY3RzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LmpvaW50Q29udGFjdHNFbmFibGVkKHRoaXMuaGFuZGxlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVW5pdE11bHRpYm9keUpvaW50IGV4dGVuZHMgTXVsdGlib2R5Sm9pbnQge1xufVxuZXhwb3J0IGNsYXNzIEZpeGVkTXVsdGlib2R5Sm9pbnQgZXh0ZW5kcyBNdWx0aWJvZHlKb2ludCB7XG59XG5leHBvcnQgY2xhc3MgUHJpc21hdGljTXVsdGlib2R5Sm9pbnQgZXh0ZW5kcyBVbml0TXVsdGlib2R5Sm9pbnQge1xuICAgIHJhd0F4aXMoKSB7XG4gICAgICAgIHJldHVybiBSYXdKb2ludEF4aXMuTGluWDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmV2b2x1dGVNdWx0aWJvZHlKb2ludCBleHRlbmRzIFVuaXRNdWx0aWJvZHlKb2ludCB7XG4gICAgcmF3QXhpcygpIHtcbiAgICAgICAgcmV0dXJuIFJhd0pvaW50QXhpcy5BbmdYO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpYm9keV9qb2ludC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultibodyJointSet: () => (/* binding */ MultibodyJointSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _multibody_joint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multibody_joint */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nclass MultibodyJointSet {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawMultibodyJointSet();\n        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = _multibody_joint__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wake_up) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=multibody_joint_set.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL211bHRpYm9keV9qb2ludF9zZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE4QztBQUNUO0FBQ2U7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4QixzREFBb0I7QUFDbEQsdUJBQXVCLDZDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0REFBYztBQUNuRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGR5bmFtaWNzXFxtdWx0aWJvZHlfam9pbnRfc2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJhd011bHRpYm9keUpvaW50U2V0IH0gZnJvbSBcIi4uL3Jhd1wiO1xuaW1wb3J0IHsgQ29hcmVuYSB9IGZyb20gXCIuLi9jb2FyZW5hXCI7XG5pbXBvcnQgeyBNdWx0aWJvZHlKb2ludCwgfSBmcm9tIFwiLi9tdWx0aWJvZHlfam9pbnRcIjtcbi8qKlxuICogQSBzZXQgb2Ygam9pbnRzLlxuICpcbiAqIFRvIGF2b2lkIGxlYWtpbmcgV0FTTSByZXNvdXJjZXMsIHRoaXMgTVVTVCBiZSBmcmVlZCBtYW51YWxseSB3aXRoIGBqb2ludFNldC5mcmVlKClgXG4gKiBvbmNlIHlvdSBhcmUgZG9uZSB1c2luZyBpdCAoYW5kIGFsbCB0aGUgam9pbnRzIGl0IGNyZWF0ZWQpLlxuICovXG5leHBvcnQgY2xhc3MgTXVsdGlib2R5Sm9pbnRTZXQge1xuICAgIGNvbnN0cnVjdG9yKHJhdykge1xuICAgICAgICB0aGlzLnJhdyA9IHJhdyB8fCBuZXcgUmF3TXVsdGlib2R5Sm9pbnRTZXQoKTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgQ29hcmVuYSgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBtYXAgd2l0aCB0aGUgZXhpc3RpbmcgZWxlbWVudHMsIGlmIGFueS5cbiAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgcmF3LmZvckVhY2hKb2ludEhhbmRsZSgoaGFuZGxlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGhhbmRsZSwgTXVsdGlib2R5Sm9pbnQubmV3VHlwZWQodGhpcy5yYXcsIGhhbmRsZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgV0FTTSBtZW1vcnkgb2NjdXBpZWQgYnkgdGhpcyBqb2ludCBzZXQuXG4gICAgICovXG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKCEhdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LmZyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCEhdGhpcy5tYXApIHtcbiAgICAgICAgICAgIHRoaXMubWFwLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgam9pbnQgYW5kIHJldHVybiBpdHMgaW50ZWdlciBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzYyAtIFRoZSBqb2ludCdzIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHBhcmVudDEgLSBUaGUgaGFuZGxlIG9mIHRoZSBmaXJzdCByaWdpZC1ib2R5IHRoaXMgam9pbnQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICogQHBhcmFtIHBhcmVudDIgLSBUaGUgaGFuZGxlIG9mIHRoZSBzZWNvbmQgcmlnaWQtYm9keSB0aGlzIGpvaW50IGlzIGF0dGFjaGVkIHRvLlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBTaG91bGQgdGhlIGF0dGFjaGVkIHJpZ2lkLWJvZGllcyBiZSBhd2FrZW5lZD9cbiAgICAgKi9cbiAgICBjcmVhdGVKb2ludChkZXNjLCBwYXJlbnQxLCBwYXJlbnQyLCB3YWtlVXApIHtcbiAgICAgICAgY29uc3QgcmF3UGFyYW1zID0gZGVzYy5pbnRvUmF3KCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMucmF3LmNyZWF0ZUpvaW50KHJhd1BhcmFtcywgcGFyZW50MSwgcGFyZW50Miwgd2FrZVVwKTtcbiAgICAgICAgcmF3UGFyYW1zLmZyZWUoKTtcbiAgICAgICAgbGV0IGpvaW50ID0gTXVsdGlib2R5Sm9pbnQubmV3VHlwZWQodGhpcy5yYXcsIGhhbmRsZSk7XG4gICAgICAgIHRoaXMubWFwLnNldChoYW5kbGUsIGpvaW50KTtcbiAgICAgICAgcmV0dXJuIGpvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBqb2ludCBmcm9tIHRoaXMgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZSAtIFRoZSBpbnRlZ2VyIGhhbmRsZSBvZiB0aGUgam9pbnQuXG4gICAgICogQHBhcmFtIHdha2VfdXAgLSBJZiBgdHJ1ZWAsIHRoZSByaWdpZC1ib2RpZXMgYXR0YWNoZWQgYnkgdGhlIHJlbW92ZWQgam9pbnQgd2lsbCBiZSB3b2tlbi11cCBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIHJlbW92ZShoYW5kbGUsIHdha2VfdXApIHtcbiAgICAgICAgdGhpcy5yYXcucmVtb3ZlKGhhbmRsZSwgd2FrZV91cCk7XG4gICAgICAgIHRoaXMubWFwLmRlbGV0ZShoYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiwgZG8gbm90IGNhbGwgZGlyZWN0bHkuXG4gICAgICogQHBhcmFtIGhhbmRsZVxuICAgICAqL1xuICAgIHVubWFwKGhhbmRsZSkge1xuICAgICAgICB0aGlzLm1hcC5kZWxldGUoaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBqb2ludHMgb24gdGhpcyBzZXQuXG4gICAgICovXG4gICAgbGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAubGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhpcyBzZXQgY29udGFpbiBhIGpvaW50IHdpdGggdGhlIGdpdmVuIGhhbmRsZT9cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgam9pbnQgaGFuZGxlIHRvIGNoZWNrLlxuICAgICAqL1xuICAgIGNvbnRhaW5zKGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoaGFuZGxlKSAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBqb2ludCB3aXRoIHRoZSBnaXZlbiBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiBubyBqb2ludCB3aXRoIHRoZSBzcGVjaWZpZWQgaGFuZGxlIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgaW50ZWdlciBoYW5kbGUgb2YgdGhlIGpvaW50IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIGdldChoYW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChoYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBjbG9zdXJlIHRvIGVhY2ggam9pbnQgY29udGFpbmVkIGJ5IHRoaXMgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGYgLSBUaGUgY2xvc3VyZSB0byBhcHBseS5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgdGhpcy5tYXAuZm9yRWFjaChmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGdpdmVuIGNsb3N1cmUgd2l0aCB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBtdWx0aWJvZHkgam9pbnQgYXR0YWNoZWQgdG8gdGhpcyByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGYgLSBUaGUgY2xvc3VyZSBjYWxsZWQgd2l0aCB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBtdWx0aWJvZHkgam9pbnQgYXR0YWNoZWQgdG8gdGhlIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgZm9yRWFjaEpvaW50SGFuZGxlQXR0YWNoZWRUb1JpZ2lkQm9keShoYW5kbGUsIGYpIHtcbiAgICAgICAgdGhpcy5yYXcuZm9yRWFjaEpvaW50QXR0YWNoZWRUb1JpZ2lkQm9keShoYW5kbGUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBqb2ludHMgaW4gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBqb2ludCBsaXN0LlxuICAgICAqL1xuICAgIGdldEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldEFsbCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpYm9keV9qb2ludF9zZXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/rigid_body.js":
/*!********************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/rigid_body.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigidBody: () => (/* binding */ RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* binding */ RigidBodyDesc),\n/* harmony export */   RigidBodyType: () => (/* binding */ RigidBodyType)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nvar RigidBodyType;\n(function (RigidBodyType) {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Dynamic\"] = 0] = \"Dynamic\";\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Fixed\"] = 1] = \"Fixed\";\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicPositionBased\"] = 2] = \"KinematicPositionBased\";\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicVelocityBased\"] = 3] = \"KinematicVelocityBased\";\n})(RigidBodyType || (RigidBodyType = {}));\n/**\n * A rigid-body.\n */\nclass RigidBody {\n    constructor(rawSet, colliderSet, handle) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n    /** @internal */\n    finalizeDeserialization(colliderSet) {\n        this.colliderSet = colliderSet;\n    }\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockTranslations(locked, wakeUp) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockRotations(locked, wakeUp) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledTranslations(enableX, enableY, wakeUp) {\n        return this.rawSet.rbSetEnabledTranslations(this.handle, enableX, enableY, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(enableX, enableY, wakeUp) {\n        this.setEnabledTranslations(enableX, enableX, wakeUp);\n    }\n    // #endif\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    dominanceGroup() {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    setDominanceGroup(group) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n    additionalSolverIterations() {\n        return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    enableCcd(enabled) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n    /**\n     * Sets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    setSoftCcdPrediction(distance) {\n        this.rawSet.rbSetSoftCcdPrediction(this.handle, distance);\n    }\n    /**\n     * Gets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    softCcdPrediction() {\n        return this.rawSet.rbSoftCcdPrediction(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        let res = this.rawSet.rbRotation(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(res);\n    }\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextTranslation() {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextRotation() {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(res);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    setTranslation(tra, wakeUp) {\n        // #if DIM2\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, wakeUp);\n        // #endif\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setLinvel(vel, wakeUp) {\n        let rawVel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    gravityScale() {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setGravityScale(factor, wakeUp) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    setRotation(angle, wakeUp) {\n        this.rawSet.rbSetRotation(this.handle, angle, wakeUp);\n    }\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setAngvel(vel, wakeUp) {\n        this.rawSet.rbSetAngvel(this.handle, vel, wakeUp);\n    }\n    // #endif\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    setNextKinematicTranslation(t) {\n        // #if DIM2\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y);\n        // #endif\n    }\n    // #if DIM2\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param angle - The kinematic rotation angle, in radians.\n     */\n    setNextKinematicRotation(angle) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, angle);\n    }\n    // #endif\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    linvel() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n    // #if DIM2\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    angvel() {\n        return this.rawSet.rbAngvel(this.handle);\n    }\n    // #endif\n    /**\n     * The mass of this rigid-body.\n     */\n    mass() {\n        return this.rawSet.rbMass(this.handle);\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    effectiveInvMass() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    invMass() {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    localCom() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    worldCom() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n    // #if DIM2\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    invPrincipalInertiaSqrt() {\n        return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    principalInertia() {\n        return this.rawSet.rbPrincipalInertia(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    effectiveWorldInvInertiaSqrt() {\n        return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    effectiveAngularInertia() {\n        return this.rawSet.rbEffectiveAngularInertia(this.handle);\n    }\n    // #endif\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    isCcdEnabled() {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    numColliders() {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    collider(i) {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    setEnabled(enabled) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this rigid-body enabled?\n     */\n    isEnabled() {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    bodyType() {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    setBodyType(type, wakeUp) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     */\n    isSleeping() {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    isMoving() {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n    /**\n     * Is this rigid-body static?\n     */\n    isFixed() {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n    /**\n     * Is this rigid-body kinematic?\n     */\n    isKinematic() {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n    /**\n     * Is this rigid-body dynamic?\n     */\n    isDynamic() {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    linearDamping() {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    angularDamping() {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setLinearDamping(factor) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);\n    }\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isn’t desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders’ contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMass(mass, wakeUp) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders’ contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, wakeUp) {\n        let rawCom = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(centerOfMass);\n        this.rawSet.rbSetAdditionalMassProperties(this.handle, mass, rawCom, principalAngularInertia, wakeUp);\n        rawCom.free();\n    }\n    // #endif\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setAngularDamping(factor) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetForces(wakeUp) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetTorques(wakeUp) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForce(force, wakeUp) {\n        const rawForce = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulse(impulse, wakeUp) {\n        const rawImpulse = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n    // #if DIM2\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addTorque(torque, wakeUp) {\n        this.rawSet.rbAddTorque(this.handle, torque, wakeUp);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyTorqueImpulse(torqueImpulse, wakeUp) {\n        this.rawSet.rbApplyTorqueImpulse(this.handle, torqueImpulse, wakeUp);\n    }\n    // #endif\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForceAtPoint(force, point, wakeUp) {\n        const rawForce = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(force);\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulseAtPoint(impulse, point, wakeUp) {\n        const rawImpulse = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(impulse);\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n        rawImpulse.free();\n        rawPoint.free();\n    }\n    /**\n     * Retrieves the constant force(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    userForce() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbUserForce(this.handle));\n    }\n    // #if DIM2\n    /**\n     * Retrieves the constant torque(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    userTorque() {\n        return this.rawSet.rbUserTorque(this.handle);\n    }\n}\nclass RigidBodyDesc {\n    constructor(status) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n        this.rotation = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM2\n        this.angvel = 0.0;\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.softCcdPrediction = 0.0;\n        this.dominanceGroup = 0;\n        this.additionalSolverIterations = 0;\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    static dynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    static kinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    static kinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    static fixed() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    static newDynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    static newKinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    static newKinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    static newStatic() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    setDominanceGroup(group) {\n        this.dominanceGroup = group;\n        return this;\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.additionalSolverIterations = iters;\n        return this;\n    }\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled − If set to `false` the rigid-body will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     */\n    setTranslation(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    setRotation(rot) {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    setGravityScale(scale) {\n        this.gravityScale = scale;\n        return this;\n    }\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     */\n    setAdditionalMass(mass) {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     */\n    setLinvel(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n        this.linvel = { x: x, y: y };\n        return this;\n    }\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    setAngvel(vel) {\n        this.angvel = vel;\n        return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     * @param centerOfMass − The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia − The initial principal angular inertia of the rigid-body to create.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia) {\n        this.mass = mass;\n        _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        this.massOnly = false;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     */\n    enabledTranslations(translationsEnabledX, translationsEnabledY) {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(translationsEnabledX, translationsEnabledY) {\n        return this.enabledTranslations(translationsEnabledX, translationsEnabledY);\n    }\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockTranslations() {\n        return this.restrictTranslations(false, false);\n    }\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockRotations() {\n        this.rotationsEnabled = false;\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    setLinearDamping(damping) {\n        this.linearDamping = damping;\n        return this;\n    }\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    setAngularDamping(damping) {\n        this.angularDamping = damping;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    setCanSleep(can) {\n        this.canSleep = can;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping) {\n        this.sleeping = sleeping;\n        return this;\n    }\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    setCcdEnabled(enabled) {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the maximum prediction distance Soft Continuous Collision-Detection.\n     *\n     * When set to 0, soft-CCD is disabled. Soft-CCD helps prevent tunneling especially of\n     * slow-but-thin to moderately fast objects. The soft CCD prediction distance indicates how\n     * far in the object’s path the CCD algorithm is allowed to inspect. Large values can impact\n     * performance badly by increasing the work needed from the broad-phase.\n     *\n     * It is a generally cheaper variant of regular CCD (that can be enabled with\n     * `RigidBodyDesc::setCcdEnabled` since it relies on predictive constraints instead of\n     * shape-cast and substeps.\n     */\n    setSoftCcdPrediction(distance) {\n        this.softCcdPrediction = distance;\n        return this;\n    }\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    setUserData(data) {\n        this.userData = data;\n        return this;\n    }\n}\n//# sourceMappingURL=rigid_body.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL3JpZ2lkX2JvZHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNENBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUFTO0FBQ2xDLHlCQUF5Qiw0Q0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNENBQVM7QUFDcEMseUJBQXlCLDRDQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0Q0FBUztBQUNwQyx3QkFBd0IsOENBQVc7QUFDbkM7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0I7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGR5bmFtaWNzXFxyaWdpZF9ib2R5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJvdGF0aW9uT3BzLCBWZWN0b3JPcHMgfSBmcm9tIFwiLi4vbWF0aFwiO1xuLyoqXG4gKiBUaGUgc2ltdWxhdGlvbiBzdGF0dXMgb2YgYSByaWdpZC1ib2R5LlxuICovXG4vLyBUT0RPOiByZW5hbWUgdGhpcyB0byBSaWdpZEJvZHlUeXBlXG5leHBvcnQgdmFyIFJpZ2lkQm9keVR5cGU7XG4oZnVuY3Rpb24gKFJpZ2lkQm9keVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIGBSaWdpZEJvZHlUeXBlOjpEeW5hbWljYCBib2R5IGNhbiBiZSBhZmZlY3RlZCBieSBhbGwgZXh0ZXJuYWwgZm9yY2VzLlxuICAgICAqL1xuICAgIFJpZ2lkQm9keVR5cGVbUmlnaWRCb2R5VHlwZVtcIkR5bmFtaWNcIl0gPSAwXSA9IFwiRHluYW1pY1wiO1xuICAgIC8qKlxuICAgICAqIEEgYFJpZ2lkQm9keVR5cGU6OkZpeGVkYCBib2R5IGNhbm5vdCBiZSBhZmZlY3RlZCBieSBleHRlcm5hbCBmb3JjZXMuXG4gICAgICovXG4gICAgUmlnaWRCb2R5VHlwZVtSaWdpZEJvZHlUeXBlW1wiRml4ZWRcIl0gPSAxXSA9IFwiRml4ZWRcIjtcbiAgICAvKipcbiAgICAgKiBBIGBSaWdpZEJvZHlUeXBlOjpLaW5lbWF0aWNQb3NpdGlvbkJhc2VkYCBib2R5IGNhbm5vdCBiZSBhZmZlY3RlZCBieSBhbnkgZXh0ZXJuYWwgZm9yY2VzIGJ1dCBjYW4gYmUgY29udHJvbGxlZFxuICAgICAqIGJ5IHRoZSB1c2VyIGF0IHRoZSBwb3NpdGlvbiBsZXZlbCB3aGlsZSBrZWVwaW5nIHJlYWxpc3RpYyBvbmUtd2F5IGludGVyYWN0aW9uIHdpdGggZHluYW1pYyBib2RpZXMuXG4gICAgICpcbiAgICAgKiBPbmUtd2F5IGludGVyYWN0aW9uIG1lYW5zIHRoYXQgYSBraW5lbWF0aWMgYm9keSBjYW4gcHVzaCBhIGR5bmFtaWMgYm9keSwgYnV0IGEga2luZW1hdGljIGJvZHlcbiAgICAgKiBjYW5ub3QgYmUgcHVzaGVkIGJ5IGFueXRoaW5nLiBJbiBvdGhlciB3b3JkcywgdGhlIHRyYWplY3Rvcnkgb2YgYSBraW5lbWF0aWMgYm9keSBjYW4gb25seSBiZVxuICAgICAqIG1vZGlmaWVkIGJ5IHRoZSB1c2VyIGFuZCBpcyBpbmRlcGVuZGVudCBmcm9tIGFueSBjb250YWN0IG9yIGpvaW50IGl0IGlzIGludm9sdmVkIGluLlxuICAgICAqL1xuICAgIFJpZ2lkQm9keVR5cGVbUmlnaWRCb2R5VHlwZVtcIktpbmVtYXRpY1Bvc2l0aW9uQmFzZWRcIl0gPSAyXSA9IFwiS2luZW1hdGljUG9zaXRpb25CYXNlZFwiO1xuICAgIC8qKlxuICAgICAqIEEgYFJpZ2lkQm9keVR5cGU6OktpbmVtYXRpY1ZlbG9jaXR5QmFzZWRgIGJvZHkgY2Fubm90IGJlIGFmZmVjdGVkIGJ5IGFueSBleHRlcm5hbCBmb3JjZXMgYnV0IGNhbiBiZSBjb250cm9sbGVkXG4gICAgICogYnkgdGhlIHVzZXIgYXQgdGhlIHZlbG9jaXR5IGxldmVsIHdoaWxlIGtlZXBpbmcgcmVhbGlzdGljIG9uZS13YXkgaW50ZXJhY3Rpb24gd2l0aCBkeW5hbWljIGJvZGllcy5cbiAgICAgKlxuICAgICAqIE9uZS13YXkgaW50ZXJhY3Rpb24gbWVhbnMgdGhhdCBhIGtpbmVtYXRpYyBib2R5IGNhbiBwdXNoIGEgZHluYW1pYyBib2R5LCBidXQgYSBraW5lbWF0aWMgYm9keVxuICAgICAqIGNhbm5vdCBiZSBwdXNoZWQgYnkgYW55dGhpbmcuIEluIG90aGVyIHdvcmRzLCB0aGUgdHJhamVjdG9yeSBvZiBhIGtpbmVtYXRpYyBib2R5IGNhbiBvbmx5IGJlXG4gICAgICogbW9kaWZpZWQgYnkgdGhlIHVzZXIgYW5kIGlzIGluZGVwZW5kZW50IGZyb20gYW55IGNvbnRhY3Qgb3Igam9pbnQgaXQgaXMgaW52b2x2ZWQgaW4uXG4gICAgICovXG4gICAgUmlnaWRCb2R5VHlwZVtSaWdpZEJvZHlUeXBlW1wiS2luZW1hdGljVmVsb2NpdHlCYXNlZFwiXSA9IDNdID0gXCJLaW5lbWF0aWNWZWxvY2l0eUJhc2VkXCI7XG59KShSaWdpZEJvZHlUeXBlIHx8IChSaWdpZEJvZHlUeXBlID0ge30pKTtcbi8qKlxuICogQSByaWdpZC1ib2R5LlxuICovXG5leHBvcnQgY2xhc3MgUmlnaWRCb2R5IHtcbiAgICBjb25zdHJ1Y3RvcihyYXdTZXQsIGNvbGxpZGVyU2V0LCBoYW5kbGUpIHtcbiAgICAgICAgdGhpcy5yYXdTZXQgPSByYXdTZXQ7XG4gICAgICAgIHRoaXMuY29sbGlkZXJTZXQgPSBjb2xsaWRlclNldDtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSBoYW5kbGU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmaW5hbGl6ZURlc2VyaWFsaXphdGlvbihjb2xsaWRlclNldCkge1xuICAgICAgICB0aGlzLmNvbGxpZGVyU2V0ID0gY29sbGlkZXJTZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIHJpZ2lkLWJvZHkgaXMgc3RpbGwgdmFsaWQgKGkuZS4gdGhhdCBpdCBoYXNcbiAgICAgKiBub3QgYmVlbiBkZWxldGVkIGZyb20gdGhlIHJpZ2lkLWJvZHkgc2V0IHlldC5cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQuY29udGFpbnModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2NrcyBvciB1bmxvY2tzIHRoZSBhYmlsaXR5IG9mIHRoaXMgcmlnaWQtYm9keSB0byB0cmFuc2xhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9ja2VkIC0gSWYgYHRydWVgLCB0aGlzIHJpZ2lkLWJvZHkgd2lsbCBubyBsb25nZXIgdHJhbnNsYXRlIGR1ZSB0byBmb3JjZXMgYW5kIGltcHVsc2VzLlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBJZiBgdHJ1ZWAsIHRoaXMgcmlnaWQtYm9keSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXdha2VuIGlmIGl0IGlzIGN1cnJlbnRseSBhc2xlZXAuXG4gICAgICovXG4gICAgbG9ja1RyYW5zbGF0aW9ucyhsb2NrZWQsIHdha2VVcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJMb2NrVHJhbnNsYXRpb25zKHRoaXMuaGFuZGxlLCBsb2NrZWQsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvY2tzIG9yIHVubG9ja3MgdGhlIGFiaWxpdHkgb2YgdGhpcyByaWdpZC1ib2R5IHRvIHJvdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NrZWQgLSBJZiBgdHJ1ZWAsIHRoaXMgcmlnaWQtYm9keSB3aWxsIG5vIGxvbmdlciByb3RhdGUgZHVlIHRvIHRvcnF1ZXMgYW5kIGltcHVsc2VzLlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBJZiBgdHJ1ZWAsIHRoaXMgcmlnaWQtYm9keSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXdha2VuIGlmIGl0IGlzIGN1cnJlbnRseSBhc2xlZXAuXG4gICAgICovXG4gICAgbG9ja1JvdGF0aW9ucyhsb2NrZWQsIHdha2VVcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJMb2NrUm90YXRpb25zKHRoaXMuaGFuZGxlLCBsb2NrZWQsIHdha2VVcCk7XG4gICAgfVxuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogTG9ja3Mgb3IgdW5sb2NrcyB0aGUgYWJpbGl0eSBvZiB0aGlzIHJpZ2lkLWJvZHkgdG8gdHJhbnNsYXRpb24gYWxvbmcgaW5kaXZpZHVhbCBjb29yZGluYXRlIGF4ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5hYmxlWCAtIElmIGBmYWxzZWAsIHRoaXMgcmlnaWQtYm9keSB3aWxsIG5vIGxvbmdlciByb3RhdGUgZHVlIHRvIHRvcnF1ZXMgYW5kIGltcHVsc2VzLCBhbG9uZyB0aGUgWCBjb29yZGluYXRlIGF4aXMuXG4gICAgICogQHBhcmFtIGVuYWJsZVkgLSBJZiBgZmFsc2VgLCB0aGlzIHJpZ2lkLWJvZHkgd2lsbCBubyBsb25nZXIgcm90YXRlIGR1ZSB0byB0b3JxdWVzIGFuZCBpbXB1bHNlcywgYWxvbmcgdGhlIFkgY29vcmRpbmF0ZSBheGlzLlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBJZiBgdHJ1ZWAsIHRoaXMgcmlnaWQtYm9keSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXdha2VuIGlmIGl0IGlzIGN1cnJlbnRseSBhc2xlZXAuXG4gICAgICovXG4gICAgc2V0RW5hYmxlZFRyYW5zbGF0aW9ucyhlbmFibGVYLCBlbmFibGVZLCB3YWtlVXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LnJiU2V0RW5hYmxlZFRyYW5zbGF0aW9ucyh0aGlzLmhhbmRsZSwgZW5hYmxlWCwgZW5hYmxlWSwgd2FrZVVwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ja3Mgb3IgdW5sb2NrcyB0aGUgYWJpbGl0eSBvZiB0aGlzIHJpZ2lkLWJvZHkgdG8gdHJhbnNsYXRpb24gYWxvbmcgaW5kaXZpZHVhbCBjb29yZGluYXRlIGF4ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5hYmxlWCAtIElmIGBmYWxzZWAsIHRoaXMgcmlnaWQtYm9keSB3aWxsIG5vIGxvbmdlciByb3RhdGUgZHVlIHRvIHRvcnF1ZXMgYW5kIGltcHVsc2VzLCBhbG9uZyB0aGUgWCBjb29yZGluYXRlIGF4aXMuXG4gICAgICogQHBhcmFtIGVuYWJsZVkgLSBJZiBgZmFsc2VgLCB0aGlzIHJpZ2lkLWJvZHkgd2lsbCBubyBsb25nZXIgcm90YXRlIGR1ZSB0byB0b3JxdWVzIGFuZCBpbXB1bHNlcywgYWxvbmcgdGhlIFkgY29vcmRpbmF0ZSBheGlzLlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBJZiBgdHJ1ZWAsIHRoaXMgcmlnaWQtYm9keSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXdha2VuIGlmIGl0IGlzIGN1cnJlbnRseSBhc2xlZXAuXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGB0aGlzLnNldEVuYWJsZWRUcmFuc2xhdGlvbnNgIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGluc3RlYWQuXG4gICAgICovXG4gICAgcmVzdHJpY3RUcmFuc2xhdGlvbnMoZW5hYmxlWCwgZW5hYmxlWSwgd2FrZVVwKSB7XG4gICAgICAgIHRoaXMuc2V0RW5hYmxlZFRyYW5zbGF0aW9ucyhlbmFibGVYLCBlbmFibGVYLCB3YWtlVXApO1xuICAgIH1cbiAgICAvLyAjZW5kaWZcbiAgICAvKipcbiAgICAgKiBUaGUgZG9taW5hbmNlIGdyb3VwLCBpbiBbLTEyNywgKzEyN10gdGhpcyByaWdpZC1ib2R5IGlzIHBhcnQgb2YuXG4gICAgICovXG4gICAgZG9taW5hbmNlR3JvdXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5yYkRvbWluYW5jZUdyb3VwKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZG9taW5hbmNlIGdyb3VwIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncm91cCAtIFRoZSBkb21pbmFuY2UgZ3JvdXAgb2YgdGhpcyByaWdpZC1ib2R5LiBNdXN0IGJlIGEgc2lnbmVkIGludGVnZXIgaW4gdGhlIHJhbmdlIFstMTI3LCArMTI3XS5cbiAgICAgKi9cbiAgICBzZXREb21pbmFuY2VHcm91cChncm91cCkge1xuICAgICAgICB0aGlzLnJhd1NldC5yYlNldERvbWluYW5jZUdyb3VwKHRoaXMuaGFuZGxlLCBncm91cCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgYWRkaXRpb25hbCBzb2x2ZXIgaXRlcmF0aW9ucyB0aGF0IHdpbGwgYmUgcnVuIGZvciB0aGlzXG4gICAgICogcmlnaWQtYm9keSBhbmQgZXZlcnl0aGluZyB0aGF0IGludGVyYWN0cyB3aXRoIGl0IGRpcmVjdGx5IG9yIGluZGlyZWN0bHlcbiAgICAgKiB0aHJvdWdoIGNvbnRhY3RzIG9yIGpvaW50cy5cbiAgICAgKi9cbiAgICBhZGRpdGlvbmFsU29sdmVySXRlcmF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LnJiQWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgYWRkaXRpb25hbCBzb2x2ZXIgaXRlcmF0aW9ucyB0aGF0IHdpbGwgYmUgcnVuIGZvciB0aGlzXG4gICAgICogcmlnaWQtYm9keSBhbmQgZXZlcnl0aGluZyB0aGF0IGludGVyYWN0cyB3aXRoIGl0IGRpcmVjdGx5IG9yIGluZGlyZWN0bHlcbiAgICAgKiB0aHJvdWdoIGNvbnRhY3RzIG9yIGpvaW50cy5cbiAgICAgKlxuICAgICAqIENvbXBhcmVkIHRvIGluY3JlYXNpbmcgdGhlIGdsb2JhbCBgV29ybGQubnVtU29sdmVySXRlcmF0aW9uYCwgc2V0dGluZyB0aGlzXG4gICAgICogdmFsdWUgbGV0cyB5b3UgaW5jcmVhc2UgYWNjdXJhY3kgb24gb25seSBhIHN1YnNldCBvZiB0aGUgc2NlbmUsIHJlc3VsdGluZyBpbiByZWR1Y2VkXG4gICAgICogcGVyZm9ybWFuY2UgbG9zcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVycyAtIFRoZSBuZXcgbnVtYmVyIG9mIGFkZGl0aW9uYWwgc29sdmVyIGl0ZXJhdGlvbnMgKGRlZmF1bHQ6IDApLlxuICAgICAqL1xuICAgIHNldEFkZGl0aW9uYWxTb2x2ZXJJdGVyYXRpb25zKGl0ZXJzKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiU2V0QWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnModGhpcy5oYW5kbGUsIGl0ZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgQ0NEIChDb250aW51b3VzIENvbGxpc2lvbiBEZXRlY3Rpb24pIGZvciB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5hYmxlZCAtIElmIGB0cnVlYCwgQ0NEIHdpbGwgYmUgZW5hYmxlZCBmb3IgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqL1xuICAgIGVuYWJsZUNjZChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiRW5hYmxlQ2NkKHRoaXMuaGFuZGxlLCBlbmFibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc29mdC1DQ0QgcHJlZGljdGlvbiBkaXN0YW5jZSBmb3IgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIGBSaWdpZEJvZHlEZXNjLnNldFNvZnRDY2RQcmVkaWN0aW9uYCBmb3JcbiAgICAgKiBhZGRpdGlvbmFsIGRldGFpbHMuXG4gICAgICovXG4gICAgc2V0U29mdENjZFByZWRpY3Rpb24oZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5yYXdTZXQucmJTZXRTb2Z0Q2NkUHJlZGljdGlvbih0aGlzLmhhbmRsZSwgZGlzdGFuY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzb2Z0LUNDRCBwcmVkaWN0aW9uIGRpc3RhbmNlIGZvciB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIGRvY3VtZW50YXRpb24gb2YgYFJpZ2lkQm9keURlc2Muc2V0U29mdENjZFByZWRpY3Rpb25gIGZvclxuICAgICAqIGFkZGl0aW9uYWwgZGV0YWlscy5cbiAgICAgKi9cbiAgICBzb2Z0Q2NkUHJlZGljdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LnJiU29mdENjZFByZWRpY3Rpb24odGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQtc3BhY2UgdHJhbnNsYXRpb24gb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqL1xuICAgIHRyYW5zbGF0aW9uKCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5yYXdTZXQucmJUcmFuc2xhdGlvbih0aGlzLmhhbmRsZSk7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyhyZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQtc3BhY2Ugb3JpZW50YXRpb24gb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqL1xuICAgIHJvdGF0aW9uKCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5yYXdTZXQucmJSb3RhdGlvbih0aGlzLmhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSb3RhdGlvbk9wcy5mcm9tUmF3KHJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZC1zcGFjZSBuZXh0IHRyYW5zbGF0aW9uIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgcmlnaWQtYm9keSBpcyBraW5lbWF0aWMgdGhpcyB2YWx1ZSBpcyBzZXQgYnkgdGhlIGBzZXROZXh0S2luZW1hdGljVHJhbnNsYXRpb25gXG4gICAgICogbWV0aG9kIGFuZCBpcyB1c2VkIGZvciBlc3RpbWF0aW5nIHRoZSBraW5lbWF0aWMgYm9keSB2ZWxvY2l0eSBhdCB0aGUgbmV4dCB0aW1lc3RlcC5cbiAgICAgKiBGb3Igbm9uLWtpbmVtYXRpYyBib2RpZXMsIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIG5leHRUcmFuc2xhdGlvbigpIHtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMucmF3U2V0LnJiTmV4dFRyYW5zbGF0aW9uKHRoaXMuaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHJlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZC1zcGFjZSBuZXh0IG9yaWVudGF0aW9uIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgcmlnaWQtYm9keSBpcyBraW5lbWF0aWMgdGhpcyB2YWx1ZSBpcyBzZXQgYnkgdGhlIGBzZXROZXh0S2luZW1hdGljUm90YXRpb25gXG4gICAgICogbWV0aG9kIGFuZCBpcyB1c2VkIGZvciBlc3RpbWF0aW5nIHRoZSBraW5lbWF0aWMgYm9keSB2ZWxvY2l0eSBhdCB0aGUgbmV4dCB0aW1lc3RlcC5cbiAgICAgKiBGb3Igbm9uLWtpbmVtYXRpYyBib2RpZXMsIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIG5leHRSb3RhdGlvbigpIHtcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMucmF3U2V0LnJiTmV4dFJvdGF0aW9uKHRoaXMuaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIFJvdGF0aW9uT3BzLmZyb21SYXcocmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHJhbnNsYXRpb24gb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYSAtIFRoZSB3b3JsZC1zcGFjZSBwb3NpdGlvbiBvZiB0aGUgcmlnaWQtYm9keS5cbiAgICAgKiBAcGFyYW0gd2FrZVVwIC0gRm9yY2VzIHRoZSByaWdpZC1ib2R5IHRvIHdha2UtdXAgc28gaXQgaXMgcHJvcGVybHkgYWZmZWN0ZWQgYnkgZm9yY2VzIGlmIGl0XG4gICAgICogICAgICAgICAgICAgICAgIHdhc24ndCBtb3ZpbmcgYmVmb3JlIG1vZGlmeWluZyBpdHMgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2V0VHJhbnNsYXRpb24odHJhLCB3YWtlVXApIHtcbiAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgdGhpcy5yYXdTZXQucmJTZXRUcmFuc2xhdGlvbih0aGlzLmhhbmRsZSwgdHJhLngsIHRyYS55LCB3YWtlVXApO1xuICAgICAgICAvLyAjZW5kaWZcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2ZWwgLSBUaGUgbGluZWFyIHZlbG9jaXR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0gd2FrZVVwIC0gRm9yY2VzIHRoZSByaWdpZC1ib2R5IHRvIHdha2UtdXAgaWYgaXQgd2FzIGFzbGVlcC5cbiAgICAgKi9cbiAgICBzZXRMaW52ZWwodmVsLCB3YWtlVXApIHtcbiAgICAgICAgbGV0IHJhd1ZlbCA9IFZlY3Rvck9wcy5pbnRvUmF3KHZlbCk7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiU2V0TGludmVsKHRoaXMuaGFuZGxlLCByYXdWZWwsIHdha2VVcCk7XG4gICAgICAgIHJhd1ZlbC5mcmVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBzY2FsZSBmYWN0b3IgYXBwbGllZCB0byB0aGUgZ3Jhdml0eSBhZmZlY3RpbmdcbiAgICAgKiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgZ3Jhdml0eVNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJHcmF2aXR5U2NhbGUodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzY2FsZSBmYWN0b3IgYXBwbGllZCB0byB0aGUgZ3Jhdml0eSBhZmZlY3RpbmdcbiAgICAgKiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmFjdG9yIC0gVGhlIHNjYWxlIGZhY3RvciB0byBzZXQuIEEgdmFsdWUgb2YgMC4wIG1lYW5zXG4gICAgICogICB0aGF0IHRoaXMgcmlnaWQtYm9keSB3aWxsIG9uIGxvbmdlciBiZSBhZmZlY3RlZCBieSBncmF2aXR5LlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBGb3JjZXMgdGhlIHJpZ2lkLWJvZHkgdG8gd2FrZS11cCBpZiBpdCB3YXMgYXNsZWVwLlxuICAgICAqL1xuICAgIHNldEdyYXZpdHlTY2FsZShmYWN0b3IsIHdha2VVcCkge1xuICAgICAgICB0aGlzLnJhd1NldC5yYlNldEdyYXZpdHlTY2FsZSh0aGlzLmhhbmRsZSwgZmFjdG9yLCB3YWtlVXApO1xuICAgIH1cbiAgICAvLyAjaWYgRElNMlxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJvdGF0aW9uIGFuZ2xlIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbmdsZSAtIFRoZSByb3RhdGlvbiBhbmdsZSwgaW4gcmFkaWFucy5cbiAgICAgKiBAcGFyYW0gd2FrZVVwIC0gRm9yY2VzIHRoZSByaWdpZC1ib2R5IHRvIHdha2UtdXAgc28gaXQgaXMgcHJvcGVybHkgYWZmZWN0ZWQgYnkgZm9yY2VzIGlmIGl0XG4gICAgICogd2Fzbid0IG1vdmluZyBiZWZvcmUgbW9kaWZ5aW5nIGl0cyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBzZXRSb3RhdGlvbihhbmdsZSwgd2FrZVVwKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiU2V0Um90YXRpb24odGhpcy5oYW5kbGUsIGFuZ2xlLCB3YWtlVXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhbmd1bGFyIHZlbG9jaXR5IGZvIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2ZWwgLSBUaGUgYW5ndWxhciB2ZWxvY2l0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHdha2VVcCAtIEZvcmNlcyB0aGUgcmlnaWQtYm9keSB0byB3YWtlLXVwIGlmIGl0IHdhcyBhc2xlZXAuXG4gICAgICovXG4gICAgc2V0QW5ndmVsKHZlbCwgd2FrZVVwKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiU2V0QW5ndmVsKHRoaXMuaGFuZGxlLCB2ZWwsIHdha2VVcCk7XG4gICAgfVxuICAgIC8vICNlbmRpZlxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgcmlnaWQgYm9keSBpcyBraW5lbWF0aWMsIHNldHMgaXRzIGZ1dHVyZSB0cmFuc2xhdGlvbiBhZnRlciB0aGUgbmV4dCB0aW1lc3RlcCBpbnRlZ3JhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBgcmlnaWRCb2R5LnNldFRyYW5zbGF0aW9uYCB0byBtYWtlIHRoZSBkeW5hbWljIG9iamVjdFxuICAgICAqIGludGVyYWN0aW5nIHdpdGggdGhpcyBraW5lbWF0aWMgYm9keSBiZWhhdmUgYXMgZXhwZWN0ZWQuIEludGVybmFsbHksIFJhcGllciB3aWxsIGNvbXB1dGVcbiAgICAgKiBhbiBhcnRpZmljaWFsIHZlbG9jaXR5IGZvciB0aGlzIHJpZ2lkLWJvZHkgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiBhbmQgaXRzIG5leHQga2luZW1hdGljXG4gICAgICogcG9zaXRpb24uIFRoaXMgdmVsb2NpdHkgd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgZm9yY2VzIG9uIGR5bmFtaWMgYm9kaWVzIGludGVyYWN0aW5nIHdpdGhcbiAgICAgKiB0aGlzIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdCAtIFRoZSBraW5lbWF0aWMgdHJhbnNsYXRpb24gdG8gc2V0LlxuICAgICAqL1xuICAgIHNldE5leHRLaW5lbWF0aWNUcmFuc2xhdGlvbih0KSB7XG4gICAgICAgIC8vICNpZiBESU0yXG4gICAgICAgIHRoaXMucmF3U2V0LnJiU2V0TmV4dEtpbmVtYXRpY1RyYW5zbGF0aW9uKHRoaXMuaGFuZGxlLCB0LngsIHQueSk7XG4gICAgICAgIC8vICNlbmRpZlxuICAgIH1cbiAgICAvLyAjaWYgRElNMlxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgcmlnaWQgYm9keSBpcyBraW5lbWF0aWMsIHNldHMgaXRzIGZ1dHVyZSByb3RhdGlvbiBhZnRlciB0aGUgbmV4dCB0aW1lc3RlcCBpbnRlZ3JhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBgcmlnaWRCb2R5LnNldFJvdGF0aW9uYCB0byBtYWtlIHRoZSBkeW5hbWljIG9iamVjdFxuICAgICAqIGludGVyYWN0aW5nIHdpdGggdGhpcyBraW5lbWF0aWMgYm9keSBiZWhhdmUgYXMgZXhwZWN0ZWQuIEludGVybmFsbHksIFJhcGllciB3aWxsIGNvbXB1dGVcbiAgICAgKiBhbiBhcnRpZmljaWFsIHZlbG9jaXR5IGZvciB0aGlzIHJpZ2lkLWJvZHkgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiBhbmQgaXRzIG5leHQga2luZW1hdGljXG4gICAgICogcG9zaXRpb24uIFRoaXMgdmVsb2NpdHkgd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgZm9yY2VzIG9uIGR5bmFtaWMgYm9kaWVzIGludGVyYWN0aW5nIHdpdGhcbiAgICAgKiB0aGlzIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5nbGUgLSBUaGUga2luZW1hdGljIHJvdGF0aW9uIGFuZ2xlLCBpbiByYWRpYW5zLlxuICAgICAqL1xuICAgIHNldE5leHRLaW5lbWF0aWNSb3RhdGlvbihhbmdsZSkge1xuICAgICAgICB0aGlzLnJhd1NldC5yYlNldE5leHRLaW5lbWF0aWNSb3RhdGlvbih0aGlzLmhhbmRsZSwgYW5nbGUpO1xuICAgIH1cbiAgICAvLyAjZW5kaWZcbiAgICAvKipcbiAgICAgKiBUaGUgbGluZWFyIHZlbG9jaXR5IG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICBsaW52ZWwoKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyh0aGlzLnJhd1NldC5yYkxpbnZlbCh0aGlzLmhhbmRsZSkpO1xuICAgIH1cbiAgICAvLyAjaWYgRElNMlxuICAgIC8qKlxuICAgICAqIFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICBhbmd2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5yYkFuZ3ZlbCh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8vICNlbmRpZlxuICAgIC8qKlxuICAgICAqIFRoZSBtYXNzIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICBtYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJNYXNzKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2UgbWFzcyB0YWtpbmcgaW50byBhY2NvdW50IHRyYW5zbGF0aW9uIGxvY2tpbmcuXG4gICAgICovXG4gICAgZWZmZWN0aXZlSW52TWFzcygpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3U2V0LnJiRWZmZWN0aXZlSW52TWFzcyh0aGlzLmhhbmRsZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiB0aGUgbWFzcyBvZiBhIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGlzIHplcm8sIHRoZSByaWdpZC1ib2R5IGlzIGFzc3VtZWQgdG8gaGF2ZSBpbmZpbml0ZSBtYXNzLlxuICAgICAqL1xuICAgIGludk1hc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5yYkludk1hc3ModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2VudGVyIG9mIG1hc3Mgb2YgYSByaWdpZC1ib2R5IGV4cHJlc3NlZCBpbiBpdHMgbG9jYWwtc3BhY2UuXG4gICAgICovXG4gICAgbG9jYWxDb20oKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyh0aGlzLnJhd1NldC5yYkxvY2FsQ29tKHRoaXMuaGFuZGxlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZC1zcGFjZSBjZW50ZXIgb2YgbWFzcyBvZiB0aGUgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICB3b3JsZENvbSgpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3U2V0LnJiV29ybGRDb20odGhpcy5oYW5kbGUpKTtcbiAgICB9XG4gICAgLy8gI2lmIERJTTJcbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiB0aGUgcHJpbmNpcGFsIGFuZ3VsYXIgaW5lcnRpYSBvZiB0aGUgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIENvbXBvbmVudHMgc2V0IHRvIHplcm8gYXJlIGFzc3VtZWQgdG8gYmUgaW5maW5pdGUgYWxvbmcgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbmNpcGFsIGF4aXMuXG4gICAgICovXG4gICAgaW52UHJpbmNpcGFsSW5lcnRpYVNxcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5yYkludlByaW5jaXBhbEluZXJ0aWFTcXJ0KHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgLy8gI2lmIERJTTJcbiAgICAvKipcbiAgICAgKiBUaGUgYW5ndWxhciBpbmVydGlhIGFsb25nIHRoZSBwcmluY2lwYWwgaW5lcnRpYSBheGVzIG9mIHRoZSByaWdpZC1ib2R5LlxuICAgICAqL1xuICAgIHByaW5jaXBhbEluZXJ0aWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5yYlByaW5jaXBhbEluZXJ0aWEodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvLyAjZW5kaWZcbiAgICAvLyAjaWYgRElNMlxuICAgIC8qKlxuICAgICAqIFRoZSBzcXVhcmUtcm9vdCBvZiB0aGUgd29ybGQtc3BhY2UgaW52ZXJzZSBhbmd1bGFyIGluZXJ0aWEgdGVuc29yIG9mIHRoZSByaWdpZC1ib2R5LFxuICAgICAqIHRha2luZyBpbnRvIGFjY291bnQgcm90YXRpb24gbG9ja2luZy5cbiAgICAgKi9cbiAgICBlZmZlY3RpdmVXb3JsZEludkluZXJ0aWFTcXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJFZmZlY3RpdmVXb3JsZEludkluZXJ0aWFTcXJ0KHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgLy8gI2lmIERJTTJcbiAgICAvKipcbiAgICAgKiBUaGUgZWZmZWN0aXZlIHdvcmxkLXNwYWNlIGFuZ3VsYXIgaW5lcnRpYSAodGhhdCB0YWtlcyB0aGUgcG90ZW50aWFsIHJvdGF0aW9uIGxvY2tpbmcgaW50byBhY2NvdW50KSBvZlxuICAgICAqIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICBlZmZlY3RpdmVBbmd1bGFySW5lcnRpYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LnJiRWZmZWN0aXZlQW5ndWxhckluZXJ0aWEodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvLyAjZW5kaWZcbiAgICAvKipcbiAgICAgKiBQdXQgdGhpcyByaWdpZCBib2R5IHRvIHNsZWVwLlxuICAgICAqXG4gICAgICogQSBzbGVlcGluZyBib2R5IG5vIGxvbmdlciBtb3ZlcyBhbmQgaXMgbm8gbG9uZ2VyIHNpbXVsYXRlZCBieSB0aGUgcGh5c2ljcyBlbmdpbmUgdW5sZXNzXG4gICAgICogaXQgaXMgd2FrZW4gdXAuIEl0IGNhbiBiZSB3b2tlbiBtYW51YWxseSB3aXRoIGB0aGlzLndha2VVcCgpYCBvciBhdXRvbWF0aWNhbGx5IGR1ZSB0b1xuICAgICAqIGV4dGVybmFsIGZvcmNlcyBsaWtlIGNvbnRhY3RzLlxuICAgICAqL1xuICAgIHNsZWVwKCkge1xuICAgICAgICB0aGlzLnJhd1NldC5yYlNsZWVwKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FrZXMgdGhpcyByaWdpZC1ib2R5IHVwLlxuICAgICAqXG4gICAgICogQSBkeW5hbWljIHJpZ2lkLWJvZHkgdGhhdCBkb2VzIG5vdCBtb3ZlIGR1cmluZyBzZXZlcmFsIGNvbnNlY3V0aXZlIGZyYW1lcyB3aWxsXG4gICAgICogYmUgcHV0IHRvIHNsZWVwIGJ5IHRoZSBwaHlzaWNzIGVuZ2luZSwgaS5lLiwgaXQgd2lsbCBzdG9wIGJlaW5nIHNpbXVsYXRlZCBpbiBvcmRlclxuICAgICAqIHRvIGF2b2lkIHVzZWxlc3MgY29tcHV0YXRpb25zLlxuICAgICAqIFRoaXMgbWV0aG9kcyBmb3JjZXMgYSBzbGVlcGluZyByaWdpZC1ib2R5IHRvIHdha2UtdXAuIFRoaXMgaXMgdXNlZnVsLCBlLmcuLCBiZWZvcmUgbW9kaWZ5aW5nXG4gICAgICogdGhlIHBvc2l0aW9uIG9mIGEgZHluYW1pYyBib2R5IHNvIHRoYXQgaXQgaXMgcHJvcGVybHkgc2ltdWxhdGVkIGFmdGVyd2FyZHMuXG4gICAgICovXG4gICAgd2FrZVVwKCkge1xuICAgICAgICB0aGlzLnJhd1NldC5yYldha2VVcCh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIENDRCBlbmFibGVkIGZvciB0aGlzIHJpZ2lkLWJvZHk/XG4gICAgICovXG4gICAgaXNDY2RFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJJc0NjZEVuYWJsZWQodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGNvbGxpZGVycyBhdHRhY2hlZCB0byB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgbnVtQ29sbGlkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJOdW1Db2xsaWRlcnModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBpLXRoYCBjb2xsaWRlciBhdHRhY2hlZCB0byB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaSAtIFRoZSBpbmRleCBvZiB0aGUgY29sbGlkZXIgdG8gcmV0cmlldmUuIE11c3QgYmUgYSBudW1iZXIgaW4gYFswLCB0aGlzLm51bUNvbGxpZGVycygpW2AuXG4gICAgICogICAgICAgICBUaGlzIGluZGV4IGlzICoqbm90KiogdGhlIHNhbWUgYXMgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBjb2xsaWRlcihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVyU2V0LmdldCh0aGlzLnJhd1NldC5yYkNvbGxpZGVyKHRoaXMuaGFuZGxlLCBpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGlzIHJpZ2lkLWJvZHkgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5hYmxlZCAtIFNldCB0byBgZmFsc2VgIHRvIGRpc2FibGUgdGhpcyByaWdpZC1ib2R5IGFuZCBhbGwgaXRzIGF0dGFjaGVkIGNvbGxpZGVycy5cbiAgICAgKi9cbiAgICBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yYXdTZXQucmJTZXRFbmFibGVkKHRoaXMuaGFuZGxlLCBlbmFibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyByaWdpZC1ib2R5IGVuYWJsZWQ/XG4gICAgICovXG4gICAgaXNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJJc0VuYWJsZWQodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdHVzIG9mIHRoaXMgcmlnaWQtYm9keTogc3RhdGljLCBkeW5hbWljLCBvciBraW5lbWF0aWMuXG4gICAgICovXG4gICAgYm9keVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5yYkJvZHlUeXBlKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGEgbmV3IHN0YXR1cyBmb3IgdGhpcyByaWdpZC1ib2R5OiBzdGF0aWMsIGR5bmFtaWMsIG9yIGtpbmVtYXRpYy5cbiAgICAgKi9cbiAgICBzZXRCb2R5VHlwZSh0eXBlLCB3YWtlVXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LnJiU2V0Qm9keVR5cGUodGhpcy5oYW5kbGUsIHR5cGUsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgcmlnaWQtYm9keSBzbGVlcGluZz9cbiAgICAgKi9cbiAgICBpc1NsZWVwaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJJc1NsZWVwaW5nKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHZlbG9jaXR5IG9mIHRoaXMgcmlnaWQtYm9keSBub3QgemVybz9cbiAgICAgKi9cbiAgICBpc01vdmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LnJiSXNNb3ZpbmcodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIHJpZ2lkLWJvZHkgc3RhdGljP1xuICAgICAqL1xuICAgIGlzRml4ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5yYklzRml4ZWQodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIHJpZ2lkLWJvZHkga2luZW1hdGljP1xuICAgICAqL1xuICAgIGlzS2luZW1hdGljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJJc0tpbmVtYXRpYyh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgcmlnaWQtYm9keSBkeW5hbWljP1xuICAgICAqL1xuICAgIGlzRHluYW1pYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3U2V0LnJiSXNEeW5hbWljKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpbmVhciBkYW1waW5nIGNvZWZmaWNpZW50IG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICBsaW5lYXJEYW1waW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJMaW5lYXJEYW1waW5nKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFuZ3VsYXIgZGFtcGluZyBjb2VmZmljaWVudCBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgYW5ndWxhckRhbXBpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd1NldC5yYkFuZ3VsYXJEYW1waW5nKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGluZWFyIGRhbXBpbmcgZmFjdG9yIGFwcGxpZWQgdG8gdGhpcyByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZhY3RvciAtIFRoZSBkYW1waW5nIGZhY3RvciB0byBzZXQuXG4gICAgICovXG4gICAgc2V0TGluZWFyRGFtcGluZyhmYWN0b3IpIHtcbiAgICAgICAgdGhpcy5yYXdTZXQucmJTZXRMaW5lYXJEYW1waW5nKHRoaXMuaGFuZGxlLCBmYWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbXB1dGUgdGhlIG1hc3MtcHJvcGVydGllcyBvZiB0aGlzIHJpZ2lkLWJvZGllcyBiYXNlZCBvbiBpdHMgY3VycmVudGx5IGF0dGFjaGVkIGNvbGxpZGVycy5cbiAgICAgKi9cbiAgICByZWNvbXB1dGVNYXNzUHJvcGVydGllc0Zyb21Db2xsaWRlcnMoKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiUmVjb21wdXRlTWFzc1Byb3BlcnRpZXNGcm9tQ29sbGlkZXJzKHRoaXMuaGFuZGxlLCB0aGlzLmNvbGxpZGVyU2V0LnJhdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJpZ2lkLWJvZHkncyBhZGRpdGlvbmFsIG1hc3MuXG4gICAgICpcbiAgICAgKiBUaGUgdG90YWwgYW5ndWxhciBpbmVydGlhIG9mIHRoZSByaWdpZC1ib2R5IHdpbGwgYmUgc2NhbGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhpcyBhZGRpdGlvbmFsIG1hc3MuIElmIHRoaXNcbiAgICAgKiBzY2FsaW5nIGVmZmVjdCBpc27igJl0IGRlc2lyZWQsIHVzZSBTZWxmOjphZGRpdGlvbmFsX21hc3NfcHJvcGVydGllcyBpbnN0ZWFkIG9mIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBvbmx5IHRoZSBcImFkZGl0aW9uYWxcIiBtYXNzIGJlY2F1c2UgdGhlIHRvdGFsIG1hc3Mgb2YgdGhlIHJpZ2lkLWJvZHkgaXMgZXF1YWwgdG8gdGhlIHN1bSBvZiB0aGlzXG4gICAgICogYWRkaXRpb25hbCBtYXNzIGFuZCB0aGUgbWFzcyBjb21wdXRlZCBmcm9tIHRoZSBjb2xsaWRlcnMgKHdpdGggbm9uLXplcm8gZGVuc2l0aWVzKSBhdHRhY2hlZCB0byB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBUaGF0IHRvdGFsIG1hc3MgKHdoaWNoIGluY2x1ZGVzIHRoZSBhdHRhY2hlZCBjb2xsaWRlcnPigJkgY29udHJpYnV0aW9ucykgd2lsbCBiZSB1cGRhdGVkIGF0IHRoZSBuYW1lIHBoeXNpY3Mgc3RlcCxcbiAgICAgKiBvciBjYW4gYmUgdXBkYXRlZCBtYW51YWxseSB3aXRoIGB0aGlzLnJlY29tcHV0ZU1hc3NQcm9wZXJ0aWVzRnJvbUNvbGxpZGVyc2AuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgb3ZlcnJpZGUgYW55IHByZXZpb3VzIGFkZGl0aW9uYWwgbWFzcy1wcm9wZXJ0aWVzIHNldCBieSBgdGhpcy5zZXRBZGRpdGlvbmFsTWFzc2AsXG4gICAgICogYHRoaXMuc2V0QWRkaXRpb25hbE1hc3NQcm9wZXJ0aWVzYCwgYFJpZ2lkQm9keURlc2M6OnNldEFkZGl0aW9uYWxNYXNzYCwgb3JcbiAgICAgKiBgUmlnaWRCb2R5RGVzYy5zZXRBZGRpdGlvbmFsTWFzc2ZQcm9wZXJ0aWVzYCBmb3IgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hc3MgLSBUaGUgYWRkaXRpb25hbCBtYXNzIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gd2FrZVVwIC0gSWYgYHRydWVgIHRoZW4gdGhlIHJpZ2lkLWJvZHkgd2lsbCBiZSB3b2tlbiB1cCBpZiBpdCB3YXMgcHV0IHRvIHNsZWVwIGJlY2F1c2UgaXQgZGlkIG5vdCBtb3ZlIGZvciBhIHdoaWxlLlxuICAgICAqL1xuICAgIHNldEFkZGl0aW9uYWxNYXNzKG1hc3MsIHdha2VVcCkge1xuICAgICAgICB0aGlzLnJhd1NldC5yYlNldEFkZGl0aW9uYWxNYXNzKHRoaXMuaGFuZGxlLCBtYXNzLCB3YWtlVXApO1xuICAgIH1cbiAgICAvLyAjaWYgRElNMlxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJpZ2lkLWJvZHkncyBhZGRpdGlvbmFsIG1hc3MtcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgb25seSB0aGUgXCJhZGRpdGlvbmFsXCIgbWFzcy1wcm9wZXJ0aWVzIGJlY2F1c2UgdGhlIHRvdGFsIG1hc3MtcHJvcGVydGllcyBvZiB0aGUgcmlnaWQtYm9keSBpcyBlcXVhbCB0byB0aGVcbiAgICAgKiBzdW0gb2YgdGhpcyBhZGRpdGlvbmFsIG1hc3MtcHJvcGVydGllcyBhbmQgdGhlIG1hc3MgY29tcHV0ZWQgZnJvbSB0aGUgY29sbGlkZXJzICh3aXRoIG5vbi16ZXJvIGRlbnNpdGllcykgYXR0YWNoZWRcbiAgICAgKiB0byB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBUaGF0IHRvdGFsIG1hc3MtcHJvcGVydGllcyAod2hpY2ggaW5jbHVkZSB0aGUgYXR0YWNoZWQgY29sbGlkZXJz4oCZIGNvbnRyaWJ1dGlvbnMpIHdpbGwgYmUgdXBkYXRlZCBhdCB0aGUgbmFtZVxuICAgICAqIHBoeXNpY3Mgc3RlcCwgb3IgY2FuIGJlIHVwZGF0ZWQgbWFudWFsbHkgd2l0aCBgdGhpcy5yZWNvbXB1dGVNYXNzUHJvcGVydGllc0Zyb21Db2xsaWRlcnNgLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIG92ZXJyaWRlIGFueSBwcmV2aW91cyBtYXNzLXByb3BlcnRpZXMgc2V0IGJ5IGB0aGlzLnNldEFkZGl0aW9uYWxNYXNzYCxcbiAgICAgKiBgdGhpcy5zZXRBZGRpdGlvbmFsTWFzc1Byb3BlcnRpZXNgLCBgUmlnaWRCb2R5RGVzYy5zZXRBZGRpdGlvbmFsTWFzc2AsIG9yIGBSaWdpZEJvZHlEZXNjLnNldEFkZGl0aW9uYWxNYXNzUHJvcGVydGllc2BcbiAgICAgKiBmb3IgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogSWYgYHdha2VfdXBgIGlzIHRydWUgdGhlbiB0aGUgcmlnaWQtYm9keSB3aWxsIGJlIHdva2VuIHVwIGlmIGl0IHdhcyBwdXQgdG8gc2xlZXAgYmVjYXVzZSBpdCBkaWQgbm90IG1vdmUgZm9yIGEgd2hpbGUuXG4gICAgICovXG4gICAgc2V0QWRkaXRpb25hbE1hc3NQcm9wZXJ0aWVzKG1hc3MsIGNlbnRlck9mTWFzcywgcHJpbmNpcGFsQW5ndWxhckluZXJ0aWEsIHdha2VVcCkge1xuICAgICAgICBsZXQgcmF3Q29tID0gVmVjdG9yT3BzLmludG9SYXcoY2VudGVyT2ZNYXNzKTtcbiAgICAgICAgdGhpcy5yYXdTZXQucmJTZXRBZGRpdGlvbmFsTWFzc1Byb3BlcnRpZXModGhpcy5oYW5kbGUsIG1hc3MsIHJhd0NvbSwgcHJpbmNpcGFsQW5ndWxhckluZXJ0aWEsIHdha2VVcCk7XG4gICAgICAgIHJhd0NvbS5mcmVlKCk7XG4gICAgfVxuICAgIC8vICNlbmRpZlxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpbmVhciBkYW1waW5nIGZhY3RvciBhcHBsaWVkIHRvIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmYWN0b3IgLSBUaGUgZGFtcGluZyBmYWN0b3IgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldEFuZ3VsYXJEYW1waW5nKGZhY3Rvcikge1xuICAgICAgICB0aGlzLnJhd1NldC5yYlNldEFuZ3VsYXJEYW1waW5nKHRoaXMuaGFuZGxlLCBmYWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdG8gemVybyB0aGUgdXNlciBmb3JjZXMgKGJ1dCBub3QgdG9ycXVlcykgYXBwbGllZCB0byB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FrZVVwIC0gc2hvdWxkIHRoZSByaWdpZC1ib2R5IGJlIGF1dG9tYXRpY2FsbHkgd29rZW4tdXA/XG4gICAgICovXG4gICAgcmVzZXRGb3JjZXMod2FrZVVwKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiUmVzZXRGb3JjZXModGhpcy5oYW5kbGUsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0byB6ZXJvIHRoZSB1c2VyIHRvcnF1ZXMgYXBwbGllZCB0byB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2FrZVVwIC0gc2hvdWxkIHRoZSByaWdpZC1ib2R5IGJlIGF1dG9tYXRpY2FsbHkgd29rZW4tdXA/XG4gICAgICovXG4gICAgcmVzZXRUb3JxdWVzKHdha2VVcCkge1xuICAgICAgICB0aGlzLnJhd1NldC5yYlJlc2V0VG9ycXVlcyh0aGlzLmhhbmRsZSwgd2FrZVVwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZvcmNlIGF0IHRoZSBjZW50ZXItb2YtbWFzcyBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2UgLSB0aGUgd29ybGQtc3BhY2UgZm9yY2UgdG8gYWRkIHRvIHRoZSByaWdpZC1ib2R5LlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBzaG91bGQgdGhlIHJpZ2lkLWJvZHkgYmUgYXV0b21hdGljYWxseSB3b2tlbi11cD9cbiAgICAgKi9cbiAgICBhZGRGb3JjZShmb3JjZSwgd2FrZVVwKSB7XG4gICAgICAgIGNvbnN0IHJhd0ZvcmNlID0gVmVjdG9yT3BzLmludG9SYXcoZm9yY2UpO1xuICAgICAgICB0aGlzLnJhd1NldC5yYkFkZEZvcmNlKHRoaXMuaGFuZGxlLCByYXdGb3JjZSwgd2FrZVVwKTtcbiAgICAgICAgcmF3Rm9yY2UuZnJlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFuIGltcHVsc2UgYXQgdGhlIGNlbnRlci1vZi1tYXNzIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbXB1bHNlIC0gdGhlIHdvcmxkLXNwYWNlIGltcHVsc2UgdG8gYXBwbHkgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgICogQHBhcmFtIHdha2VVcCAtIHNob3VsZCB0aGUgcmlnaWQtYm9keSBiZSBhdXRvbWF0aWNhbGx5IHdva2VuLXVwP1xuICAgICAqL1xuICAgIGFwcGx5SW1wdWxzZShpbXB1bHNlLCB3YWtlVXApIHtcbiAgICAgICAgY29uc3QgcmF3SW1wdWxzZSA9IFZlY3Rvck9wcy5pbnRvUmF3KGltcHVsc2UpO1xuICAgICAgICB0aGlzLnJhd1NldC5yYkFwcGx5SW1wdWxzZSh0aGlzLmhhbmRsZSwgcmF3SW1wdWxzZSwgd2FrZVVwKTtcbiAgICAgICAgcmF3SW1wdWxzZS5mcmVlKCk7XG4gICAgfVxuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRvcnF1ZSBhdCB0aGUgY2VudGVyLW9mLW1hc3Mgb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRvcnF1ZSAtIHRoZSB0b3JxdWUgdG8gYWRkIHRvIHRoZSByaWdpZC1ib2R5LlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBzaG91bGQgdGhlIHJpZ2lkLWJvZHkgYmUgYXV0b21hdGljYWxseSB3b2tlbi11cD9cbiAgICAgKi9cbiAgICBhZGRUb3JxdWUodG9ycXVlLCB3YWtlVXApIHtcbiAgICAgICAgdGhpcy5yYXdTZXQucmJBZGRUb3JxdWUodGhpcy5oYW5kbGUsIHRvcnF1ZSwgd2FrZVVwKTtcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgLy8gI2lmIERJTTJcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFuIGltcHVsc2l2ZSB0b3JxdWUgYXQgdGhlIGNlbnRlci1vZi1tYXNzIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b3JxdWVJbXB1bHNlIC0gdGhlIHRvcnF1ZSBpbXB1bHNlIHRvIGFwcGx5IG9uIHRoZSByaWdpZC1ib2R5LlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBzaG91bGQgdGhlIHJpZ2lkLWJvZHkgYmUgYXV0b21hdGljYWxseSB3b2tlbi11cD9cbiAgICAgKi9cbiAgICBhcHBseVRvcnF1ZUltcHVsc2UodG9ycXVlSW1wdWxzZSwgd2FrZVVwKSB7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiQXBwbHlUb3JxdWVJbXB1bHNlKHRoaXMuaGFuZGxlLCB0b3JxdWVJbXB1bHNlLCB3YWtlVXApO1xuICAgIH1cbiAgICAvLyAjZW5kaWZcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZm9yY2UgYXQgdGhlIGdpdmVuIHdvcmxkLXNwYWNlIHBvaW50IG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JjZSAtIHRoZSB3b3JsZC1zcGFjZSBmb3JjZSB0byBhZGQgdG8gdGhlIHJpZ2lkLWJvZHkuXG4gICAgICogQHBhcmFtIHBvaW50IC0gdGhlIHdvcmxkLXNwYWNlIHBvaW50IHdoZXJlIHRoZSBpbXB1bHNlIGlzIHRvIGJlIGFwcGxpZWQgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgICogQHBhcmFtIHdha2VVcCAtIHNob3VsZCB0aGUgcmlnaWQtYm9keSBiZSBhdXRvbWF0aWNhbGx5IHdva2VuLXVwP1xuICAgICAqL1xuICAgIGFkZEZvcmNlQXRQb2ludChmb3JjZSwgcG9pbnQsIHdha2VVcCkge1xuICAgICAgICBjb25zdCByYXdGb3JjZSA9IFZlY3Rvck9wcy5pbnRvUmF3KGZvcmNlKTtcbiAgICAgICAgY29uc3QgcmF3UG9pbnQgPSBWZWN0b3JPcHMuaW50b1Jhdyhwb2ludCk7XG4gICAgICAgIHRoaXMucmF3U2V0LnJiQWRkRm9yY2VBdFBvaW50KHRoaXMuaGFuZGxlLCByYXdGb3JjZSwgcmF3UG9pbnQsIHdha2VVcCk7XG4gICAgICAgIHJhd0ZvcmNlLmZyZWUoKTtcbiAgICAgICAgcmF3UG9pbnQuZnJlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFuIGltcHVsc2UgYXQgdGhlIGdpdmVuIHdvcmxkLXNwYWNlIHBvaW50IG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbXB1bHNlIC0gdGhlIHdvcmxkLXNwYWNlIGltcHVsc2UgdG8gYXBwbHkgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgICogQHBhcmFtIHBvaW50IC0gdGhlIHdvcmxkLXNwYWNlIHBvaW50IHdoZXJlIHRoZSBpbXB1bHNlIGlzIHRvIGJlIGFwcGxpZWQgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgICogQHBhcmFtIHdha2VVcCAtIHNob3VsZCB0aGUgcmlnaWQtYm9keSBiZSBhdXRvbWF0aWNhbGx5IHdva2VuLXVwP1xuICAgICAqL1xuICAgIGFwcGx5SW1wdWxzZUF0UG9pbnQoaW1wdWxzZSwgcG9pbnQsIHdha2VVcCkge1xuICAgICAgICBjb25zdCByYXdJbXB1bHNlID0gVmVjdG9yT3BzLmludG9SYXcoaW1wdWxzZSk7XG4gICAgICAgIGNvbnN0IHJhd1BvaW50ID0gVmVjdG9yT3BzLmludG9SYXcocG9pbnQpO1xuICAgICAgICB0aGlzLnJhd1NldC5yYkFwcGx5SW1wdWxzZUF0UG9pbnQodGhpcy5oYW5kbGUsIHJhd0ltcHVsc2UsIHJhd1BvaW50LCB3YWtlVXApO1xuICAgICAgICByYXdJbXB1bHNlLmZyZWUoKTtcbiAgICAgICAgcmF3UG9pbnQuZnJlZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbnN0YW50IGZvcmNlKHMpIHRoZSB1c2VyIGFkZGVkIHRvIHRoaXMgcmlnaWQtYm9keVxuICAgICAqIFJldHVybnMgemVybyBpZiB0aGUgcmlnaWQtYm9keSBpcyBub3QgZHluYW1pYy5cbiAgICAgKi9cbiAgICB1c2VyRm9yY2UoKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyh0aGlzLnJhd1NldC5yYlVzZXJGb3JjZSh0aGlzLmhhbmRsZSkpO1xuICAgIH1cbiAgICAvLyAjaWYgRElNMlxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY29uc3RhbnQgdG9ycXVlKHMpIHRoZSB1c2VyIGFkZGVkIHRvIHRoaXMgcmlnaWQtYm9keVxuICAgICAqIFJldHVybnMgemVybyBpZiB0aGUgcmlnaWQtYm9keSBpcyBub3QgZHluYW1pYy5cbiAgICAgKi9cbiAgICB1c2VyVG9ycXVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdTZXQucmJVc2VyVG9ycXVlKHRoaXMuaGFuZGxlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmlnaWRCb2R5RGVzYyB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uID0gVmVjdG9yT3BzLnplcm9zKCk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBSb3RhdGlvbk9wcy5pZGVudGl0eSgpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTY2FsZSA9IDEuMDtcbiAgICAgICAgdGhpcy5saW52ZWwgPSBWZWN0b3JPcHMuemVyb3MoKTtcbiAgICAgICAgdGhpcy5tYXNzID0gMC4wO1xuICAgICAgICB0aGlzLm1hc3NPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2VudGVyT2ZNYXNzID0gVmVjdG9yT3BzLnplcm9zKCk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25zRW5hYmxlZFggPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uc0VuYWJsZWRZID0gdHJ1ZTtcbiAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgdGhpcy5hbmd2ZWwgPSAwLjA7XG4gICAgICAgIHRoaXMucHJpbmNpcGFsQW5ndWxhckluZXJ0aWEgPSAwLjA7XG4gICAgICAgIHRoaXMucm90YXRpb25zRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIC8vICNlbmRpZlxuICAgICAgICB0aGlzLmxpbmVhckRhbXBpbmcgPSAwLjA7XG4gICAgICAgIHRoaXMuYW5ndWxhckRhbXBpbmcgPSAwLjA7XG4gICAgICAgIHRoaXMuY2FuU2xlZXAgPSB0cnVlO1xuICAgICAgICB0aGlzLnNsZWVwaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2NkRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvZnRDY2RQcmVkaWN0aW9uID0gMC4wO1xuICAgICAgICB0aGlzLmRvbWluYW5jZUdyb3VwID0gMDtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsU29sdmVySXRlcmF0aW9ucyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmlnaWQtYm9keSBkZXNjcmlwdG9yIHVzZWQgdG8gYnVpbGQgYSBkeW5hbWljIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgc3RhdGljIGR5bmFtaWMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaWRCb2R5RGVzYyhSaWdpZEJvZHlUeXBlLkR5bmFtaWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJpZ2lkLWJvZHkgZGVzY3JpcHRvciB1c2VkIHRvIGJ1aWxkIGEgcG9zaXRpb24tYmFzZWQga2luZW1hdGljIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgc3RhdGljIGtpbmVtYXRpY1Bvc2l0aW9uQmFzZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaWRCb2R5RGVzYyhSaWdpZEJvZHlUeXBlLktpbmVtYXRpY1Bvc2l0aW9uQmFzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJpZ2lkLWJvZHkgZGVzY3JpcHRvciB1c2VkIHRvIGJ1aWxkIGEgdmVsb2NpdHktYmFzZWQga2luZW1hdGljIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgc3RhdGljIGtpbmVtYXRpY1ZlbG9jaXR5QmFzZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaWRCb2R5RGVzYyhSaWdpZEJvZHlUeXBlLktpbmVtYXRpY1ZlbG9jaXR5QmFzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJpZ2lkLWJvZHkgZGVzY3JpcHRvciB1c2VkIHRvIGJ1aWxkIGEgZml4ZWQgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZml4ZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaWRCb2R5RGVzYyhSaWdpZEJvZHlUeXBlLkZpeGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByaWdpZC1ib2R5IGRlc2NyaXB0b3IgdXNlZCB0byBidWlsZCBhIGR5bmFtaWMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFRoZSBtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBgLmR5bmFtaWMoKWAuXG4gICAgICovXG4gICAgc3RhdGljIG5ld0R5bmFtaWMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlnaWRCb2R5RGVzYyhSaWdpZEJvZHlUeXBlLkR5bmFtaWMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJpZ2lkLWJvZHkgZGVzY3JpcHRvciB1c2VkIHRvIGJ1aWxkIGEgcG9zaXRpb24tYmFzZWQga2luZW1hdGljIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGUgbWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYC5raW5lbWF0aWNQb3NpdGlvbkJhc2VkKClgLlxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdLaW5lbWF0aWNQb3NpdGlvbkJhc2VkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJpZ2lkQm9keURlc2MoUmlnaWRCb2R5VHlwZS5LaW5lbWF0aWNQb3NpdGlvbkJhc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByaWdpZC1ib2R5IGRlc2NyaXB0b3IgdXNlZCB0byBidWlsZCBhIHZlbG9jaXR5LWJhc2VkIGtpbmVtYXRpYyByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIG1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIGAua2luZW1hdGljVmVsb2NpdHlCYXNlZCgpYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3S2luZW1hdGljVmVsb2NpdHlCYXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdpZEJvZHlEZXNjKFJpZ2lkQm9keVR5cGUuS2luZW1hdGljVmVsb2NpdHlCYXNlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmlnaWQtYm9keSBkZXNjcmlwdG9yIHVzZWQgdG8gYnVpbGQgYSBmaXhlZCByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVGhlIG1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIGAuZml4ZWQoKWAuXG4gICAgICovXG4gICAgc3RhdGljIG5ld1N0YXRpYygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdpZEJvZHlEZXNjKFJpZ2lkQm9keVR5cGUuRml4ZWQpO1xuICAgIH1cbiAgICBzZXREb21pbmFuY2VHcm91cChncm91cCkge1xuICAgICAgICB0aGlzLmRvbWluYW5jZUdyb3VwID0gZ3JvdXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgYWRkaXRpb25hbCBzb2x2ZXIgaXRlcmF0aW9ucyB0aGF0IHdpbGwgYmUgcnVuIGZvciB0aGlzXG4gICAgICogcmlnaWQtYm9keSBhbmQgZXZlcnl0aGluZyB0aGF0IGludGVyYWN0cyB3aXRoIGl0IGRpcmVjdGx5IG9yIGluZGlyZWN0bHlcbiAgICAgKiB0aHJvdWdoIGNvbnRhY3RzIG9yIGpvaW50cy5cbiAgICAgKlxuICAgICAqIENvbXBhcmVkIHRvIGluY3JlYXNpbmcgdGhlIGdsb2JhbCBgV29ybGQubnVtU29sdmVySXRlcmF0aW9uYCwgc2V0dGluZyB0aGlzXG4gICAgICogdmFsdWUgbGV0cyB5b3UgaW5jcmVhc2UgYWNjdXJhY3kgb24gb25seSBhIHN1YnNldCBvZiB0aGUgc2NlbmUsIHJlc3VsdGluZyBpbiByZWR1Y2VkXG4gICAgICogcGVyZm9ybWFuY2UgbG9zcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVycyAtIFRoZSBuZXcgbnVtYmVyIG9mIGFkZGl0aW9uYWwgc29sdmVyIGl0ZXJhdGlvbnMgKGRlZmF1bHQ6IDApLlxuICAgICAqL1xuICAgIHNldEFkZGl0aW9uYWxTb2x2ZXJJdGVyYXRpb25zKGl0ZXJzKSB7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnMgPSBpdGVycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciB0aGUgY3JlYXRlZCByaWdpZC1ib2R5IHdpbGwgYmUgZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAgICAgKiBAcGFyYW0gZW5hYmxlZCDiiJIgSWYgc2V0IHRvIGBmYWxzZWAgdGhlIHJpZ2lkLWJvZHkgd2lsbCBiZSBkaXNhYmxlZCBhdCBjcmVhdGlvbi5cbiAgICAgKi9cbiAgICBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5pdGlhbCB0cmFuc2xhdGlvbiBvZiB0aGUgcmlnaWQtYm9keSB0byBjcmVhdGUuXG4gICAgICovXG4gICAgc2V0VHJhbnNsYXRpb24oeCwgeSkge1xuICAgICAgICBpZiAodHlwZW9mIHggIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudHMgbXVzdCBiZSBudW1iZXJzLlwiKTtcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbiA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5pdGlhbCByb3RhdGlvbiBvZiB0aGUgcmlnaWQtYm9keSB0byBjcmVhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm90IC0gVGhlIHJvdGF0aW9uIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXRSb3RhdGlvbihyb3QpIHtcbiAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvdDtcbiAgICAgICAgLy8gI2VuZGlmXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzY2FsZSBmYWN0b3IgYXBwbGllZCB0byB0aGUgZ3Jhdml0eSBhZmZlY3RpbmdcbiAgICAgKiB0aGUgcmlnaWQtYm9keSBiZWluZyBidWlsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2FsZSAtIFRoZSBzY2FsZSBmYWN0b3IuIFNldCB0aGlzIHRvIGAwLjBgIGlmIHRoZSByaWdpZC1ib2R5XG4gICAgICogICBuZWVkcyB0byBpZ25vcmUgZ3Jhdml0eS5cbiAgICAgKi9cbiAgICBzZXRHcmF2aXR5U2NhbGUoc2NhbGUpIHtcbiAgICAgICAgdGhpcy5ncmF2aXR5U2NhbGUgPSBzY2FsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluaXRpYWwgbWFzcyBvZiB0aGUgcmlnaWQtYm9keSBiZWluZyBidWlsdCwgYmVmb3JlIGFkZGluZyBjb2xsaWRlcnMnIGNvbnRyaWJ1dGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFzcyDiiJIgVGhlIGluaXRpYWwgbWFzcyBvZiB0aGUgcmlnaWQtYm9keSB0byBjcmVhdGUuXG4gICAgICovXG4gICAgc2V0QWRkaXRpb25hbE1hc3MobWFzcykge1xuICAgICAgICB0aGlzLm1hc3MgPSBtYXNzO1xuICAgICAgICB0aGlzLm1hc3NPbmx5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5pdGlhbCBsaW5lYXIgdmVsb2NpdHkgb2YgdGhlIHJpZ2lkLWJvZHkgdG8gY3JlYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHggLSBUaGUgbGluZWFyIHZlbG9jaXR5IHRvIHNldCBhbG9uZyB0aGUgYHhgIGF4aXMuXG4gICAgICogQHBhcmFtIHkgLSBUaGUgbGluZWFyIHZlbG9jaXR5IHRvIHNldCBhbG9uZyB0aGUgYHlgIGF4aXMuXG4gICAgICovXG4gICAgc2V0TGludmVsKHgsIHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHkgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIlRoZSBsaW52ZWwgY29tcG9uZW50cyBtdXN0IGJlIG51bWJlcnMuXCIpO1xuICAgICAgICB0aGlzLmxpbnZlbCA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5pdGlhbCBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSByaWdpZC1ib2R5IHRvIGNyZWF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2ZWwgLSBUaGUgYW5ndWxhciB2ZWxvY2l0eSB0byBzZXQuXG4gICAgICovXG4gICAgc2V0QW5ndmVsKHZlbCkge1xuICAgICAgICB0aGlzLmFuZ3ZlbCA9IHZlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGUgcmlnaWQtYm9keSBiZWluZyBidWlsdC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWwgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoZSByaWdpZC1ib2RpZXMgZGVwZW5kc1xuICAgICAqIG9uIHRoZSBpbml0aWFsIG1hc3MtcHJvcGVydGllcyBvZiB0aGUgcmlnaWQtYm9keSAoc2V0IGJ5IHRoaXMgbWV0aG9kKVxuICAgICAqIHRvIHdoaWNoIGlzIGFkZGVkIHRoZSBjb250cmlidXRpb25zIG9mIGFsbCB0aGUgY29sbGlkZXJzIHdpdGggbm9uLXplcm8gZGVuc2l0eVxuICAgICAqIGF0dGFjaGVkIHRvIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIFRoZXJlZm9yZSwgaWYgeW91IHdhbnQgeW91ciBwcm92aWRlZCBtYXNzIHByb3BlcnRpZXMgdG8gYmUgdGhlIGZpbmFsXG4gICAgICogbWFzcyBwcm9wZXJ0aWVzIG9mIHlvdXIgcmlnaWQtYm9keSwgZG9uJ3QgYXR0YWNoIGNvbGxpZGVycyB0byBpdCwgb3JcbiAgICAgKiBvbmx5IGF0dGFjaCBjb2xsaWRlcnMgd2l0aCBkZW5zaXRpZXMgZXF1YWwgdG8gemVyby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXNzIOKIkiBUaGUgaW5pdGlhbCBtYXNzIG9mIHRoZSByaWdpZC1ib2R5IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0gY2VudGVyT2ZNYXNzIOKIkiBUaGUgaW5pdGlhbCBjZW50ZXItb2YtbWFzcyBvZiB0aGUgcmlnaWQtYm9keSB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhIOKIkiBUaGUgaW5pdGlhbCBwcmluY2lwYWwgYW5ndWxhciBpbmVydGlhIG9mIHRoZSByaWdpZC1ib2R5IHRvIGNyZWF0ZS5cbiAgICAgKi9cbiAgICBzZXRBZGRpdGlvbmFsTWFzc1Byb3BlcnRpZXMobWFzcywgY2VudGVyT2ZNYXNzLCBwcmluY2lwYWxBbmd1bGFySW5lcnRpYSkge1xuICAgICAgICB0aGlzLm1hc3MgPSBtYXNzO1xuICAgICAgICBWZWN0b3JPcHMuY29weSh0aGlzLmNlbnRlck9mTWFzcywgY2VudGVyT2ZNYXNzKTtcbiAgICAgICAgdGhpcy5wcmluY2lwYWxBbmd1bGFySW5lcnRpYSA9IHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhO1xuICAgICAgICB0aGlzLm1hc3NPbmx5ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvdyB0cmFuc2xhdGlvbiBvZiB0aGlzIHJpZ2lkLWJvZHkgb25seSBhbG9uZyBzcGVjaWZpYyBheGVzLlxuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbnNFbmFibGVkWCAtIEFyZSB0cmFuc2xhdGlvbnMgYWxvbmcgdGhlIFggYXhpcyBlbmFibGVkP1xuICAgICAqIEBwYXJhbSB0cmFuc2xhdGlvbnNFbmFibGVkWSAtIEFyZSB0cmFuc2xhdGlvbnMgYWxvbmcgdGhlIHkgYXhpcyBlbmFibGVkP1xuICAgICAqL1xuICAgIGVuYWJsZWRUcmFuc2xhdGlvbnModHJhbnNsYXRpb25zRW5hYmxlZFgsIHRyYW5zbGF0aW9uc0VuYWJsZWRZKSB7XG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25zRW5hYmxlZFggPSB0cmFuc2xhdGlvbnNFbmFibGVkWDtcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbnNFbmFibGVkWSA9IHRyYW5zbGF0aW9uc0VuYWJsZWRZO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3cgdHJhbnNsYXRpb24gb2YgdGhpcyByaWdpZC1ib2R5IG9ubHkgYWxvbmcgc3BlY2lmaWMgYXhlcy5cbiAgICAgKiBAcGFyYW0gdHJhbnNsYXRpb25zRW5hYmxlZFggLSBBcmUgdHJhbnNsYXRpb25zIGFsb25nIHRoZSBYIGF4aXMgZW5hYmxlZD9cbiAgICAgKiBAcGFyYW0gdHJhbnNsYXRpb25zRW5hYmxlZFkgLSBBcmUgdHJhbnNsYXRpb25zIGFsb25nIHRoZSB5IGF4aXMgZW5hYmxlZD9cbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgYHRoaXMuZW5hYmxlZFRyYW5zbGF0aW9uc2Agd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMgaW5zdGVhZC5cbiAgICAgKi9cbiAgICByZXN0cmljdFRyYW5zbGF0aW9ucyh0cmFuc2xhdGlvbnNFbmFibGVkWCwgdHJhbnNsYXRpb25zRW5hYmxlZFkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZFRyYW5zbGF0aW9ucyh0cmFuc2xhdGlvbnNFbmFibGVkWCwgdHJhbnNsYXRpb25zRW5hYmxlZFkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2NrcyBhbGwgdHJhbnNsYXRpb25zIHRoYXQgd291bGQgaGF2ZSByZXN1bHRlZCBmcm9tIGZvcmNlcyBvblxuICAgICAqIHRoZSBjcmVhdGVkIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgbG9ja1RyYW5zbGF0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdHJpY3RUcmFuc2xhdGlvbnMoZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ja3MgYWxsIHJvdGF0aW9ucyB0aGF0IHdvdWxkIGhhdmUgcmVzdWx0ZWQgZnJvbSBmb3JjZXMgb25cbiAgICAgKiB0aGUgY3JlYXRlZCByaWdpZC1ib2R5LlxuICAgICAqL1xuICAgIGxvY2tSb3RhdGlvbnMoKSB7XG4gICAgICAgIHRoaXMucm90YXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGluZWFyIGRhbXBpbmcgb2YgdGhlIHJpZ2lkLWJvZHkgdG8gY3JlYXRlLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIHByb2dyZXNzaXZlbHkgc2xvd2Rvd24gdGhlIHRyYW5zbGF0aW9uYWwgbW92ZW1lbnQgb2YgdGhlIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGFtcGluZyAtIFRoZSBhbmd1bGFyIGRhbXBpbmcgY29lZmZpY2llbnQuIFNob3VsZCBiZSA+PSAwLiBUaGUgaGlnaGVyIHRoaXNcbiAgICAgKiAgICAgICAgICAgICAgICAgIHZhbHVlIGlzLCB0aGUgc3Ryb25nZXIgdGhlIHRyYW5zbGF0aW9uYWwgc2xvd2Rvd24gd2lsbCBiZS5cbiAgICAgKi9cbiAgICBzZXRMaW5lYXJEYW1waW5nKGRhbXBpbmcpIHtcbiAgICAgICAgdGhpcy5saW5lYXJEYW1waW5nID0gZGFtcGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFuZ3VsYXIgZGFtcGluZyBvZiB0aGUgcmlnaWQtYm9keSB0byBjcmVhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcHJvZ3Jlc3NpdmVseSBzbG93ZG93biB0aGUgcm90YXRpb25hbCBtb3ZlbWVudCBvZiB0aGUgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYW1waW5nIC0gVGhlIGFuZ3VsYXIgZGFtcGluZyBjb2VmZmljaWVudC4gU2hvdWxkIGJlID49IDAuIFRoZSBoaWdoZXIgdGhpc1xuICAgICAqICAgICAgICAgICAgICAgICAgdmFsdWUgaXMsIHRoZSBzdHJvbmdlciB0aGUgcm90YXRpb25hbCBzbG93ZG93biB3aWxsIGJlLlxuICAgICAqL1xuICAgIHNldEFuZ3VsYXJEYW1waW5nKGRhbXBpbmcpIHtcbiAgICAgICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IGRhbXBpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IHRoZSByaWdpZC1ib2R5IHRvIGNyZWF0ZSBjYW4gc2xlZXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FuIC0gdHJ1ZSBpZiB0aGUgcmlnaWQtYm9keSBjYW4gc2xlZXAsIGZhbHNlIGlmIGl0IGNhbid0LlxuICAgICAqL1xuICAgIHNldENhblNsZWVwKGNhbikge1xuICAgICAgICB0aGlzLmNhblNsZWVwID0gY2FuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcmlnaWQtYm9keSBpcyB0byBiZSBjcmVhdGVkIGFzbGVlcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYW4gLSB0cnVlIGlmIHRoZSByaWdpZC1ib2R5IHNob3VsZCBiZSBpbiBzbGVlcCwgZGVmYXVsdCBmYWxzZS5cbiAgICAgKi9cbiAgICBzZXRTbGVlcGluZyhzbGVlcGluZykge1xuICAgICAgICB0aGlzLnNsZWVwaW5nID0gc2xlZXBpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgQ29udGludW91cyBDb2xsaXNpb24gRGV0ZWN0aW9uIChDQ0QpIGlzIGVuYWJsZWQgZm9yIHRoaXMgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmFibGVkIC0gdHJ1ZSBpZiB0aGUgcmlnaWQtYm9keSBoYXMgQ0NEIGVuYWJsZWQuXG4gICAgICovXG4gICAgc2V0Q2NkRW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuY2NkRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXhpbXVtIHByZWRpY3Rpb24gZGlzdGFuY2UgU29mdCBDb250aW51b3VzIENvbGxpc2lvbi1EZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiBXaGVuIHNldCB0byAwLCBzb2Z0LUNDRCBpcyBkaXNhYmxlZC4gU29mdC1DQ0QgaGVscHMgcHJldmVudCB0dW5uZWxpbmcgZXNwZWNpYWxseSBvZlxuICAgICAqIHNsb3ctYnV0LXRoaW4gdG8gbW9kZXJhdGVseSBmYXN0IG9iamVjdHMuIFRoZSBzb2Z0IENDRCBwcmVkaWN0aW9uIGRpc3RhbmNlIGluZGljYXRlcyBob3dcbiAgICAgKiBmYXIgaW4gdGhlIG9iamVjdOKAmXMgcGF0aCB0aGUgQ0NEIGFsZ29yaXRobSBpcyBhbGxvd2VkIHRvIGluc3BlY3QuIExhcmdlIHZhbHVlcyBjYW4gaW1wYWN0XG4gICAgICogcGVyZm9ybWFuY2UgYmFkbHkgYnkgaW5jcmVhc2luZyB0aGUgd29yayBuZWVkZWQgZnJvbSB0aGUgYnJvYWQtcGhhc2UuXG4gICAgICpcbiAgICAgKiBJdCBpcyBhIGdlbmVyYWxseSBjaGVhcGVyIHZhcmlhbnQgb2YgcmVndWxhciBDQ0QgKHRoYXQgY2FuIGJlIGVuYWJsZWQgd2l0aFxuICAgICAqIGBSaWdpZEJvZHlEZXNjOjpzZXRDY2RFbmFibGVkYCBzaW5jZSBpdCByZWxpZXMgb24gcHJlZGljdGl2ZSBjb25zdHJhaW50cyBpbnN0ZWFkIG9mXG4gICAgICogc2hhcGUtY2FzdCBhbmQgc3Vic3RlcHMuXG4gICAgICovXG4gICAgc2V0U29mdENjZFByZWRpY3Rpb24oZGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5zb2Z0Q2NkUHJlZGljdGlvbiA9IGRpc3RhbmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdXNlci1kZWZpbmVkIG9iamVjdCBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckRhdGEgLSBUaGUgdXNlci1kZWZpbmVkIG9iamVjdCB0byBzZXQuXG4gICAgICovXG4gICAgc2V0VXNlckRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLnVzZXJEYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlnaWRfYm9keS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/rigid_body.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigidBodySet: () => (/* binding */ RigidBodySet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _rigid_body__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rigid_body */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/rigid_body.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _rigid_body__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _rigid_body__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass RigidBodySet {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodySet();\n        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle) => {\n                this.map.set(handle, new _rigid_body__WEBPACK_IMPORTED_MODULE_2__.RigidBody(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    finalizeDeserialization(colliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    createRigidBody(colliderSet, desc) {\n        let rawTra = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.translation);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_3__.RotationOps.intoRaw(desc.rotation);\n        let rawLv = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.linvel);\n        let rawCom = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.centerOfMass);\n        let handle = this.raw.createRigidBody(desc.enabled, rawTra, rawRot, desc.gravityScale, desc.mass, desc.massOnly, rawCom, rawLv, \n        // #if DIM2\n        desc.angvel, desc.principalAngularInertia, desc.translationsEnabledX, desc.translationsEnabledY, desc.rotationsEnabled, \n        // #endif\n        desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.softCcdPrediction, desc.ccdEnabled, desc.dominanceGroup, desc.additionalSolverIterations);\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n        const body = new _rigid_body__WEBPACK_IMPORTED_MODULE_2__.RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n        this.map.set(handle, body);\n        return body;\n    }\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    remove(handle, islands, colliders, impulseJoints, multibodyJoints) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => impulseJoints.unmap(handle));\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => multibodyJoints.unmap(handle));\n        // Remove the rigid-body.\n        this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        this.map.delete(handle);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBody(islands, f) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=rigid_body_set.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2R5bmFtaWNzL3JpZ2lkX2JvZHlfc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ0o7QUFDWTtBQUNQO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw4QkFBOEIsaURBQWU7QUFDN0MsdUJBQXVCLDZDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBUztBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUFTO0FBQzlCLHFCQUFxQiw4Q0FBVztBQUNoQyxvQkFBb0IsNENBQVM7QUFDN0IscUJBQXFCLDRDQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEMiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxcZHluYW1pY3NcXHJpZ2lkX2JvZHlfc2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJhd1JpZ2lkQm9keVNldCB9IGZyb20gXCIuLi9yYXdcIjtcbmltcG9ydCB7IENvYXJlbmEgfSBmcm9tIFwiLi4vY29hcmVuYVwiO1xuaW1wb3J0IHsgVmVjdG9yT3BzLCBSb3RhdGlvbk9wcyB9IGZyb20gXCIuLi9tYXRoXCI7XG5pbXBvcnQgeyBSaWdpZEJvZHksIH0gZnJvbSBcIi4vcmlnaWRfYm9keVwiO1xuLyoqXG4gKiBBIHNldCBvZiByaWdpZCBib2RpZXMgdGhhdCBjYW4gYmUgaGFuZGxlZCBieSBhIHBoeXNpY3MgcGlwZWxpbmUuXG4gKlxuICogVG8gYXZvaWQgbGVha2luZyBXQVNNIHJlc291cmNlcywgdGhpcyBNVVNUIGJlIGZyZWVkIG1hbnVhbGx5IHdpdGggYHJpZ2lkQm9keVNldC5mcmVlKClgXG4gKiBvbmNlIHlvdSBhcmUgZG9uZSB1c2luZyBpdCAoYW5kIGFsbCB0aGUgcmlnaWQtYm9kaWVzIGl0IGNyZWF0ZWQpLlxuICovXG5leHBvcnQgY2xhc3MgUmlnaWRCb2R5U2V0IHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXcgfHwgbmV3IFJhd1JpZ2lkQm9keVNldCgpO1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBDb2FyZW5hKCk7XG4gICAgICAgIC8vIGRlc2VyaWFsaXplXG4gICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICAgIHJhdy5mb3JFYWNoUmlnaWRCb2R5SGFuZGxlKChoYW5kbGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXQoaGFuZGxlLCBuZXcgUmlnaWRCb2R5KHJhdywgbnVsbCwgaGFuZGxlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBXQVNNIG1lbW9yeSBvY2N1cGllZCBieSB0aGlzIHJpZ2lkLWJvZHkgc2V0LlxuICAgICAqL1xuICAgIGZyZWUoKSB7XG4gICAgICAgIGlmICghIXRoaXMucmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5mcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghIXRoaXMubWFwKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QsIGRvIG5vdCBjYWxsIHRoaXMgZXhwbGljaXRseS5cbiAgICAgKi9cbiAgICBmaW5hbGl6ZURlc2VyaWFsaXphdGlvbihjb2xsaWRlclNldCkge1xuICAgICAgICB0aGlzLm1hcC5mb3JFYWNoKChyYikgPT4gcmIuZmluYWxpemVEZXNlcmlhbGl6YXRpb24oY29sbGlkZXJTZXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByaWdpZC1ib2R5IGFuZCByZXR1cm4gaXRzIGludGVnZXIgaGFuZGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlc2MgLSBUaGUgZGVzY3JpcHRpb24gb2YgdGhlIHJpZ2lkLWJvZHkgdG8gY3JlYXRlLlxuICAgICAqL1xuICAgIGNyZWF0ZVJpZ2lkQm9keShjb2xsaWRlclNldCwgZGVzYykge1xuICAgICAgICBsZXQgcmF3VHJhID0gVmVjdG9yT3BzLmludG9SYXcoZGVzYy50cmFuc2xhdGlvbik7XG4gICAgICAgIGxldCByYXdSb3QgPSBSb3RhdGlvbk9wcy5pbnRvUmF3KGRlc2Mucm90YXRpb24pO1xuICAgICAgICBsZXQgcmF3THYgPSBWZWN0b3JPcHMuaW50b1JhdyhkZXNjLmxpbnZlbCk7XG4gICAgICAgIGxldCByYXdDb20gPSBWZWN0b3JPcHMuaW50b1JhdyhkZXNjLmNlbnRlck9mTWFzcyk7XG4gICAgICAgIGxldCBoYW5kbGUgPSB0aGlzLnJhdy5jcmVhdGVSaWdpZEJvZHkoZGVzYy5lbmFibGVkLCByYXdUcmEsIHJhd1JvdCwgZGVzYy5ncmF2aXR5U2NhbGUsIGRlc2MubWFzcywgZGVzYy5tYXNzT25seSwgcmF3Q29tLCByYXdMdiwgXG4gICAgICAgIC8vICNpZiBESU0yXG4gICAgICAgIGRlc2MuYW5ndmVsLCBkZXNjLnByaW5jaXBhbEFuZ3VsYXJJbmVydGlhLCBkZXNjLnRyYW5zbGF0aW9uc0VuYWJsZWRYLCBkZXNjLnRyYW5zbGF0aW9uc0VuYWJsZWRZLCBkZXNjLnJvdGF0aW9uc0VuYWJsZWQsIFxuICAgICAgICAvLyAjZW5kaWZcbiAgICAgICAgZGVzYy5saW5lYXJEYW1waW5nLCBkZXNjLmFuZ3VsYXJEYW1waW5nLCBkZXNjLnN0YXR1cywgZGVzYy5jYW5TbGVlcCwgZGVzYy5zbGVlcGluZywgZGVzYy5zb2Z0Q2NkUHJlZGljdGlvbiwgZGVzYy5jY2RFbmFibGVkLCBkZXNjLmRvbWluYW5jZUdyb3VwLCBkZXNjLmFkZGl0aW9uYWxTb2x2ZXJJdGVyYXRpb25zKTtcbiAgICAgICAgcmF3VHJhLmZyZWUoKTtcbiAgICAgICAgcmF3Um90LmZyZWUoKTtcbiAgICAgICAgcmF3THYuZnJlZSgpO1xuICAgICAgICByYXdDb20uZnJlZSgpO1xuICAgICAgICBjb25zdCBib2R5ID0gbmV3IFJpZ2lkQm9keSh0aGlzLnJhdywgY29sbGlkZXJTZXQsIGhhbmRsZSk7XG4gICAgICAgIGJvZHkudXNlckRhdGEgPSBkZXNjLnVzZXJEYXRhO1xuICAgICAgICB0aGlzLm1hcC5zZXQoaGFuZGxlLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSByaWdpZC1ib2R5IGZyb20gdGhpcyBzZXQuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgYWxzbyByZW1vdmUgYWxsIHRoZSBjb2xsaWRlcnMgYW5kIGpvaW50cyBhdHRhY2hlZCB0byB0aGUgcmlnaWQtYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgaW50ZWdlciBoYW5kbGUgb2YgdGhlIHJpZ2lkLWJvZHkgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSBjb2xsaWRlcnMgLSBUaGUgc2V0IG9mIGNvbGxpZGVycyB0aGF0IG1heSBjb250YWluIGNvbGxpZGVycyBhdHRhY2hlZCB0byB0aGUgcmVtb3ZlZCByaWdpZC1ib2R5LlxuICAgICAqIEBwYXJhbSBpbXB1bHNlSm9pbnRzIC0gVGhlIHNldCBvZiBpbXB1bHNlIGpvaW50cyB0aGF0IG1heSBjb250YWluIGpvaW50cyBhdHRhY2hlZCB0byB0aGUgcmVtb3ZlZCByaWdpZC1ib2R5LlxuICAgICAqIEBwYXJhbSBtdWx0aWJvZHlKb2ludHMgLSBUaGUgc2V0IG9mIG11bHRpYm9keSBqb2ludHMgdGhhdCBtYXkgY29udGFpbiBqb2ludHMgYXR0YWNoZWQgdG8gdGhlIHJlbW92ZWQgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICByZW1vdmUoaGFuZGxlLCBpc2xhbmRzLCBjb2xsaWRlcnMsIGltcHVsc2VKb2ludHMsIG11bHRpYm9keUpvaW50cykge1xuICAgICAgICAvLyBVbm1hcCB0aGUgZW50aXRpZXMgdGhhdCB3aWxsIGJlIHJlbW92ZWQgYXV0b21hdGljYWxseSBiZWNhdXNlIG9mIHRoZSByaWdpZC1ib2R5IHJlbW92YWxzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmF3LnJiTnVtQ29sbGlkZXJzKGhhbmRsZSk7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29sbGlkZXJzLnVubWFwKHRoaXMucmF3LnJiQ29sbGlkZXIoaGFuZGxlLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaW1wdWxzZUpvaW50cy5mb3JFYWNoSm9pbnRIYW5kbGVBdHRhY2hlZFRvUmlnaWRCb2R5KGhhbmRsZSwgKGhhbmRsZSkgPT4gaW1wdWxzZUpvaW50cy51bm1hcChoYW5kbGUpKTtcbiAgICAgICAgbXVsdGlib2R5Sm9pbnRzLmZvckVhY2hKb2ludEhhbmRsZUF0dGFjaGVkVG9SaWdpZEJvZHkoaGFuZGxlLCAoaGFuZGxlKSA9PiBtdWx0aWJvZHlKb2ludHMudW5tYXAoaGFuZGxlKSk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmlnaWQtYm9keS5cbiAgICAgICAgdGhpcy5yYXcucmVtb3ZlKGhhbmRsZSwgaXNsYW5kcy5yYXcsIGNvbGxpZGVycy5yYXcsIGltcHVsc2VKb2ludHMucmF3LCBtdWx0aWJvZHlKb2ludHMucmF3KTtcbiAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgcmlnaWQtYm9kaWVzIG9uIHRoaXMgc2V0LlxuICAgICAqL1xuICAgIGxlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmxlbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgc2V0IGNvbnRhaW4gYSByaWdpZC1ib2R5IHdpdGggdGhlIGdpdmVuIGhhbmRsZT9cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgcmlnaWQtYm9keSBoYW5kbGUgdG8gY2hlY2suXG4gICAgICovXG4gICAgY29udGFpbnMoaGFuZGxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChoYW5kbGUpICE9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJpZ2lkLWJvZHkgd2l0aCB0aGUgZ2l2ZW4gaGFuZGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZSAtIFRoZSBoYW5kbGUgb2YgdGhlIHJpZ2lkLWJvZHkgdG8gcmV0cmlldmUuXG4gICAgICovXG4gICAgZ2V0KGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGNsb3N1cmUgdG8gZWFjaCByaWdpZC1ib2R5IGNvbnRhaW5lZCBieSB0aGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmIC0gVGhlIGNsb3N1cmUgdG8gYXBwbHkuXG4gICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIHRoaXMubWFwLmZvckVhY2goZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGNsb3N1cmUgdG8gZWFjaCBhY3RpdmUgcmlnaWQtYm9kaWVzIGNvbnRhaW5lZCBieSB0aGlzIHNldC5cbiAgICAgKlxuICAgICAqIEEgcmlnaWQtYm9keSBpcyBhY3RpdmUgaWYgaXQgaXMgbm90IHNsZWVwaW5nLCBpLmUuLCBpZiBpdCBtb3ZlZCByZWNlbnRseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmIC0gVGhlIGNsb3N1cmUgdG8gYXBwbHkuXG4gICAgICovXG4gICAgZm9yRWFjaEFjdGl2ZVJpZ2lkQm9keShpc2xhbmRzLCBmKSB7XG4gICAgICAgIGlzbGFuZHMuZm9yRWFjaEFjdGl2ZVJpZ2lkQm9keUhhbmRsZSgoaGFuZGxlKSA9PiB7XG4gICAgICAgICAgICBmKHRoaXMuZ2V0KGhhbmRsZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgcmlnaWQtYm9kaWVzIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgcmlnaWQtYm9kaWVzIGxpc3QuXG4gICAgICovXG4gICAgZ2V0QWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0QWxsKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlnaWRfYm9keV9zZXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/exports.js":
/*!********************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/exports.js ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ActiveCollisionTypes),\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.ActiveHooks),\n/* harmony export */   Ball: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.BroadPhase),\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.CCDSolver),\n/* harmony export */   Capsule: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Capsule),\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_5__.CharacterCollision),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.CoefficientCombineRule),\n/* harmony export */   Collider: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderSet),\n/* harmony export */   ColliderShapeCastHit: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderShapeCastHit),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Cuboid),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.EventQueue),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.FeatureType),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.FixedMultibodyJoint),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Heightfield),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointType),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_5__.KinematicCharacterController),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.MassPropsMode),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MultibodyJointSet),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.NarrowPhase),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.PhysicsPipeline),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Polyline),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.PrismaticMultibodyJoint),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.QueryPipeline),\n/* harmony export */   Ray: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Ray),\n/* harmony export */   RayColliderHit: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayColliderHit),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayColliderIntersection),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayIntersection),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RopeImpulseJoint),\n/* harmony export */   RotationOps: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Segment),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.SerializationPipeline),\n/* harmony export */   Shape: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Shape),\n/* harmony export */   ShapeCastHit: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeCastHit),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeContact),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeType),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.SolverFlags),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.SpringImpulseJoint),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.TempContactForceEvent),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TriMesh),\n/* harmony export */   TriMeshFlags: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TriMeshFlags),\n/* harmony export */   Triangle: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Triangle),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.UnitMultibodyJoint),\n/* harmony export */   Vector2: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.Vector2),\n/* harmony export */   VectorOps: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps),\n/* harmony export */   World: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.World),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dynamics */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/index.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/index.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/index.js\");\n/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./control */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/control/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _pipeline__WEBPACK_IMPORTED_MODULE_4__, _control__WEBPACK_IMPORTED_MODULE_5__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _pipeline__WEBPACK_IMPORTED_MODULE_4__, _control__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\nfunction version() {\n    return (0,_raw__WEBPACK_IMPORTED_MODULE_0__.version)();\n}\n\n\n\n\n\n\n//# sourceMappingURL=exports.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2V4cG9ydHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ2pDO0FBQ1AsV0FBVyw2Q0FBSTtBQUNmO0FBQ3VCO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDRztBQUMxQixtQyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxleHBvcnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gYXMgdmVycyB9IGZyb20gXCIuL3Jhd1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHZlcnMoKTtcbn1cbmV4cG9ydCAqIGZyb20gXCIuL21hdGhcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2R5bmFtaWNzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9nZW9tZXRyeVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcGlwZWxpbmVcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2luaXRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbnRyb2xcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cG9ydHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/exports.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/broad_phase.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/broad_phase.js ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BroadPhase: () => (/* binding */ BroadPhase)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nclass BroadPhase {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawBroadPhase();\n    }\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=broad_phase.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L2Jyb2FkX3BoYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw4QkFBOEIsK0NBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGdlb21ldHJ5XFxicm9hZF9waGFzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXdCcm9hZFBoYXNlIH0gZnJvbSBcIi4uL3Jhd1wiO1xuLyoqXG4gKiBUaGUgYnJvYWQtcGhhc2UgdXNlZCBmb3IgY29hcnNlIGNvbGxpc2lvbi1kZXRlY3Rpb24uXG4gKlxuICogVG8gYXZvaWQgbGVha2luZyBXQVNNIHJlc291cmNlcywgdGhpcyBNVVNUIGJlIGZyZWVkIG1hbnVhbGx5IHdpdGggYGJyb2FkUGhhc2UuZnJlZSgpYFxuICogb25jZSB5b3UgYXJlIGRvbmUgdXNpbmcgaXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBCcm9hZFBoYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXcgfHwgbmV3IFJhd0Jyb2FkUGhhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgV0FTTSBtZW1vcnkgb2NjdXBpZWQgYnkgdGhpcyBicm9hZC1waGFzZS5cbiAgICAgKi9cbiAgICBmcmVlKCkge1xuICAgICAgICBpZiAoISF0aGlzLnJhdykge1xuICAgICAgICAgICAgdGhpcy5yYXcuZnJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmF3ID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb2FkX3BoYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/broad_phase.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/collider.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/collider.js ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* binding */ ActiveCollisionTypes),\n/* harmony export */   Collider: () => (/* binding */ Collider),\n/* harmony export */   ColliderDesc: () => (/* binding */ ColliderDesc),\n/* harmony export */   MassPropsMode: () => (/* binding */ MassPropsMode)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamics */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/event_queue.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js\");\n/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/shape.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ray */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toi */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contact */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/contact.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_shape__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _point__WEBPACK_IMPORTED_MODULE_2__, _toi__WEBPACK_IMPORTED_MODULE_3__, _contact__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__, _pipeline__WEBPACK_IMPORTED_MODULE_7__]);\n([_shape__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _point__WEBPACK_IMPORTED_MODULE_2__, _toi__WEBPACK_IMPORTED_MODULE_3__, _contact__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__, _pipeline__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nvar ActiveCollisionTypes;\n(function (ActiveCollisionTypes) {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_DYNAMIC\"] = 1] = \"DYNAMIC_DYNAMIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_KINEMATIC\"] = 12] = \"DYNAMIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_FIXED\"] = 2] = \"DYNAMIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_KINEMATIC\"] = 52224] = \"KINEMATIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_FIXED\"] = 8704] = \"KINEMATIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"FIXED_FIXED\"] = 32] = \"FIXED_FIXED\";\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DEFAULT\"] = 15] = \"DEFAULT\";\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"ALL\"] = 60943] = \"ALL\";\n})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nclass Collider {\n    constructor(colliderSet, handle, parent, shape) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        if (this.handle != null) {\n            this._parent = bodies.get(this.colliderSet.raw.coParent(this.handle));\n        }\n    }\n    ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = _shape__WEBPACK_IMPORTED_MODULE_0__.Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n    /**\n     * The shape of this collider.\n     */\n    get shape() {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    isValid() {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.colliderSet.raw.coTranslation(this.handle));\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.fromRaw(this.colliderSet.raw.coRotation(this.handle));\n    }\n    /**\n     * Is this collider a sensor?\n     */\n    isSensor() {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    setSensor(isSensor) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The collider’s new shape.\n     */\n    setShape(shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body won’t be disabled automatically by this).\n     */\n    setEnabled(enabled) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this collider enabled?\n     */\n    isEnabled() {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    frictionCombineRule() {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    restitutionCombineRule() {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     */\n    contactSkin() {\n        return this.colliderSet.raw.coContactSkin(this.handle);\n    }\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     *\n     * @param thickness - The contact skin thickness.\n     */\n    setContactSkin(thickness) {\n        return this.colliderSet.raw.coSetContactSkin(this.handle, thickness);\n    }\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n    /**\n     * The events active for this collider.\n     */\n    activeEvents() {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n    /**\n     * Gets the collision types active for this collider.\n     */\n    activeCollisionTypes() {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    setContactForceEventThreshold(threshold) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, threshold);\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    contactForceEventThreshold() {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    setDensity(density) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    setMass(mass) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n    // #if DIM2\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia) {\n        let rawCom = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(centerOfMass);\n        this.colliderSet.raw.coSetMassProperties(this.handle, mass, rawCom, principalAngularInertia);\n        rawCom.free();\n    }\n    // #endif\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    setTranslation(tra) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y);\n        // #endif\n    }\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    setTranslationWrtParent(tra) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslationWrtParent(this.handle, tra.x, tra.y);\n        // #endif\n    }\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this collider.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    setRotation(angle) {\n        this.colliderSet.raw.coSetRotation(this.handle, angle);\n    }\n    /**\n     * Sets the rotation angle of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    setRotationWrtParent(angle) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, angle);\n    }\n    // #endif\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    shapeType() {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfExtents() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));\n    }\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    setHalfExtents(newHalfExtents) {\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    radius() {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    setRadius(newRadius) {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    roundRadius() {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    setRoundRadius(newBorderRadius) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfHeight() {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    setHalfHeight(newHalfheight) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    vertices() {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    indices() {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldHeights() {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldScale() {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(scale);\n    }\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    parent() {\n        return this._parent;\n    }\n    /**\n     * The friction coefficient of this collider.\n     */\n    friction() {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n    /**\n     * The restitution coefficient of this collider.\n     */\n    restitution() {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n    /**\n     * The density of this collider.\n     */\n    density() {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n    /**\n     * The mass of this collider.\n     */\n    mass() {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n    /**\n     * The volume of this collider.\n     */\n    volume() {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n    /**\n     * The collision groups of this collider.\n     */\n    collisionGroups() {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n    /**\n     * The solver groups of this collider.\n     */\n    solverGroups() {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    containsPoint(point) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(this.handle, rawPoint);\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    projectPoint(point, solid) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        let result = _point__WEBPACK_IMPORTED_MODULE_2__.PointProjection.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    intersectsRay(ray, maxToi) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(this.handle, rawOrig, rawDir, maxToi);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     */\n    castShape(collider1Vel, shape2, shape2Pos, shape2Rot, shape2Vel, targetDistance, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n        let result = _toi__WEBPACK_IMPORTED_MODULE_3__.ShapeCastHit.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, rawCollider1Vel, rawShape2, rawShape2Pos, rawShape2Rot, rawShape2Vel, targetDistance, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     */\n    castCollider(collider1Vel, collider2, collider2Vel, targetDistance, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(collider2Vel);\n        let result = _toi__WEBPACK_IMPORTED_MODULE_3__.ColliderShapeCastHit.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, rawCollider1Vel, collider2.handle, rawCollider2Vel, targetDistance, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n        return result;\n    }\n    intersectsShape(shape2, shapePos2, shapeRot2) {\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos2);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n        let result = this.colliderSet.raw.coIntersectsShape(this.handle, rawShape2, rawPos2, rawRot2);\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shape2, shape2Pos, shape2Rot, prediction) {\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n        let result = _contact__WEBPACK_IMPORTED_MODULE_4__.ShapeContact.fromRaw(this.colliderSet.raw.coContactShape(this.handle, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(collider2, prediction) {\n        let result = _contact__WEBPACK_IMPORTED_MODULE_4__.ShapeContact.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, collider2.handle, prediction));\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    castRay(ray, maxToi, solid) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(this.handle, rawOrig, rawDir, maxToi, solid);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    castRayAndGetNormal(ray, maxToi, solid) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let result = _ray__WEBPACK_IMPORTED_MODULE_5__.RayIntersection.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, rawOrig, rawDir, maxToi, solid));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n}\nvar MassPropsMode;\n(function (MassPropsMode) {\n    MassPropsMode[MassPropsMode[\"Density\"] = 0] = \"Density\";\n    MassPropsMode[MassPropsMode[\"Mass\"] = 1] = \"Mass\";\n    MassPropsMode[MassPropsMode[\"MassProps\"] = 2] = \"MassProps\";\n})(MassPropsMode || (MassPropsMode = {}));\nclass ColliderDesc {\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.identity();\n        this.translation = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 4294967295;\n        this.solverGroups = 4294967295;\n        this.frictionCombineRule = _dynamics__WEBPACK_IMPORTED_MODULE_6__.CoefficientCombineRule.Average;\n        this.restitutionCombineRule = _dynamics__WEBPACK_IMPORTED_MODULE_6__.CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = _pipeline__WEBPACK_IMPORTED_MODULE_7__.ActiveEvents.NONE;\n        this.activeHooks = _pipeline__WEBPACK_IMPORTED_MODULE_8__.ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        this.contactSkin = 0.0;\n        // #if DIM2\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n    }\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    static ball(radius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Ball(radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    static capsule(halfHeight, radius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    static segment(a, b) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    static triangle(a, b, c) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    static roundTriangle(a, b, c, borderRadius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    static polyline(vertices, indices) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    static trimesh(vertices, indices, flags) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.TriMesh(vertices, indices, flags);\n        return new ColliderDesc(shape);\n    }\n    // #if DIM2\n    /**\n     * Creates a new collider descriptor with a rectangular shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     */\n    static cuboid(hx, hy) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Cuboid(hx, hy);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    static roundCuboid(hx, hy, borderRadius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.RoundCuboid(hx, hy, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider description with a halfspace (infinite plane) shape.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    static halfspace(normal) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.HalfSpace(normal);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    static heightfield(heights, scale) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.Heightfield(heights, scale);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    static convexHull(points) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.ConvexPolygon(points, false);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    static convexPolyline(vertices) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.ConvexPolygon(vertices, true);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor. A\n     * border is added to that convex polygon to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polygon.\n     */\n    static roundConvexHull(points, borderRadius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.RoundConvexPolygon(points, borderRadius, false);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    static roundConvexPolyline(vertices, borderRadius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_0__.RoundConvexPolygon(vertices, borderRadius, true);\n        return new ColliderDesc(shape);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setTranslation(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setRotation(rot) {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    setSensor(sensor) {\n        this.isSensor = sensor;\n        return this;\n    }\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled − If set to `false` the collider will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the contact skin of the collider.\n     *\n     * The contact skin acts as if the collider was enlarged with a skin of width `skin_thickness`\n     * around it, keeping objects further apart when colliding.\n     *\n     * A non-zero contact skin can increase performance, and in some cases, stability. However\n     * it creates a small gap between colliding object (equal to the sum of their skin). If the\n     * skin is sufficiently small, this might not be visually significant or can be hidden by the\n     * rendering assets.\n     */\n    setContactSkin(thickness) {\n        this.contactSkin = thickness;\n        return this;\n    }\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the collider’s shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    setDensity(density) {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the collider’s shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    setMass(mass) {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass − The mass of the collider to create.\n     * @param centerOfMass − The center-of-mass of the collider to create.\n     * @param principalAngularInertia − The principal angular inertia of the collider to create.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia) {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.restitution = restitution;\n        return this;\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.friction = friction;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.collisionGroups = groups;\n        return this;\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.solverGroups = groups;\n        return this;\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    setContactForceEventThreshold(threshold) {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n//# sourceMappingURL=collider.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L2NvbGxpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDSztBQUNFO0FBS3RDO0FBQ3NCO0FBQ0U7QUFDaUI7QUFDbEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5Q0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQVM7QUFDaEMscUJBQXFCLG1EQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0IscUJBQXFCLDRDQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRDQUFTO0FBQ3ZDLDJCQUEyQiw0Q0FBUztBQUNwQywyQkFBMkIsOENBQVc7QUFDdEMsMkJBQTJCLDRDQUFTO0FBQ3BDO0FBQ0EscUJBQXFCLDhDQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRDQUFTO0FBQ3ZDLDhCQUE4Qiw0Q0FBUztBQUN2QyxxQkFBcUIsc0RBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0Isc0JBQXNCLDhDQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0Isc0JBQXNCLDhDQUFXO0FBQ2pDO0FBQ0EscUJBQXFCLGtEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBUztBQUMvQixxQkFBcUIsNENBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBUztBQUMvQixxQkFBcUIsNENBQVM7QUFDOUIscUJBQXFCLGlEQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQVc7QUFDbkMsMkJBQTJCLDRDQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2REFBc0I7QUFDekQsc0NBQXNDLDZEQUFzQjtBQUM1RDtBQUNBLDRCQUE0QixtREFBWTtBQUN4QywyQkFBMkIsa0RBQVc7QUFDdEM7QUFDQSw0QkFBNEIsNENBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyQ0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0Q0FBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaURBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtDQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpREFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaURBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzREFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0Q0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGdlb21ldHJ5XFxjb2xsaWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSb3RhdGlvbk9wcywgVmVjdG9yT3BzIH0gZnJvbSBcIi4uL21hdGhcIjtcbmltcG9ydCB7IENvZWZmaWNpZW50Q29tYmluZVJ1bGUsIH0gZnJvbSBcIi4uL2R5bmFtaWNzXCI7XG5pbXBvcnQgeyBBY3RpdmVIb29rcywgQWN0aXZlRXZlbnRzIH0gZnJvbSBcIi4uL3BpcGVsaW5lXCI7XG5pbXBvcnQgeyBTaGFwZSwgQ3Vib2lkLCBCYWxsLCBDYXBzdWxlLCBUcmlNZXNoLCBQb2x5bGluZSwgSGVpZ2h0ZmllbGQsIFNlZ21lbnQsIFRyaWFuZ2xlLCBSb3VuZFRyaWFuZ2xlLCBSb3VuZEN1Ym9pZCwgSGFsZlNwYWNlLCBcbi8vICNpZiBESU0yXG5Db252ZXhQb2x5Z29uLCBSb3VuZENvbnZleFBvbHlnb24sXG4vLyAjZW5kaWZcbiB9IGZyb20gXCIuL3NoYXBlXCI7XG5pbXBvcnQgeyBSYXlJbnRlcnNlY3Rpb24gfSBmcm9tIFwiLi9yYXlcIjtcbmltcG9ydCB7IFBvaW50UHJvamVjdGlvbiB9IGZyb20gXCIuL3BvaW50XCI7XG5pbXBvcnQgeyBDb2xsaWRlclNoYXBlQ2FzdEhpdCwgU2hhcGVDYXN0SGl0IH0gZnJvbSBcIi4vdG9pXCI7XG5pbXBvcnQgeyBTaGFwZUNvbnRhY3QgfSBmcm9tIFwiLi9jb250YWN0XCI7XG4vKipcbiAqIEZsYWdzIGFmZmVjdGluZyB3aGV0aGVyIGNvbGxpc2lvbi1kZXRlY3Rpb24gaGFwcGVucyBiZXR3ZWVuIHR3byBjb2xsaWRlcnNcbiAqIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiByaWdpZC1ib2RpZXMgdGhleSBhcmUgYXR0YWNoZWQgdG8uXG4gKi9cbmV4cG9ydCB2YXIgQWN0aXZlQ29sbGlzaW9uVHlwZXM7XG4oZnVuY3Rpb24gKEFjdGl2ZUNvbGxpc2lvblR5cGVzKSB7XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGNvbGxpc2lvbi1kZXRlY3Rpb24gYmV0d2VlbiBhIGNvbGxpZGVyIGF0dGFjaGVkIHRvIGEgZHluYW1pYyBib2R5XG4gICAgICogYW5kIGFub3RoZXIgY29sbGlkZXIgYXR0YWNoZWQgdG8gYSBkeW5hbWljIGJvZHkuXG4gICAgICovXG4gICAgQWN0aXZlQ29sbGlzaW9uVHlwZXNbQWN0aXZlQ29sbGlzaW9uVHlwZXNbXCJEWU5BTUlDX0RZTkFNSUNcIl0gPSAxXSA9IFwiRFlOQU1JQ19EWU5BTUlDXCI7XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGNvbGxpc2lvbi1kZXRlY3Rpb24gYmV0d2VlbiBhIGNvbGxpZGVyIGF0dGFjaGVkIHRvIGEgZHluYW1pYyBib2R5XG4gICAgICogYW5kIGFub3RoZXIgY29sbGlkZXIgYXR0YWNoZWQgdG8gYSBraW5lbWF0aWMgYm9keS5cbiAgICAgKi9cbiAgICBBY3RpdmVDb2xsaXNpb25UeXBlc1tBY3RpdmVDb2xsaXNpb25UeXBlc1tcIkRZTkFNSUNfS0lORU1BVElDXCJdID0gMTJdID0gXCJEWU5BTUlDX0tJTkVNQVRJQ1wiO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBjb2xsaXNpb24tZGV0ZWN0aW9uIGJldHdlZW4gYSBjb2xsaWRlciBhdHRhY2hlZCB0byBhIGR5bmFtaWMgYm9keVxuICAgICAqIGFuZCBhbm90aGVyIGNvbGxpZGVyIGF0dGFjaGVkIHRvIGEgZml4ZWQgYm9keSAob3Igbm90IGF0dGFjaGVkIHRvIGFueSBib2R5KS5cbiAgICAgKi9cbiAgICBBY3RpdmVDb2xsaXNpb25UeXBlc1tBY3RpdmVDb2xsaXNpb25UeXBlc1tcIkRZTkFNSUNfRklYRURcIl0gPSAyXSA9IFwiRFlOQU1JQ19GSVhFRFwiO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBjb2xsaXNpb24tZGV0ZWN0aW9uIGJldHdlZW4gYSBjb2xsaWRlciBhdHRhY2hlZCB0byBhIGtpbmVtYXRpYyBib2R5XG4gICAgICogYW5kIGFub3RoZXIgY29sbGlkZXIgYXR0YWNoZWQgdG8gYSBraW5lbWF0aWMgYm9keS5cbiAgICAgKi9cbiAgICBBY3RpdmVDb2xsaXNpb25UeXBlc1tBY3RpdmVDb2xsaXNpb25UeXBlc1tcIktJTkVNQVRJQ19LSU5FTUFUSUNcIl0gPSA1MjIyNF0gPSBcIktJTkVNQVRJQ19LSU5FTUFUSUNcIjtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgY29sbGlzaW9uLWRldGVjdGlvbiBiZXR3ZWVuIGEgY29sbGlkZXIgYXR0YWNoZWQgdG8gYSBraW5lbWF0aWMgYm9keVxuICAgICAqIGFuZCBhbm90aGVyIGNvbGxpZGVyIGF0dGFjaGVkIHRvIGEgZml4ZWQgYm9keSAob3Igbm90IGF0dGFjaGVkIHRvIGFueSBib2R5KS5cbiAgICAgKi9cbiAgICBBY3RpdmVDb2xsaXNpb25UeXBlc1tBY3RpdmVDb2xsaXNpb25UeXBlc1tcIktJTkVNQVRJQ19GSVhFRFwiXSA9IDg3MDRdID0gXCJLSU5FTUFUSUNfRklYRURcIjtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgY29sbGlzaW9uLWRldGVjdGlvbiBiZXR3ZWVuIGEgY29sbGlkZXIgYXR0YWNoZWQgdG8gYSBmaXhlZCBib2R5IChvclxuICAgICAqIG5vdCBhdHRhY2hlZCB0byBhbnkgYm9keSkgYW5kIGFub3RoZXIgY29sbGlkZXIgYXR0YWNoZWQgdG8gYSBmaXhlZCBib2R5IChvclxuICAgICAqIG5vdCBhdHRhY2hlZCB0byBhbnkgYm9keSkuXG4gICAgICovXG4gICAgQWN0aXZlQ29sbGlzaW9uVHlwZXNbQWN0aXZlQ29sbGlzaW9uVHlwZXNbXCJGSVhFRF9GSVhFRFwiXSA9IDMyXSA9IFwiRklYRURfRklYRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBhY3RpdmUgY29sbGlzaW9uIHR5cGVzLCBlbmFibGluZyBjb2xsaXNpb25zIGJldHdlZW4gYSBkeW5hbWljIGJvZHlcbiAgICAgKiBhbmQgYW5vdGhlciBib2R5IG9mIGFueSB0eXBlLCBidXQgbm90IGVuYWJsaW5nIGNvbGxpc2lvbnMgYmV0d2VlbiB0d28gbm9uLWR5bmFtaWMgYm9kaWVzLlxuICAgICAqL1xuICAgIEFjdGl2ZUNvbGxpc2lvblR5cGVzW0FjdGl2ZUNvbGxpc2lvblR5cGVzW1wiREVGQVVMVFwiXSA9IDE1XSA9IFwiREVGQVVMVFwiO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBjb2xsaXNpb25zIGJldHdlZW4gYW55IGtpbmQgb2YgcmlnaWQtYm9kaWVzIChpbmNsdWRpbmcgYmV0d2VlbiB0d28gbm9uLWR5bmFtaWMgYm9kaWVzKS5cbiAgICAgKi9cbiAgICBBY3RpdmVDb2xsaXNpb25UeXBlc1tBY3RpdmVDb2xsaXNpb25UeXBlc1tcIkFMTFwiXSA9IDYwOTQzXSA9IFwiQUxMXCI7XG59KShBY3RpdmVDb2xsaXNpb25UeXBlcyB8fCAoQWN0aXZlQ29sbGlzaW9uVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIGdlb21ldHJpYyBlbnRpdHkgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSBib2R5IHNvIGl0IGNhbiBiZSBhZmZlY3RlZFxuICogYnkgY29udGFjdHMgYW5kIHByb3hpbWl0eSBxdWVyaWVzLlxuICovXG5leHBvcnQgY2xhc3MgQ29sbGlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbGxpZGVyU2V0LCBoYW5kbGUsIHBhcmVudCwgc2hhcGUpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldCA9IGNvbGxpZGVyU2V0O1xuICAgICAgICB0aGlzLmhhbmRsZSA9IGhhbmRsZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9zaGFwZSA9IHNoYXBlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZmluYWxpemVEZXNlcmlhbGl6YXRpb24oYm9kaWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBib2RpZXMuZ2V0KHRoaXMuY29sbGlkZXJTZXQucmF3LmNvUGFyZW50KHRoaXMuaGFuZGxlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5zdXJlU2hhcGVJc0NhY2hlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaGFwZSlcbiAgICAgICAgICAgIHRoaXMuX3NoYXBlID0gU2hhcGUuZnJvbVJhdyh0aGlzLmNvbGxpZGVyU2V0LnJhdywgdGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2hhcGUgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlU2hhcGVJc0NhY2hlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIGNvbGxpZGVyIGlzIHN0aWxsIHZhbGlkIChpLmUuIHRoYXQgaXQgaGFzXG4gICAgICogbm90IGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBjb2xsaWRlciBzZXQgeWV0KS5cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlclNldC5yYXcuY29udGFpbnModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQtc3BhY2UgdHJhbnNsYXRpb24gb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqL1xuICAgIHRyYW5zbGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gVmVjdG9yT3BzLmZyb21SYXcodGhpcy5jb2xsaWRlclNldC5yYXcuY29UcmFuc2xhdGlvbih0aGlzLmhhbmRsZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgd29ybGQtc3BhY2Ugb3JpZW50YXRpb24gb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICAqL1xuICAgIHJvdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gUm90YXRpb25PcHMuZnJvbVJhdyh0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1JvdGF0aW9uKHRoaXMuaGFuZGxlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgY29sbGlkZXIgYSBzZW5zb3I/XG4gICAgICovXG4gICAgaXNTZW5zb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0lzU2Vuc29yKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbGxpZGVyIGlzIGEgc2Vuc29yLlxuICAgICAqIEBwYXJhbSBpc1NlbnNvciAtIElmIGB0cnVlYCwgdGhlIGNvbGxpZGVyIHdpbGwgYmUgYSBzZW5zb3IuXG4gICAgICovXG4gICAgc2V0U2Vuc29yKGlzU2Vuc29yKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvU2V0U2Vuc29yKHRoaXMuaGFuZGxlLCBpc1NlbnNvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG5ldyBzaGFwZSBvZiB0aGUgY29sbGlkZXIuXG4gICAgICogQHBhcmFtIHNoYXBlIC0gVGhlIGNvbGxpZGVy4oCZcyBuZXcgc2hhcGUuXG4gICAgICovXG4gICAgc2V0U2hhcGUoc2hhcGUpIHtcbiAgICAgICAgbGV0IHJhd1NoYXBlID0gc2hhcGUuaW50b1JhdygpO1xuICAgICAgICB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1NldFNoYXBlKHRoaXMuaGFuZGxlLCByYXdTaGFwZSk7XG4gICAgICAgIHJhd1NoYXBlLmZyZWUoKTtcbiAgICAgICAgdGhpcy5fc2hhcGUgPSBzaGFwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoaXMgY29sbGlkZXIgaXMgZW5hYmxlZCBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5hYmxlZCAtIFNldCB0byBgZmFsc2VgIHRvIGRpc2FibGUgdGhpcyBjb2xsaWRlciAoaXRzIHBhcmVudCByaWdpZC1ib2R5IHdvbuKAmXQgYmUgZGlzYWJsZWQgYXV0b21hdGljYWxseSBieSB0aGlzKS5cbiAgICAgKi9cbiAgICBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRFbmFibGVkKHRoaXMuaGFuZGxlLCBlbmFibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBjb2xsaWRlciBlbmFibGVkP1xuICAgICAqL1xuICAgIGlzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvSXNFbmFibGVkKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVzdGl0dXRpb24gY29lZmZpY2llbnQgb2YgdGhlIGNvbGxpZGVyIHRvIGJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzdGl0dXRpb24gLSBUaGUgcmVzdGl0dXRpb24gY29lZmZpY2llbnQgaW4gYFswLCAxXWAuIEEgdmFsdWUgb2YgMCAodGhlIGRlZmF1bHQpIG1lYW5zIG5vIGJvdW5jaW5nIGJlaGF2aW9yXG4gICAgICogICAgICAgICAgICAgICAgICAgd2hpbGUgMSBtZWFucyBwZXJmZWN0IGJvdW5jaW5nICh0aG91Z2ggZW5lcmd5IG1heSBzdGlsbCBiZSBsb3N0IGR1ZSB0byBudW1lcmljYWwgZXJyb3JzIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzIHNvbHZlcikuXG4gICAgICovXG4gICAgc2V0UmVzdGl0dXRpb24ocmVzdGl0dXRpb24pIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRSZXN0aXR1dGlvbih0aGlzLmhhbmRsZSwgcmVzdGl0dXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmcmljdGlvbiBjb2VmZmljaWVudCBvZiB0aGUgY29sbGlkZXIgdG8gYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcmljdGlvbiAtIFRoZSBmcmljdGlvbiBjb2VmZmljaWVudC4gTXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDAuIFRoaXMgaXMgZ2VuZXJhbGx5IHNtYWxsZXIgdGhhbiAxLiBUaGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICBoaWdoZXIgdGhlIGNvZWZmaWNpZW50LCB0aGUgc3Ryb25nZXIgZnJpY3Rpb24gZm9yY2VzIHdpbGwgYmUgZm9yIGNvbnRhY3RzIHdpdGggdGhlIGNvbGxpZGVyXG4gICAgICogICAgICAgICAgICAgICAgICAgYmVpbmcgYnVpbHQuXG4gICAgICovXG4gICAgc2V0RnJpY3Rpb24oZnJpY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRGcmljdGlvbih0aGlzLmhhbmRsZSwgZnJpY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBydWxlIHVzZWQgdG8gY29tYmluZSB0aGUgZnJpY3Rpb24gY29lZmZpY2llbnRzIG9mIHR3byBjb2xsaWRlcnNcbiAgICAgKiBjb2xsaWRlcnMgaW52b2x2ZWQgaW4gYSBjb250YWN0LlxuICAgICAqL1xuICAgIGZyaWN0aW9uQ29tYmluZVJ1bGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0ZyaWN0aW9uQ29tYmluZVJ1bGUodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydWxlIHVzZWQgdG8gY29tYmluZSB0aGUgZnJpY3Rpb24gY29lZmZpY2llbnRzIG9mIHR3byBjb2xsaWRlcnNcbiAgICAgKiBjb2xsaWRlcnMgaW52b2x2ZWQgaW4gYSBjb250YWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bGUg4oiSIFRoZSBjb21iaW5lIHJ1bGUgdG8gYXBwbHkuXG4gICAgICovXG4gICAgc2V0RnJpY3Rpb25Db21iaW5lUnVsZShydWxlKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvU2V0RnJpY3Rpb25Db21iaW5lUnVsZSh0aGlzLmhhbmRsZSwgcnVsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJ1bGUgdXNlZCB0byBjb21iaW5lIHRoZSByZXN0aXR1dGlvbiBjb2VmZmljaWVudHMgb2YgdHdvIGNvbGxpZGVyc1xuICAgICAqIGNvbGxpZGVycyBpbnZvbHZlZCBpbiBhIGNvbnRhY3QuXG4gICAgICovXG4gICAgcmVzdGl0dXRpb25Db21iaW5lUnVsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvUmVzdGl0dXRpb25Db21iaW5lUnVsZSh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJ1bGUgdXNlZCB0byBjb21iaW5lIHRoZSByZXN0aXR1dGlvbiBjb2VmZmljaWVudHMgb2YgdHdvIGNvbGxpZGVyc1xuICAgICAqIGNvbGxpZGVycyBpbnZvbHZlZCBpbiBhIGNvbnRhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcnVsZSDiiJIgVGhlIGNvbWJpbmUgcnVsZSB0byBhcHBseS5cbiAgICAgKi9cbiAgICBzZXRSZXN0aXR1dGlvbkNvbWJpbmVSdWxlKHJ1bGUpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRSZXN0aXR1dGlvbkNvbWJpbmVSdWxlKHRoaXMuaGFuZGxlLCBydWxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29sbGlzaW9uIGdyb3VwcyB1c2VkIGJ5IHRoaXMgY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBUd28gY29sbGlkZXJzIHdpbGwgaW50ZXJhY3QgaWZmLiB0aGVpciBjb2xsaXNpb24gZ3JvdXBzIGFyZSBjb21wYXRpYmxlLlxuICAgICAqIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvZiBgSW50ZXJhY3Rpb25Hcm91cHNgIGZvciBkZXRhaWxzIG9uIHRlaCB1c2VkIGJpdCBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFRoZSBjb2xsaXNpb24gZ3JvdXBzIHVzZWQgZm9yIHRoZSBjb2xsaWRlciBiZWluZyBidWlsdC5cbiAgICAgKi9cbiAgICBzZXRDb2xsaXNpb25Hcm91cHMoZ3JvdXBzKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvU2V0Q29sbGlzaW9uR3JvdXBzKHRoaXMuaGFuZGxlLCBncm91cHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzb2x2ZXIgZ3JvdXBzIHVzZWQgYnkgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIEZvcmNlcyBiZXR3ZWVuIHR3byBjb2xsaWRlcnMgaW4gY29udGFjdCB3aWxsIGJlIGNvbXB1dGVkIGlmZiB0aGVpciBzb2x2ZXJcbiAgICAgKiBncm91cHMgYXJlIGNvbXBhdGlibGUuXG4gICAgICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIGBJbnRlcmFjdGlvbkdyb3Vwc2AgZm9yIGRldGFpbHMgb24gdGhlIHVzZWQgYml0IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JvdXBzIC0gVGhlIHNvbHZlciBncm91cHMgdXNlZCBmb3IgdGhlIGNvbGxpZGVyIGJlaW5nIGJ1aWx0LlxuICAgICAqL1xuICAgIHNldFNvbHZlckdyb3Vwcyhncm91cHMpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRTb2x2ZXJHcm91cHModGhpcy5oYW5kbGUsIGdyb3Vwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbnRhY3Qgc2tpbiBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvZiBgQ29sbGlkZXJEZXNjLnNldENvbnRhY3RTa2luYCBmb3IgYWRkaXRpb25hbCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGNvbnRhY3RTa2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlclNldC5yYXcuY29Db250YWN0U2tpbih0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbnRhY3Qgc2tpbiBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvZiBgQ29sbGlkZXJEZXNjLnNldENvbnRhY3RTa2luYCBmb3IgYWRkaXRpb25hbCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRoaWNrbmVzcyAtIFRoZSBjb250YWN0IHNraW4gdGhpY2tuZXNzLlxuICAgICAqL1xuICAgIHNldENvbnRhY3RTa2luKHRoaWNrbmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRDb250YWN0U2tpbih0aGlzLmhhbmRsZSwgdGhpY2tuZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwaHlzaWNzIGhvb2tzIGFjdGl2ZSBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBhY3RpdmVIb29rcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvQWN0aXZlSG9va3ModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBoeXNpY3MgaG9va3MgYWN0aXZlIGZvciB0aGlzIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgdG8gZW5hYmxlIGN1c3RvbSBmaWx0ZXJpbmcgcnVsZXMgZm9yIGNvbnRhY3QvaW50ZXJzZWNzdGlvbiBwYWlycyBpbnZvbHZpbmcgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3RpdmVIb29rcyAtIFRoZSBob29rcyBhY3RpdmUgZm9yIGNvbnRhY3QvaW50ZXJzZWN0aW9uIHBhaXJzIGludm9sdmluZyB0aGlzIGNvbGxpZGVyLlxuICAgICAqL1xuICAgIHNldEFjdGl2ZUhvb2tzKGFjdGl2ZUhvb2tzKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvU2V0QWN0aXZlSG9va3ModGhpcy5oYW5kbGUsIGFjdGl2ZUhvb2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50cyBhY3RpdmUgZm9yIHRoaXMgY29sbGlkZXIuXG4gICAgICovXG4gICAgYWN0aXZlRXZlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlclNldC5yYXcuY29BY3RpdmVFdmVudHModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGV2ZW50cyBhY3RpdmUgZm9yIHRoaXMgY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB0byBlbmFibGUgY29udGFjdCBhbmQvb3IgaW50ZXJzZWN0aW9uIGV2ZW50IHJlcG9ydGluZyBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3RpdmVFdmVudHMgLSBUaGUgZXZlbnRzIGFjdGl2ZSBmb3IgY29udGFjdC9pbnRlcnNlY3Rpb24gcGFpcnMgaW52b2x2aW5nIHRoaXMgY29sbGlkZXIuXG4gICAgICovXG4gICAgc2V0QWN0aXZlRXZlbnRzKGFjdGl2ZUV2ZW50cykge1xuICAgICAgICB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1NldEFjdGl2ZUV2ZW50cyh0aGlzLmhhbmRsZSwgYWN0aXZlRXZlbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29sbGlzaW9uIHR5cGVzIGFjdGl2ZSBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBhY3RpdmVDb2xsaXNpb25UeXBlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvQWN0aXZlQ29sbGlzaW9uVHlwZXModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0b3RhbCBmb3JjZSBtYWduaXR1ZGUgYmV5b25kIHdoaWNoIGEgY29udGFjdCBmb3JjZSBldmVudCBjYW4gYmUgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aHJlc2hvbGQgLSBUaGUgbmV3IGZvcmNlIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBzZXRDb250YWN0Rm9yY2VFdmVudFRocmVzaG9sZCh0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvU2V0Q29udGFjdEZvcmNlRXZlbnRUaHJlc2hvbGQodGhpcy5oYW5kbGUsIHRocmVzaG9sZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBmb3JjZSBtYWduaXR1ZGUgYmV5b25kIHdoaWNoIGEgY29udGFjdCBmb3JjZSBldmVudCBjYW4gYmUgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBjb250YWN0Rm9yY2VFdmVudFRocmVzaG9sZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvQ29udGFjdEZvcmNlRXZlbnRUaHJlc2hvbGQodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbGxpc2lvbiB0eXBlcyBhY3RpdmUgZm9yIHRoaXMgY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aXZlQ29sbGlzaW9uVHlwZXMgLSBUaGUgaG9va3MgYWN0aXZlIGZvciBjb250YWN0L2ludGVyc2VjdGlvbiBwYWlycyBpbnZvbHZpbmcgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBzZXRBY3RpdmVDb2xsaXNpb25UeXBlcyhhY3RpdmVDb2xsaXNpb25UeXBlcykge1xuICAgICAgICB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1NldEFjdGl2ZUNvbGxpc2lvblR5cGVzKHRoaXMuaGFuZGxlLCBhY3RpdmVDb2xsaXNpb25UeXBlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVuaWZvcm0gZGVuc2l0eSBvZiB0aGlzIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIG92ZXJyaWRlIGFueSBwcmV2aW91cyBtYXNzLXByb3BlcnRpZXMgc2V0IGJ5IGB0aGlzLnNldERlbnNpdHlgLFxuICAgICAqIGB0aGlzLnNldE1hc3NgLCBgdGhpcy5zZXRNYXNzUHJvcGVydGllc2AsIGBDb2xsaWRlckRlc2MuZGVuc2l0eWAsXG4gICAgICogYENvbGxpZGVyRGVzYy5tYXNzYCwgb3IgYENvbGxpZGVyRGVzYy5tYXNzUHJvcGVydGllc2AgZm9yIHRoaXMgY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBUaGUgbWFzcyBhbmQgYW5ndWxhciBpbmVydGlhIG9mIHRoaXMgY29sbGlkZXIgd2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIGl0c1xuICAgICAqIHNoYXBlLlxuICAgICAqL1xuICAgIHNldERlbnNpdHkoZGVuc2l0eSkge1xuICAgICAgICB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1NldERlbnNpdHkodGhpcy5oYW5kbGUsIGRlbnNpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXNzIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgb3ZlcnJpZGUgYW55IHByZXZpb3VzIG1hc3MtcHJvcGVydGllcyBzZXQgYnkgYHRoaXMuc2V0RGVuc2l0eWAsXG4gICAgICogYHRoaXMuc2V0TWFzc2AsIGB0aGlzLnNldE1hc3NQcm9wZXJ0aWVzYCwgYENvbGxpZGVyRGVzYy5kZW5zaXR5YCxcbiAgICAgKiBgQ29sbGlkZXJEZXNjLm1hc3NgLCBvciBgQ29sbGlkZXJEZXNjLm1hc3NQcm9wZXJ0aWVzYCBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIFRoZSBhbmd1bGFyIGluZXJ0aWEgb2YgdGhpcyBjb2xsaWRlciB3aWxsIGJlIGNvbXB1dGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIHNoYXBlXG4gICAgICogYW5kIHRoaXMgbWFzcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRNYXNzKG1hc3MpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRNYXNzKHRoaXMuaGFuZGxlLCBtYXNzKTtcbiAgICB9XG4gICAgLy8gI2lmIERJTTJcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXNzIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgb3ZlcnJpZGUgYW55IHByZXZpb3VzIG1hc3MtcHJvcGVydGllcyBzZXQgYnkgYHRoaXMuc2V0RGVuc2l0eWAsXG4gICAgICogYHRoaXMuc2V0TWFzc2AsIGB0aGlzLnNldE1hc3NQcm9wZXJ0aWVzYCwgYENvbGxpZGVyRGVzYy5kZW5zaXR5YCxcbiAgICAgKiBgQ29sbGlkZXJEZXNjLm1hc3NgLCBvciBgQ29sbGlkZXJEZXNjLm1hc3NQcm9wZXJ0aWVzYCBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBzZXRNYXNzUHJvcGVydGllcyhtYXNzLCBjZW50ZXJPZk1hc3MsIHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhKSB7XG4gICAgICAgIGxldCByYXdDb20gPSBWZWN0b3JPcHMuaW50b1JhdyhjZW50ZXJPZk1hc3MpO1xuICAgICAgICB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1NldE1hc3NQcm9wZXJ0aWVzKHRoaXMuaGFuZGxlLCBtYXNzLCByYXdDb20sIHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhKTtcbiAgICAgICAgcmF3Q29tLmZyZWUoKTtcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHJhbnNsYXRpb24gb2YgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmEgLSBUaGUgd29ybGQtc3BhY2UgcG9zaXRpb24gb2YgdGhlIGNvbGxpZGVyLlxuICAgICAqL1xuICAgIHNldFRyYW5zbGF0aW9uKHRyYSkge1xuICAgICAgICAvLyAjaWYgRElNMlxuICAgICAgICB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1NldFRyYW5zbGF0aW9uKHRoaXMuaGFuZGxlLCB0cmEueCwgdHJhLnkpO1xuICAgICAgICAvLyAjZW5kaWZcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdHJhbnNsYXRpb24gb2YgdGhpcyBjb2xsaWRlciByZWxhdGl2ZSB0byBpdHMgcGFyZW50IHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhpcyBjb2xsaWRlciBpc24ndCBhdHRhY2hlZCB0byBhIHJpZ2lkLWJvZHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhIC0gVGhlIG5ldyB0cmFuc2xhdGlvbiBvZiB0aGUgY29sbGlkZXIgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cbiAgICAgKi9cbiAgICBzZXRUcmFuc2xhdGlvbldydFBhcmVudCh0cmEpIHtcbiAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRUcmFuc2xhdGlvbldydFBhcmVudCh0aGlzLmhhbmRsZSwgdHJhLngsIHRyYS55KTtcbiAgICAgICAgLy8gI2VuZGlmXG4gICAgfVxuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcm90YXRpb24gYW5nbGUgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbmdsZSAtIFRoZSByb3RhdGlvbiBhbmdsZSwgaW4gcmFkaWFucy5cbiAgICAgKi9cbiAgICBzZXRSb3RhdGlvbihhbmdsZSkge1xuICAgICAgICB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1NldFJvdGF0aW9uKHRoaXMuaGFuZGxlLCBhbmdsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJvdGF0aW9uIGFuZ2xlIG9mIHRoaXMgY29sbGlkZXIgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogRG9lcyBub3RoaW5nIGlmIHRoaXMgY29sbGlkZXIgaXNuJ3QgYXR0YWNoZWQgdG8gYSByaWdpZC1ib2R5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFuZ2xlIC0gVGhlIHJvdGF0aW9uIGFuZ2xlLCBpbiByYWRpYW5zLlxuICAgICAqL1xuICAgIHNldFJvdGF0aW9uV3J0UGFyZW50KGFuZ2xlKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvU2V0Um90YXRpb25XcnRQYXJlbnQodGhpcy5oYW5kbGUsIGFuZ2xlKTtcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIHNoYXBlIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBmaWVsZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgcGxlYXNlIGFjY2VzcyB0aGlzIGZpZWxkIG9uIGBzaGFwZWAgbWVtYmVyIGluc3RlYWQuXG4gICAgICovXG4gICAgc2hhcGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlclNldC5yYXcuY29TaGFwZVR5cGUodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaGFsZi1leHRlbnRzIG9mIHRoaXMgY29sbGlkZXIgaWYgaXQgaXMgYSBjdWJvaWQgc2hhcGUuXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBmaWVsZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgcGxlYXNlIGFjY2VzcyB0aGlzIGZpZWxkIG9uIGBzaGFwZWAgbWVtYmVyIGluc3RlYWQuXG4gICAgICovXG4gICAgaGFsZkV4dGVudHMoKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyh0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0hhbGZFeHRlbnRzKHRoaXMuaGFuZGxlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhbGYtZXh0ZW50cyBvZiB0aGlzIGNvbGxpZGVyIGlmIGl0IGlzIGEgY3Vib2lkIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0hhbGZFeHRlbnRzIC0gZGVzaXJlZCBoYWxmIGV4dGVudHMuXG4gICAgICovXG4gICAgc2V0SGFsZkV4dGVudHMobmV3SGFsZkV4dGVudHMpIHtcbiAgICAgICAgY29uc3QgcmF3UG9pbnQgPSBWZWN0b3JPcHMuaW50b1JhdyhuZXdIYWxmRXh0ZW50cyk7XG4gICAgICAgIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvU2V0SGFsZkV4dGVudHModGhpcy5oYW5kbGUsIHJhd1BvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJhZGl1cyBvZiB0aGlzIGNvbGxpZGVyIGlmIGl0IGlzIGEgYmFsbCwgY3lsaW5kZXIsIGNhcHN1bGUsIG9yIGNvbmUgc2hhcGUuXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBmaWVsZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgcGxlYXNlIGFjY2VzcyB0aGlzIGZpZWxkIG9uIGBzaGFwZWAgbWVtYmVyIGluc3RlYWQuXG4gICAgICovXG4gICAgcmFkaXVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlclNldC5yYXcuY29SYWRpdXModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByYWRpdXMgb2YgdGhpcyBjb2xsaWRlciBpZiBpdCBpcyBhIGJhbGwsIGN5bGluZGVyLCBjYXBzdWxlLCBvciBjb25lIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld1JhZGl1cyAtIGRlc2lyZWQgcmFkaXVzLlxuICAgICAqL1xuICAgIHNldFJhZGl1cyhuZXdSYWRpdXMpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRSYWRpdXModGhpcy5oYW5kbGUsIG5ld1JhZGl1cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByYWRpdXMgb2YgdGhlIHJvdW5kIGVkZ2VzIG9mIHRoaXMgY29sbGlkZXIgaWYgaXQgaXMgYSByb3VuZCBjeWxpbmRlci5cbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIGZpZWxkIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLCBwbGVhc2UgYWNjZXNzIHRoaXMgZmllbGQgb24gYHNoYXBlYCBtZW1iZXIgaW5zdGVhZC5cbiAgICAgKi9cbiAgICByb3VuZFJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvUm91bmRSYWRpdXModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByYWRpdXMgb2YgdGhlIHJvdW5kIGVkZ2VzIG9mIHRoaXMgY29sbGlkZXIgaWYgaXQgaGFzIHJvdW5kIGVkZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ld0JvcmRlclJhZGl1cyAtIGRlc2lyZWQgcm91bmQgZWRnZSByYWRpdXMuXG4gICAgICovXG4gICAgc2V0Um91bmRSYWRpdXMobmV3Qm9yZGVyUmFkaXVzKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvU2V0Um91bmRSYWRpdXModGhpcy5oYW5kbGUsIG5ld0JvcmRlclJhZGl1cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBoYWxmIGhlaWdodCBvZiB0aGlzIGNvbGxpZGVyIGlmIGl0IGlzIGEgY3lsaW5kZXIsIGNhcHN1bGUsIG9yIGNvbmUgc2hhcGUuXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBmaWVsZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgcGxlYXNlIGFjY2VzcyB0aGlzIGZpZWxkIG9uIGBzaGFwZWAgbWVtYmVyIGluc3RlYWQuXG4gICAgICovXG4gICAgaGFsZkhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvSGFsZkhlaWdodCh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhbGYgaGVpZ2h0IG9mIHRoaXMgY29sbGlkZXIgaWYgaXQgaXMgYSBjeWxpbmRlciwgY2Fwc3VsZSwgb3IgY29uZSBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdIYWxmaGVpZ2h0IC0gZGVzaXJlZCBoYWxmIGhlaWdodC5cbiAgICAgKi9cbiAgICBzZXRIYWxmSGVpZ2h0KG5ld0hhbGZoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jb2xsaWRlclNldC5yYXcuY29TZXRIYWxmSGVpZ2h0KHRoaXMuaGFuZGxlLCBuZXdIYWxmaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBjb2xsaWRlciBoYXMgYSB0cmlhbmdsZSBtZXNoLCBwb2x5bGluZSwgY29udmV4IHBvbHlnb24sIG9yIGNvbnZleCBwb2x5aGVkcm9uIHNoYXBlLFxuICAgICAqIHRoaXMgcmV0dXJucyB0aGUgdmVydGV4IGJ1ZmZlciBvZiBzYWlkIHNoYXBlLlxuICAgICAqIEBkZXByZWNhdGVkIHRoaXMgZmllbGQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUsIHBsZWFzZSBhY2Nlc3MgdGhpcyBmaWVsZCBvbiBgc2hhcGVgIG1lbWJlciBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHZlcnRpY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlclNldC5yYXcuY29WZXJ0aWNlcyh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgY29sbGlkZXIgaGFzIGEgdHJpYW5nbGUgbWVzaCwgcG9seWxpbmUsIG9yIGNvbnZleCBwb2x5aGVkcm9uIHNoYXBlLFxuICAgICAqIHRoaXMgcmV0dXJucyB0aGUgaW5kZXggYnVmZmVyIG9mIHNhaWQgc2hhcGUuXG4gICAgICogQGRlcHJlY2F0ZWQgdGhpcyBmaWVsZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgcGxlYXNlIGFjY2VzcyB0aGlzIGZpZWxkIG9uIGBzaGFwZWAgbWVtYmVyIGluc3RlYWQuXG4gICAgICovXG4gICAgaW5kaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvSW5kaWNlcyh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgY29sbGlkZXIgaGFzIGEgaGVpZ2h0ZmllbGQgc2hhcGUsIHRoaXMgcmV0dXJucyB0aGUgaGVpZ2h0cyBidWZmZXIgb2ZcbiAgICAgKiB0aGUgaGVpZ2h0ZmllbGQuXG4gICAgICogSW4gM0QsIHRoZSByZXR1cm5lZCBoZWlnaHQgbWF0cml4IGlzIHByb3ZpZGVkIGluIGNvbHVtbi1tYWpvciBvcmRlci5cbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIGZpZWxkIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLCBwbGVhc2UgYWNjZXNzIHRoaXMgZmllbGQgb24gYHNoYXBlYCBtZW1iZXIgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBoZWlnaHRmaWVsZEhlaWdodHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0hlaWdodGZpZWxkSGVpZ2h0cyh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgY29sbGlkZXIgaGFzIGEgaGVpZ2h0ZmllbGQgc2hhcGUsIHRoaXMgcmV0dXJucyB0aGUgc2NhbGVcbiAgICAgKiBhcHBsaWVkIHRvIGl0LlxuICAgICAqIEBkZXByZWNhdGVkIHRoaXMgZmllbGQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUsIHBsZWFzZSBhY2Nlc3MgdGhpcyBmaWVsZCBvbiBgc2hhcGVgIG1lbWJlciBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGhlaWdodGZpZWxkU2NhbGUoKSB7XG4gICAgICAgIGxldCBzY2FsZSA9IHRoaXMuY29sbGlkZXJTZXQucmF3LmNvSGVpZ2h0ZmllbGRTY2FsZSh0aGlzLmhhbmRsZSk7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyhzY2FsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByaWdpZC1ib2R5IHRoaXMgY29sbGlkZXIgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZnJpY3Rpb24gY29lZmZpY2llbnQgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBmcmljdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvRnJpY3Rpb24odGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdGl0dXRpb24gY29lZmZpY2llbnQgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICByZXN0aXR1dGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvUmVzdGl0dXRpb24odGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZGVuc2l0eSBvZiB0aGlzIGNvbGxpZGVyLlxuICAgICAqL1xuICAgIGRlbnNpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0RlbnNpdHkodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFzcyBvZiB0aGlzIGNvbGxpZGVyLlxuICAgICAqL1xuICAgIG1hc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb01hc3ModGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdm9sdW1lIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgICovXG4gICAgdm9sdW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlclNldC5yYXcuY29Wb2x1bWUodGhpcy5oYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29sbGlzaW9uIGdyb3VwcyBvZiB0aGlzIGNvbGxpZGVyLlxuICAgICAqL1xuICAgIGNvbGxpc2lvbkdyb3VwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvQ29sbGlzaW9uR3JvdXBzKHRoaXMuaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNvbHZlciBncm91cHMgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBzb2x2ZXJHcm91cHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb1NvbHZlckdyb3Vwcyh0aGlzLmhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgY29sbGlkZXIgY29udGFpbnMgYSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0LlxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgbGV0IHJhd1BvaW50ID0gVmVjdG9yT3BzLmludG9SYXcocG9pbnQpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb2xsaWRlclNldC5yYXcuY29Db250YWluc1BvaW50KHRoaXMuaGFuZGxlLCByYXdQb2ludCk7XG4gICAgICAgIHJhd1BvaW50LmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgcHJvamVjdGlvbiBvZiBhIHBvaW50IG9uIHRoaXMgY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gcHJvamVjdC5cbiAgICAgKiBAcGFyYW0gc29saWQgLSBJZiB0aGlzIGlzIHNldCB0byBgdHJ1ZWAgdGhlbiB0aGUgY29sbGlkZXIgc2hhcGVzIGFyZSBjb25zaWRlcmVkIHRvXG4gICAgICogICBiZSBwbGFpbiAoaWYgdGhlIHBvaW50IGlzIGxvY2F0ZWQgaW5zaWRlIG9mIGEgcGxhaW4gc2hhcGUsIGl0cyBwcm9qZWN0aW9uIGlzIHRoZSBwb2ludFxuICAgICAqICAgaXRzZWxmKS4gSWYgaXQgaXMgc2V0IHRvIGBmYWxzZWAgdGhlIGNvbGxpZGVyIHNoYXBlcyBhcmUgY29uc2lkZXJlZCB0byBiZSBob2xsb3dcbiAgICAgKiAgIChpZiB0aGUgcG9pbnQgaXMgbG9jYXRlZCBpbnNpZGUgb2YgYW4gaG9sbG93IHNoYXBlLCBpdCBpcyBwcm9qZWN0ZWQgb24gdGhlIHNoYXBlJ3NcbiAgICAgKiAgIGJvdW5kYXJ5KS5cbiAgICAgKi9cbiAgICBwcm9qZWN0UG9pbnQocG9pbnQsIHNvbGlkKSB7XG4gICAgICAgIGxldCByYXdQb2ludCA9IFZlY3Rvck9wcy5pbnRvUmF3KHBvaW50KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFBvaW50UHJvamVjdGlvbi5mcm9tUmF3KHRoaXMuY29sbGlkZXJTZXQucmF3LmNvUHJvamVjdFBvaW50KHRoaXMuaGFuZGxlLCByYXdQb2ludCwgc29saWQpKTtcbiAgICAgICAgcmF3UG9pbnQuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIGNvbGxpZGVyIGludGVyc2VjdHMgdGhlIGdpdmVuIHJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYXkgLSBUaGUgcmF5IHRvIGNhc3QuXG4gICAgICogQHBhcmFtIG1heFRvaSAtIFRoZSBtYXhpbXVtIHRpbWUtb2YtaW1wYWN0IHRoYXQgY2FuIGJlIHJlcG9ydGVkIGJ5IHRoaXMgY2FzdC4gVGhpcyBlZmZlY3RpdmVseVxuICAgICAqICAgbGltaXRzIHRoZSBsZW5ndGggb2YgdGhlIHJheSB0byBgcmF5LmRpci5ub3JtKCkgKiBtYXhUb2lgLlxuICAgICAqL1xuICAgIGludGVyc2VjdHNSYXkocmF5LCBtYXhUb2kpIHtcbiAgICAgICAgbGV0IHJhd09yaWcgPSBWZWN0b3JPcHMuaW50b1JhdyhyYXkub3JpZ2luKTtcbiAgICAgICAgbGV0IHJhd0RpciA9IFZlY3Rvck9wcy5pbnRvUmF3KHJheS5kaXIpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb2xsaWRlclNldC5yYXcuY29JbnRlcnNlY3RzUmF5KHRoaXMuaGFuZGxlLCByYXdPcmlnLCByYXdEaXIsIG1heFRvaSk7XG4gICAgICAgIHJhd09yaWcuZnJlZSgpO1xuICAgICAgICByYXdEaXIuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKlxuICAgICAqIENvbXB1dGVzIHRoZSBzbWFsbGVzdCB0aW1lIGJldHdlZW4gdGhpcyBhbmQgdGhlIGdpdmVuIHNoYXBlIHVuZGVyIHRyYW5zbGF0aW9uYWwgbW92ZW1lbnQgYXJlIHNlcGFyYXRlZCBieSBhIGRpc3RhbmNlIHNtYWxsZXIgb3IgZXF1YWwgdG8gZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sbGlkZXIxVmVsIC0gVGhlIGNvbnN0YW50IHZlbG9jaXR5IG9mIHRoZSBjdXJyZW50IHNoYXBlIHRvIGNhc3QgKGkuZS4gdGhlIGNhc3QgZGlyZWN0aW9uKS5cbiAgICAgKiBAcGFyYW0gc2hhcGUyIC0gVGhlIHNoYXBlIHRvIGNhc3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gc2hhcGUyUG9zIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgc2hhcGUuXG4gICAgICogQHBhcmFtIHNoYXBlMlJvdCAtIFRoZSByb3RhdGlvbiBvZiB0aGUgc2Vjb25kIHNoYXBlLlxuICAgICAqIEBwYXJhbSBzaGFwZTJWZWwgLSBUaGUgY29uc3RhbnQgdmVsb2NpdHkgb2YgdGhlIHNlY29uZCBzaGFwZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0RGlzdGFuY2Ug4oiSIElmIHRoZSBzaGFwZSBtb3ZlcyBjbG9zZXIgdG8gdGhpcyBkaXN0YW5jZSBmcm9tIGEgY29sbGlkZXIsIGEgaGl0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gbWF4VG9pIC0gVGhlIG1heGltdW0gdGltZS1vZi1pbXBhY3QgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgdGhpcyBjYXN0LiBUaGlzIGVmZmVjdGl2ZWx5XG4gICAgICogICBsaW1pdHMgdGhlIGRpc3RhbmNlIHRyYXZlbGVkIGJ5IHRoZSBzaGFwZSB0byBgY29sbGlkZXIxVmVsLm5vcm0oKSAqIG1heFRvaWAuXG4gICAgICogQHBhcmFtIHN0b3BBdFBlbmV0cmF0aW9uIC0gSWYgc2V0IHRvIGBmYWxzZWAsIHRoZSBsaW5lYXIgc2hhcGUtY2FzdCB3b27igJl0IGltbWVkaWF0ZWx5IHN0b3AgaWZcbiAgICAgKiAgIHRoZSBzaGFwZSBpcyBwZW5ldHJhdGluZyBhbm90aGVyIHNoYXBlIGF0IGl0cyBzdGFydGluZyBwb2ludCAqKmFuZCoqIGl0cyB0cmFqZWN0b3J5IGlzIHN1Y2hcbiAgICAgKiAgIHRoYXQgaXTigJlzIG9uIGEgcGF0aCB0byBleGl0IHRoYXQgcGVuZXRyYXRpb24gc3RhdGUuXG4gICAgICovXG4gICAgY2FzdFNoYXBlKGNvbGxpZGVyMVZlbCwgc2hhcGUyLCBzaGFwZTJQb3MsIHNoYXBlMlJvdCwgc2hhcGUyVmVsLCB0YXJnZXREaXN0YW5jZSwgbWF4VG9pLCBzdG9wQXRQZW5ldHJhdGlvbikge1xuICAgICAgICBsZXQgcmF3Q29sbGlkZXIxVmVsID0gVmVjdG9yT3BzLmludG9SYXcoY29sbGlkZXIxVmVsKTtcbiAgICAgICAgbGV0IHJhd1NoYXBlMlBvcyA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlMlBvcyk7XG4gICAgICAgIGxldCByYXdTaGFwZTJSb3QgPSBSb3RhdGlvbk9wcy5pbnRvUmF3KHNoYXBlMlJvdCk7XG4gICAgICAgIGxldCByYXdTaGFwZTJWZWwgPSBWZWN0b3JPcHMuaW50b1JhdyhzaGFwZTJWZWwpO1xuICAgICAgICBsZXQgcmF3U2hhcGUyID0gc2hhcGUyLmludG9SYXcoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFNoYXBlQ2FzdEhpdC5mcm9tUmF3KHRoaXMuY29sbGlkZXJTZXQsIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvQ2FzdFNoYXBlKHRoaXMuaGFuZGxlLCByYXdDb2xsaWRlcjFWZWwsIHJhd1NoYXBlMiwgcmF3U2hhcGUyUG9zLCByYXdTaGFwZTJSb3QsIHJhd1NoYXBlMlZlbCwgdGFyZ2V0RGlzdGFuY2UsIG1heFRvaSwgc3RvcEF0UGVuZXRyYXRpb24pKTtcbiAgICAgICAgcmF3Q29sbGlkZXIxVmVsLmZyZWUoKTtcbiAgICAgICAgcmF3U2hhcGUyUG9zLmZyZWUoKTtcbiAgICAgICAgcmF3U2hhcGUyUm90LmZyZWUoKTtcbiAgICAgICAgcmF3U2hhcGUyVmVsLmZyZWUoKTtcbiAgICAgICAgcmF3U2hhcGUyLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLypcbiAgICAgKiBDb21wdXRlcyB0aGUgc21hbGxlc3QgdGltZSBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBnaXZlbiBjb2xsaWRlciB1bmRlciB0cmFuc2xhdGlvbmFsIG1vdmVtZW50IGFyZSBzZXBhcmF0ZWQgYnkgYSBkaXN0YW5jZSBzbWFsbGVyIG9yIGVxdWFsIHRvIGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVyMVZlbCAtIFRoZSBjb25zdGFudCB2ZWxvY2l0eSBvZiB0aGUgY3VycmVudCBjb2xsaWRlciB0byBjYXN0IChpLmUuIHRoZSBjYXN0IGRpcmVjdGlvbikuXG4gICAgICogQHBhcmFtIGNvbGxpZGVyMiAtIFRoZSBjb2xsaWRlciB0byBjYXN0IGFnYWluc3QuXG4gICAgICogQHBhcmFtIGNvbGxpZGVyMlZlbCAtIFRoZSBjb25zdGFudCB2ZWxvY2l0eSBvZiB0aGUgc2Vjb25kIGNvbGxpZGVyLlxuICAgICAqIEBwYXJhbSB0YXJnZXREaXN0YW5jZSDiiJIgSWYgdGhlIHNoYXBlIG1vdmVzIGNsb3NlciB0byB0aGlzIGRpc3RhbmNlIGZyb20gYSBjb2xsaWRlciwgYSBoaXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSBtYXhUb2kgLSBUaGUgbWF4aW11bSB0aW1lLW9mLWltcGFjdCB0aGF0IGNhbiBiZSByZXBvcnRlZCBieSB0aGlzIGNhc3QuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgKiAgIGxpbWl0cyB0aGUgZGlzdGFuY2UgdHJhdmVsZWQgYnkgdGhlIHNoYXBlIHRvIGBzaGFwZVZlbC5ub3JtKCkgKiBtYXhUb2lgLlxuICAgICAqIEBwYXJhbSBzdG9wQXRQZW5ldHJhdGlvbiAtIElmIHNldCB0byBgZmFsc2VgLCB0aGUgbGluZWFyIHNoYXBlLWNhc3Qgd29u4oCZdCBpbW1lZGlhdGVseSBzdG9wIGlmXG4gICAgICogICB0aGUgc2hhcGUgaXMgcGVuZXRyYXRpbmcgYW5vdGhlciBzaGFwZSBhdCBpdHMgc3RhcnRpbmcgcG9pbnQgKiphbmQqKiBpdHMgdHJhamVjdG9yeSBpcyBzdWNoXG4gICAgICogICB0aGF0IGl04oCZcyBvbiBhIHBhdGggdG8gZXhpdCB0aGF0IHBlbmV0cmF0aW9uIHN0YXRlLlxuICAgICAqL1xuICAgIGNhc3RDb2xsaWRlcihjb2xsaWRlcjFWZWwsIGNvbGxpZGVyMiwgY29sbGlkZXIyVmVsLCB0YXJnZXREaXN0YW5jZSwgbWF4VG9pLCBzdG9wQXRQZW5ldHJhdGlvbikge1xuICAgICAgICBsZXQgcmF3Q29sbGlkZXIxVmVsID0gVmVjdG9yT3BzLmludG9SYXcoY29sbGlkZXIxVmVsKTtcbiAgICAgICAgbGV0IHJhd0NvbGxpZGVyMlZlbCA9IFZlY3Rvck9wcy5pbnRvUmF3KGNvbGxpZGVyMlZlbCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBDb2xsaWRlclNoYXBlQ2FzdEhpdC5mcm9tUmF3KHRoaXMuY29sbGlkZXJTZXQsIHRoaXMuY29sbGlkZXJTZXQucmF3LmNvQ2FzdENvbGxpZGVyKHRoaXMuaGFuZGxlLCByYXdDb2xsaWRlcjFWZWwsIGNvbGxpZGVyMi5oYW5kbGUsIHJhd0NvbGxpZGVyMlZlbCwgdGFyZ2V0RGlzdGFuY2UsIG1heFRvaSwgc3RvcEF0UGVuZXRyYXRpb24pKTtcbiAgICAgICAgcmF3Q29sbGlkZXIxVmVsLmZyZWUoKTtcbiAgICAgICAgcmF3Q29sbGlkZXIyVmVsLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaW50ZXJzZWN0c1NoYXBlKHNoYXBlMiwgc2hhcGVQb3MyLCBzaGFwZVJvdDIpIHtcbiAgICAgICAgbGV0IHJhd1BvczIgPSBWZWN0b3JPcHMuaW50b1JhdyhzaGFwZVBvczIpO1xuICAgICAgICBsZXQgcmF3Um90MiA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QyKTtcbiAgICAgICAgbGV0IHJhd1NoYXBlMiA9IHNoYXBlMi5pbnRvUmF3KCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0ludGVyc2VjdHNTaGFwZSh0aGlzLmhhbmRsZSwgcmF3U2hhcGUyLCByYXdQb3MyLCByYXdSb3QyKTtcbiAgICAgICAgcmF3UG9zMi5mcmVlKCk7XG4gICAgICAgIHJhd1JvdDIuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZTIuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBvbmUgcGFpciBvZiBjb250YWN0IHBvaW50cyBiZXR3ZWVuIHRoZSBzaGFwZSBvd25lZCBieSB0aGlzIGNvbGxpZGVyIGFuZCB0aGUgZ2l2ZW4gc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hhcGUyIC0gVGhlIHNlY29uZCBzaGFwZS5cbiAgICAgKiBAcGFyYW0gc2hhcGUyUG9zIC0gVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBzaGFwZS5cbiAgICAgKiBAcGFyYW0gc2hhcGUyUm90IC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBzZWNvbmQgc2hhcGUuXG4gICAgICogQHBhcmFtIHByZWRpY3Rpb24gLSBUaGUgcHJlZGljdGlvbiB2YWx1ZSwgaWYgdGhlIHNoYXBlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgZGlzdGFuY2UgZ3JlYXRlciB0aGFuIHRoaXMgdmFsdWUsIHRlc3Qgd2lsbCBmYWlsLlxuICAgICAqIEByZXR1cm5zIGBudWxsYCBpZiB0aGUgc2hhcGVzIGFyZSBzZXBhcmF0ZWQgYnkgYSBkaXN0YW5jZSBncmVhdGVyIHRoYW4gcHJlZGljdGlvbiwgb3RoZXJ3aXNlIGNvbnRhY3QgZGV0YWlscy4gVGhlIHJlc3VsdCBpcyBnaXZlbiBpbiB3b3JsZC1zcGFjZS5cbiAgICAgKi9cbiAgICBjb250YWN0U2hhcGUoc2hhcGUyLCBzaGFwZTJQb3MsIHNoYXBlMlJvdCwgcHJlZGljdGlvbikge1xuICAgICAgICBsZXQgcmF3UG9zMiA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlMlBvcyk7XG4gICAgICAgIGxldCByYXdSb3QyID0gUm90YXRpb25PcHMuaW50b1JhdyhzaGFwZTJSb3QpO1xuICAgICAgICBsZXQgcmF3U2hhcGUyID0gc2hhcGUyLmludG9SYXcoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFNoYXBlQ29udGFjdC5mcm9tUmF3KHRoaXMuY29sbGlkZXJTZXQucmF3LmNvQ29udGFjdFNoYXBlKHRoaXMuaGFuZGxlLCByYXdTaGFwZTIsIHJhd1BvczIsIHJhd1JvdDIsIHByZWRpY3Rpb24pKTtcbiAgICAgICAgcmF3UG9zMi5mcmVlKCk7XG4gICAgICAgIHJhd1JvdDIuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZTIuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBvbmUgcGFpciBvZiBjb250YWN0IHBvaW50cyBiZXR3ZWVuIHRoZSBjb2xsaWRlciBhbmQgdGhlIGdpdmVuIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVyMiAtIFRoZSBzZWNvbmQgY29sbGlkZXIuXG4gICAgICogQHBhcmFtIHByZWRpY3Rpb24gLSBUaGUgcHJlZGljdGlvbiB2YWx1ZSwgaWYgdGhlIHNoYXBlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgZGlzdGFuY2UgZ3JlYXRlciB0aGFuIHRoaXMgdmFsdWUsIHRlc3Qgd2lsbCBmYWlsLlxuICAgICAqIEByZXR1cm5zIGBudWxsYCBpZiB0aGUgc2hhcGVzIGFyZSBzZXBhcmF0ZWQgYnkgYSBkaXN0YW5jZSBncmVhdGVyIHRoYW4gcHJlZGljdGlvbiwgb3RoZXJ3aXNlIGNvbnRhY3QgZGV0YWlscy4gVGhlIHJlc3VsdCBpcyBnaXZlbiBpbiB3b3JsZC1zcGFjZS5cbiAgICAgKi9cbiAgICBjb250YWN0Q29sbGlkZXIoY29sbGlkZXIyLCBwcmVkaWN0aW9uKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBTaGFwZUNvbnRhY3QuZnJvbVJhdyh0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0NvbnRhY3RDb2xsaWRlcih0aGlzLmhhbmRsZSwgY29sbGlkZXIyLmhhbmRsZSwgcHJlZGljdGlvbikpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjbG9zZXN0IGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgcmF5IGFuZCB0aGlzIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogVGhpcyBhbHNvIGNvbXB1dGVzIHRoZSBub3JtYWwgYXQgdGhlIGhpdCBwb2ludC5cbiAgICAgKiBAcGFyYW0gcmF5IC0gVGhlIHJheSB0byBjYXN0LlxuICAgICAqIEBwYXJhbSBtYXhUb2kgLSBUaGUgbWF4aW11bSB0aW1lLW9mLWltcGFjdCB0aGF0IGNhbiBiZSByZXBvcnRlZCBieSB0aGlzIGNhc3QuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgKiAgIGxpbWl0cyB0aGUgbGVuZ3RoIG9mIHRoZSByYXkgdG8gYHJheS5kaXIubm9ybSgpICogbWF4VG9pYC5cbiAgICAgKiBAcGFyYW0gc29saWQgLSBJZiBgZmFsc2VgIHRoZW4gdGhlIHJheSB3aWxsIGF0dGVtcHQgdG8gaGl0IHRoZSBib3VuZGFyeSBvZiBhIHNoYXBlLCBldmVuIGlmIGl0c1xuICAgICAqICAgb3JpZ2luIGFscmVhZHkgbGllcyBpbnNpZGUgb2YgYSBzaGFwZS4gSW4gb3RoZXIgdGVybXMsIGB0cnVlYCBpbXBsaWVzIHRoYXQgYWxsIHNoYXBlcyBhcmUgcGxhaW4sXG4gICAgICogICB3aGVyZWFzIGBmYWxzZWAgaW1wbGllcyB0aGF0IGFsbCBzaGFwZXMgYXJlIGhvbGxvdyBmb3IgdGhpcyByYXktY2FzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdGltZS1vZi1pbXBhY3QgYmV0d2VlbiB0aGlzIGNvbGxpZGVyIGFuZCB0aGUgcmF5LCBvciBgLTFgIGlmIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cbiAgICAgKi9cbiAgICBjYXN0UmF5KHJheSwgbWF4VG9pLCBzb2xpZCkge1xuICAgICAgICBsZXQgcmF3T3JpZyA9IFZlY3Rvck9wcy5pbnRvUmF3KHJheS5vcmlnaW4pO1xuICAgICAgICBsZXQgcmF3RGlyID0gVmVjdG9yT3BzLmludG9SYXcocmF5LmRpcik7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0Nhc3RSYXkodGhpcy5oYW5kbGUsIHJhd09yaWcsIHJhd0RpciwgbWF4VG9pLCBzb2xpZCk7XG4gICAgICAgIHJhd09yaWcuZnJlZSgpO1xuICAgICAgICByYXdEaXIuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBjbG9zZXN0IGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgcmF5IGFuZCB0aGlzIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogVGhpcyBhbHNvIGNvbXB1dGVzIHRoZSBub3JtYWwgYXQgdGhlIGhpdCBwb2ludC5cbiAgICAgKiBAcGFyYW0gcmF5IC0gVGhlIHJheSB0byBjYXN0LlxuICAgICAqIEBwYXJhbSBtYXhUb2kgLSBUaGUgbWF4aW11bSB0aW1lLW9mLWltcGFjdCB0aGF0IGNhbiBiZSByZXBvcnRlZCBieSB0aGlzIGNhc3QuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgKiAgIGxpbWl0cyB0aGUgbGVuZ3RoIG9mIHRoZSByYXkgdG8gYHJheS5kaXIubm9ybSgpICogbWF4VG9pYC5cbiAgICAgKiBAcGFyYW0gc29saWQgLSBJZiBgZmFsc2VgIHRoZW4gdGhlIHJheSB3aWxsIGF0dGVtcHQgdG8gaGl0IHRoZSBib3VuZGFyeSBvZiBhIHNoYXBlLCBldmVuIGlmIGl0c1xuICAgICAqICAgb3JpZ2luIGFscmVhZHkgbGllcyBpbnNpZGUgb2YgYSBzaGFwZS4gSW4gb3RoZXIgdGVybXMsIGB0cnVlYCBpbXBsaWVzIHRoYXQgYWxsIHNoYXBlcyBhcmUgcGxhaW4sXG4gICAgICogICB3aGVyZWFzIGBmYWxzZWAgaW1wbGllcyB0aGF0IGFsbCBzaGFwZXMgYXJlIGhvbGxvdyBmb3IgdGhpcyByYXktY2FzdC5cbiAgICAgKi9cbiAgICBjYXN0UmF5QW5kR2V0Tm9ybWFsKHJheSwgbWF4VG9pLCBzb2xpZCkge1xuICAgICAgICBsZXQgcmF3T3JpZyA9IFZlY3Rvck9wcy5pbnRvUmF3KHJheS5vcmlnaW4pO1xuICAgICAgICBsZXQgcmF3RGlyID0gVmVjdG9yT3BzLmludG9SYXcocmF5LmRpcik7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYXlJbnRlcnNlY3Rpb24uZnJvbVJhdyh0aGlzLmNvbGxpZGVyU2V0LnJhdy5jb0Nhc3RSYXlBbmRHZXROb3JtYWwodGhpcy5oYW5kbGUsIHJhd09yaWcsIHJhd0RpciwgbWF4VG9pLCBzb2xpZCkpO1xuICAgICAgICByYXdPcmlnLmZyZWUoKTtcbiAgICAgICAgcmF3RGlyLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnQgdmFyIE1hc3NQcm9wc01vZGU7XG4oZnVuY3Rpb24gKE1hc3NQcm9wc01vZGUpIHtcbiAgICBNYXNzUHJvcHNNb2RlW01hc3NQcm9wc01vZGVbXCJEZW5zaXR5XCJdID0gMF0gPSBcIkRlbnNpdHlcIjtcbiAgICBNYXNzUHJvcHNNb2RlW01hc3NQcm9wc01vZGVbXCJNYXNzXCJdID0gMV0gPSBcIk1hc3NcIjtcbiAgICBNYXNzUHJvcHNNb2RlW01hc3NQcm9wc01vZGVbXCJNYXNzUHJvcHNcIl0gPSAyXSA9IFwiTWFzc1Byb3BzXCI7XG59KShNYXNzUHJvcHNNb2RlIHx8IChNYXNzUHJvcHNNb2RlID0ge30pKTtcbmV4cG9ydCBjbGFzcyBDb2xsaWRlckRlc2Mge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgY29sbGlkZXIgZGVzY3JpcHRvciBmcm9tIHRoZSBjb2xsaXNpb24gc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hhcGUgLSBUaGUgc2hhcGUgb2YgdGhlIGNvbGxpZGVyIGJlaW5nIGJ1aWx0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNoYXBlKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdGhpcy5tYXNzUHJvcHNNb2RlID0gTWFzc1Byb3BzTW9kZS5EZW5zaXR5O1xuICAgICAgICB0aGlzLmRlbnNpdHkgPSAxLjA7XG4gICAgICAgIHRoaXMuZnJpY3Rpb24gPSAwLjU7XG4gICAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBSb3RhdGlvbk9wcy5pZGVudGl0eSgpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uID0gVmVjdG9yT3BzLnplcm9zKCk7XG4gICAgICAgIHRoaXMuaXNTZW5zb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMgPSA0Mjk0OTY3Mjk1O1xuICAgICAgICB0aGlzLnNvbHZlckdyb3VwcyA9IDQyOTQ5NjcyOTU7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25Db21iaW5lUnVsZSA9IENvZWZmaWNpZW50Q29tYmluZVJ1bGUuQXZlcmFnZTtcbiAgICAgICAgdGhpcy5yZXN0aXR1dGlvbkNvbWJpbmVSdWxlID0gQ29lZmZpY2llbnRDb21iaW5lUnVsZS5BdmVyYWdlO1xuICAgICAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvblR5cGVzID0gQWN0aXZlQ29sbGlzaW9uVHlwZXMuREVGQVVMVDtcbiAgICAgICAgdGhpcy5hY3RpdmVFdmVudHMgPSBBY3RpdmVFdmVudHMuTk9ORTtcbiAgICAgICAgdGhpcy5hY3RpdmVIb29rcyA9IEFjdGl2ZUhvb2tzLk5PTkU7XG4gICAgICAgIHRoaXMubWFzcyA9IDAuMDtcbiAgICAgICAgdGhpcy5jZW50ZXJPZk1hc3MgPSBWZWN0b3JPcHMuemVyb3MoKTtcbiAgICAgICAgdGhpcy5jb250YWN0Rm9yY2VFdmVudFRocmVzaG9sZCA9IDAuMDtcbiAgICAgICAgdGhpcy5jb250YWN0U2tpbiA9IDAuMDtcbiAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgdGhpcy5wcmluY2lwYWxBbmd1bGFySW5lcnRpYSA9IDAuMDtcbiAgICAgICAgdGhpcy5yb3RhdGlvbnNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gI2VuZGlmXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjb2xsaWRlciBkZXNjcmlwdG9yIHdpdGggYSBiYWxsIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGJhbGwuXG4gICAgICovXG4gICAgc3RhdGljIGJhbGwocmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gbmV3IEJhbGwocmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaWRlckRlc2Moc2hhcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY29sbGlkZXIgZGVzY3JpcHRvciB3aXRoIGEgY2Fwc3VsZSBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYWxmSGVpZ2h0IC0gVGhlIGhhbGYtaGVpZ2h0IG9mIHRoZSBjYXBzdWxlLCBhbG9uZyB0aGUgYHlgIGF4aXMuXG4gICAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNhcHN1bGUgYmFzaXMuXG4gICAgICovXG4gICAgc3RhdGljIGNhcHN1bGUoaGFsZkhlaWdodCwgcmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gbmV3IENhcHN1bGUoaGFsZkhlaWdodCwgcmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaWRlckRlc2Moc2hhcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNlZ21lbnQgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBwb2ludCBvZiB0aGUgc2VnbWVudC5cbiAgICAgKiBAcGFyYW0gYiAtIFRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIHNlZ21lbnQuXG4gICAgICovXG4gICAgc3RhdGljIHNlZ21lbnQoYSwgYikge1xuICAgICAgICBjb25zdCBzaGFwZSA9IG5ldyBTZWdtZW50KGEsIGIpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxpZGVyRGVzYyhzaGFwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJpYW5nbGUgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBwb2ludCBvZiB0aGUgdHJpYW5nbGUuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgc2Vjb25kIHBvaW50IG9mIHRoZSB0cmlhbmdsZS5cbiAgICAgKiBAcGFyYW0gYyAtIFRoZSB0aGlyZCBwb2ludCBvZiB0aGUgdHJpYW5nbGUuXG4gICAgICovXG4gICAgc3RhdGljIHRyaWFuZ2xlKGEsIGIsIGMpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgVHJpYW5nbGUoYSwgYiwgYyk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGlkZXJEZXNjKHNoYXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0cmlhbmdsZSBzaGFwZSB3aXRoIHJvdW5kIGNvcm5lcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBwb2ludCBvZiB0aGUgdHJpYW5nbGUuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgc2Vjb25kIHBvaW50IG9mIHRoZSB0cmlhbmdsZS5cbiAgICAgKiBAcGFyYW0gYyAtIFRoZSB0aGlyZCBwb2ludCBvZiB0aGUgdHJpYW5nbGUuXG4gICAgICogQHBhcmFtIGJvcmRlclJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGJvcmRlcnMgb2YgdGhpcyB0cmlhbmdsZS4gSW4gM0QsXG4gICAgICogICB0aGlzIGlzIGFsc28gZXF1YWwgdG8gaGFsZiB0aGUgdGhpY2tuZXNzIG9mIHRoZSB0cmlhbmdsZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcm91bmRUcmlhbmdsZShhLCBiLCBjLCBib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgUm91bmRUcmlhbmdsZShhLCBiLCBjLCBib3JkZXJSYWRpdXMpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxpZGVyRGVzYyhzaGFwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sbGlkZXIgZGVzY3JpcHRvciB3aXRoIGEgcG9seWxpbmUgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmVydGljZXMgLSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlsaW5lJ3MgdmVydGljZXMuXG4gICAgICogQHBhcmFtIGluZGljZXMgLSBUaGUgaW5kaWNlcyBvZiB0aGUgcG9seWxpbmUncyBzZWdtZW50cy4gSWYgdGhpcyBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsXG4gICAgICogICAgdGhlIHZlcnRpY2VzIGFyZSBhc3N1bWVkIHRvIGRlc2NyaWJlIGEgbGluZSBzdHJpcC5cbiAgICAgKi9cbiAgICBzdGF0aWMgcG9seWxpbmUodmVydGljZXMsIGluZGljZXMpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgUG9seWxpbmUodmVydGljZXMsIGluZGljZXMpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxpZGVyRGVzYyhzaGFwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sbGlkZXIgZGVzY3JpcHRvciB3aXRoIGEgdHJpYW5nbGUgbWVzaCBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2ZXJ0aWNlcyAtIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgdHJpYW5nbGUgbWVzaCdzIHZlcnRpY2VzLlxuICAgICAqIEBwYXJhbSBpbmRpY2VzIC0gVGhlIGluZGljZXMgb2YgdGhlIHRyaWFuZ2xlIG1lc2gncyB0cmlhbmdsZXMuXG4gICAgICovXG4gICAgc3RhdGljIHRyaW1lc2godmVydGljZXMsIGluZGljZXMsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gbmV3IFRyaU1lc2godmVydGljZXMsIGluZGljZXMsIGZsYWdzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaWRlckRlc2Moc2hhcGUpO1xuICAgIH1cbiAgICAvLyAjaWYgRElNMlxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sbGlkZXIgZGVzY3JpcHRvciB3aXRoIGEgcmVjdGFuZ3VsYXIgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaHggLSBUaGUgaGFsZi13aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIGFsb25nIGl0cyBsb2NhbCBgeGAgYXhpcy5cbiAgICAgKiBAcGFyYW0gaHkgLSBUaGUgaGFsZi13aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIGFsb25nIGl0cyBsb2NhbCBgeWAgYXhpcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3Vib2lkKGh4LCBoeSkge1xuICAgICAgICBjb25zdCBzaGFwZSA9IG5ldyBDdWJvaWQoaHgsIGh5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaWRlckRlc2Moc2hhcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxpZGVyIGRlc2NyaXB0b3Igd2l0aCBhIHJlY3Rhbmd1bGFyIHNoYXBlIHdpdGggcm91bmQgYm9yZGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoeCAtIFRoZSBoYWxmLXdpZHRoIG9mIHRoZSByZWN0YW5nbGUgYWxvbmcgaXRzIGxvY2FsIGB4YCBheGlzLlxuICAgICAqIEBwYXJhbSBoeSAtIFRoZSBoYWxmLXdpZHRoIG9mIHRoZSByZWN0YW5nbGUgYWxvbmcgaXRzIGxvY2FsIGB5YCBheGlzLlxuICAgICAqIEBwYXJhbSBib3JkZXJSYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjdWJvaWQncyBib3JkZXJzLlxuICAgICAqL1xuICAgIHN0YXRpYyByb3VuZEN1Ym9pZChoeCwgaHksIGJvcmRlclJhZGl1cykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IG5ldyBSb3VuZEN1Ym9pZChoeCwgaHksIGJvcmRlclJhZGl1cyk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGlkZXJEZXNjKHNoYXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb2xsaWRlciBkZXNjcmlwdGlvbiB3aXRoIGEgaGFsZnNwYWNlIChpbmZpbml0ZSBwbGFuZSkgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9ybWFsIC0gVGhlIG91dHdhcmQgbm9ybWFsIG9mIHRoZSBwbGFuZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFsZnNwYWNlKG5vcm1hbCkge1xuICAgICAgICBjb25zdCBzaGFwZSA9IG5ldyBIYWxmU3BhY2Uobm9ybWFsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaWRlckRlc2Moc2hhcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxpZGVyIGRlc2NyaXB0b3Igd2l0aCBhIGhlaWdodGZpZWxkIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhlaWdodHMgLSBUaGUgaGVpZ2h0cyBvZiB0aGUgaGVpZ2h0ZmllbGQsIGFsb25nIGl0cyBsb2NhbCBgeWAgYXhpcy5cbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBUaGUgc2NhbGUgZmFjdG9yIGFwcGxpZWQgdG8gdGhlIGhlaWdodGZpZWxkLlxuICAgICAqL1xuICAgIHN0YXRpYyBoZWlnaHRmaWVsZChoZWlnaHRzLCBzY2FsZSkge1xuICAgICAgICBjb25zdCBzaGFwZSA9IG5ldyBIZWlnaHRmaWVsZChoZWlnaHRzLCBzY2FsZSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGlkZXJEZXNjKHNoYXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIGNvbnZleC1odWxsIG9mIHRoZSBnaXZlbiBwb2ludHMgYW5kIHVzZSB0aGUgcmVzdWx0aW5nXG4gICAgICogY29udmV4IHBvbHlnb24gYXMgdGhlIHNoYXBlIGZvciB0aGlzIG5ldyBjb2xsaWRlciBkZXNjcmlwdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvaW50cyAtIFRoZSBwb2ludCB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb21wdXRlIHRoZSBjb252ZXgtaHVsbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmV4SHVsbChwb2ludHMpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgQ29udmV4UG9seWdvbihwb2ludHMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaWRlckRlc2Moc2hhcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxpZGVyIGRlc2NyaXB0b3IgdGhhdCB1c2VzIHRoZSBnaXZlbiBzZXQgb2YgcG9pbnRzIGFzc3VtZWRcbiAgICAgKiB0byBmb3JtIGEgY29udmV4IHBvbHlsaW5lIChubyBjb252ZXgtaHVsbCBjb21wdXRhdGlvbiB3aWxsIGJlIGRvbmUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZlcnRpY2VzIC0gVGhlIHZlcnRpY2VzIG9mIHRoZSBjb252ZXggcG9seWxpbmUuXG4gICAgICovXG4gICAgc3RhdGljIGNvbnZleFBvbHlsaW5lKHZlcnRpY2VzKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gbmV3IENvbnZleFBvbHlnb24odmVydGljZXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxpZGVyRGVzYyhzaGFwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBjb252ZXgtaHVsbCBvZiB0aGUgZ2l2ZW4gcG9pbnRzIGFuZCB1c2UgdGhlIHJlc3VsdGluZ1xuICAgICAqIGNvbnZleCBwb2x5Z29uIGFzIHRoZSBzaGFwZSBmb3IgdGhpcyBuZXcgY29sbGlkZXIgZGVzY3JpcHRvci4gQVxuICAgICAqIGJvcmRlciBpcyBhZGRlZCB0byB0aGF0IGNvbnZleCBwb2x5Z29uIHRvIGdpdmUgaXQgcm91bmQgY29ybmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgcG9pbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgY29udmV4LWh1bGwuXG4gICAgICogQHBhcmFtIGJvcmRlclJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIHJvdW5kIGJvcmRlciBhZGRlZCB0byB0aGUgY29udmV4IHBvbHlnb24uXG4gICAgICovXG4gICAgc3RhdGljIHJvdW5kQ29udmV4SHVsbChwb2ludHMsIGJvcmRlclJhZGl1cykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IG5ldyBSb3VuZENvbnZleFBvbHlnb24ocG9pbnRzLCBib3JkZXJSYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaWRlckRlc2Moc2hhcGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxpZGVyIGRlc2NyaXB0b3IgdGhhdCB1c2VzIHRoZSBnaXZlbiBzZXQgb2YgcG9pbnRzIGFzc3VtZWRcbiAgICAgKiB0byBmb3JtIGEgcm91bmQgY29udmV4IHBvbHlsaW5lIChubyBjb252ZXgtaHVsbCBjb21wdXRhdGlvbiB3aWxsIGJlIGRvbmUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZlcnRpY2VzIC0gVGhlIHZlcnRpY2VzIG9mIHRoZSBjb252ZXggcG9seWxpbmUuXG4gICAgICogQHBhcmFtIGJvcmRlclJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIHJvdW5kIGJvcmRlciBhZGRlZCB0byB0aGUgY29udmV4IHBvbHlsaW5lLlxuICAgICAqL1xuICAgIHN0YXRpYyByb3VuZENvbnZleFBvbHlsaW5lKHZlcnRpY2VzLCBib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBuZXcgUm91bmRDb252ZXhQb2x5Z29uKHZlcnRpY2VzLCBib3JkZXJSYWRpdXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IENvbGxpZGVyRGVzYyhzaGFwZSk7XG4gICAgfVxuICAgIC8vICNlbmRpZlxuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbGxpZGVyIHRvIGJlIGNyZWF0ZWQgcmVsYXRpdmUgdG8gdGhlIHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgc2V0VHJhbnNsYXRpb24oeCwgeSkge1xuICAgICAgICBpZiAodHlwZW9mIHggIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeSAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudHMgbXVzdCBiZSBudW1iZXJzLlwiKTtcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbiA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGNvbGxpZGVyIHRvIGJlIGNyZWF0ZWQgcmVsYXRpdmUgdG8gdGhlIHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm90IC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBjb2xsaWRlciB0byBiZSBjcmVhdGVkIHJlbGF0aXZlIHRvIHRoZSByaWdpZC1ib2R5IGl0IGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIHNldFJvdGF0aW9uKHJvdCkge1xuICAgICAgICAvLyAjaWYgRElNMlxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90O1xuICAgICAgICAvLyAjZW5kaWZcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgd2hldGhlciBvciBub3QgdGhlIGNvbGxpZGVyIGJlaW5nIGNyZWF0ZWQgaXMgYSBzZW5zb3IuXG4gICAgICpcbiAgICAgKiBBIHNlbnNvciBjb2xsaWRlciBkb2VzIG5vdCB0YWtlIHBhcnQgb2YgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbiwgYnV0IGdlbmVyYXRlc1xuICAgICAqIHByb3hpbWl0eSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Vuc29yIC0gU2V0IHRvIGB0cnVlYCBvZiB0aGUgY29sbGlkZXIgYnVpbHQgaXMgdG8gYmUgYSBzZW5zb3IuXG4gICAgICovXG4gICAgc2V0U2Vuc29yKHNlbnNvcikge1xuICAgICAgICB0aGlzLmlzU2Vuc29yID0gc2Vuc29yO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRoZSBjcmVhdGVkIGNvbGxpZGVyIHdpbGwgYmUgZW5hYmxlZCBvciBkaXNhYmxlZC5cbiAgICAgKiBAcGFyYW0gZW5hYmxlZCDiiJIgSWYgc2V0IHRvIGBmYWxzZWAgdGhlIGNvbGxpZGVyIHdpbGwgYmUgZGlzYWJsZWQgYXQgY3JlYXRpb24uXG4gICAgICovXG4gICAgc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb250YWN0IHNraW4gb2YgdGhlIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogVGhlIGNvbnRhY3Qgc2tpbiBhY3RzIGFzIGlmIHRoZSBjb2xsaWRlciB3YXMgZW5sYXJnZWQgd2l0aCBhIHNraW4gb2Ygd2lkdGggYHNraW5fdGhpY2tuZXNzYFxuICAgICAqIGFyb3VuZCBpdCwga2VlcGluZyBvYmplY3RzIGZ1cnRoZXIgYXBhcnQgd2hlbiBjb2xsaWRpbmcuXG4gICAgICpcbiAgICAgKiBBIG5vbi16ZXJvIGNvbnRhY3Qgc2tpbiBjYW4gaW5jcmVhc2UgcGVyZm9ybWFuY2UsIGFuZCBpbiBzb21lIGNhc2VzLCBzdGFiaWxpdHkuIEhvd2V2ZXJcbiAgICAgKiBpdCBjcmVhdGVzIGEgc21hbGwgZ2FwIGJldHdlZW4gY29sbGlkaW5nIG9iamVjdCAoZXF1YWwgdG8gdGhlIHN1bSBvZiB0aGVpciBza2luKS4gSWYgdGhlXG4gICAgICogc2tpbiBpcyBzdWZmaWNpZW50bHkgc21hbGwsIHRoaXMgbWlnaHQgbm90IGJlIHZpc3VhbGx5IHNpZ25pZmljYW50IG9yIGNhbiBiZSBoaWRkZW4gYnkgdGhlXG4gICAgICogcmVuZGVyaW5nIGFzc2V0cy5cbiAgICAgKi9cbiAgICBzZXRDb250YWN0U2tpbih0aGlja25lc3MpIHtcbiAgICAgICAgdGhpcy5jb250YWN0U2tpbiA9IHRoaWNrbmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlbnNpdHkgb2YgdGhlIGNvbGxpZGVyIGJlaW5nIGJ1aWx0LlxuICAgICAqXG4gICAgICogVGhlIG1hc3MgYW5kIGFuZ3VsYXIgaW5lcnRpYSB0ZW5zb3Igd2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoaXMgZGVuc2l0eSBhbmQgdGhlIGNvbGxpZGVy4oCZcyBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZW5zaXR5IC0gVGhlIGRlbnNpdHkgdG8gc2V0LCBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMC4gQSBkZW5zaXR5IG9mIDAgbWVhbnMgdGhhdCB0aGlzIGNvbGxpZGVyXG4gICAgICogICAgICAgICAgICAgICAgICB3aWxsIG5vdCBhZmZlY3QgdGhlIG1hc3Mgb3IgYW5ndWxhciBpbmVydGlhIG9mIHRoZSByaWdpZC1ib2R5IGl0IGlzIGF0dGFjaGVkIHRvLlxuICAgICAqL1xuICAgIHNldERlbnNpdHkoZGVuc2l0eSkge1xuICAgICAgICB0aGlzLm1hc3NQcm9wc01vZGUgPSBNYXNzUHJvcHNNb2RlLkRlbnNpdHk7XG4gICAgICAgIHRoaXMuZGVuc2l0eSA9IGRlbnNpdHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXNzIG9mIHRoZSBjb2xsaWRlciBiZWluZyBidWlsdC5cbiAgICAgKlxuICAgICAqIFRoZSBhbmd1bGFyIGluZXJ0aWEgdGVuc29yIHdpbGwgYmUgY29tcHV0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGlzIG1hc3MgYW5kIHRoZSBjb2xsaWRlcuKAmXMgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFzcyAtIFRoZSBtYXNzIHRvIHNldCwgbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDAuXG4gICAgICovXG4gICAgc2V0TWFzcyhtYXNzKSB7XG4gICAgICAgIHRoaXMubWFzc1Byb3BzTW9kZSA9IE1hc3NQcm9wc01vZGUuTWFzcztcbiAgICAgICAgdGhpcy5tYXNzID0gbWFzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoZSBjb2xsaWRlciBiZWluZyBidWlsdC5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVwbGFjZXMgdGhlIG1hc3MtcHJvcGVydGllcyBhdXRvbWF0aWNhbGx5IGNvbXB1dGVkIGZyb20gdGhlIGNvbGxpZGVyJ3MgZGVuc2l0eSBhbmQgc2hhcGUuXG4gICAgICogVGhlc2UgbWFzcy1wcm9wZXJ0aWVzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hc3MtcHJvcGVydGllcyBvZiB0aGUgcmlnaWQtYm9keSB0aGlzIGNvbGxpZGVyIHdpbGwgYmUgYXR0YWNoZWQgdG8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFzcyDiiJIgVGhlIG1hc3Mgb2YgdGhlIGNvbGxpZGVyIHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0gY2VudGVyT2ZNYXNzIOKIkiBUaGUgY2VudGVyLW9mLW1hc3Mgb2YgdGhlIGNvbGxpZGVyIHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0gcHJpbmNpcGFsQW5ndWxhckluZXJ0aWEg4oiSIFRoZSBwcmluY2lwYWwgYW5ndWxhciBpbmVydGlhIG9mIHRoZSBjb2xsaWRlciB0byBjcmVhdGUuXG4gICAgICovXG4gICAgc2V0TWFzc1Byb3BlcnRpZXMobWFzcywgY2VudGVyT2ZNYXNzLCBwcmluY2lwYWxBbmd1bGFySW5lcnRpYSkge1xuICAgICAgICB0aGlzLm1hc3NQcm9wc01vZGUgPSBNYXNzUHJvcHNNb2RlLk1hc3NQcm9wcztcbiAgICAgICAgdGhpcy5tYXNzID0gbWFzcztcbiAgICAgICAgVmVjdG9yT3BzLmNvcHkodGhpcy5jZW50ZXJPZk1hc3MsIGNlbnRlck9mTWFzcyk7XG4gICAgICAgIHRoaXMucHJpbmNpcGFsQW5ndWxhckluZXJ0aWEgPSBwcmluY2lwYWxBbmd1bGFySW5lcnRpYTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICNlbmRpZlxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlc3RpdHV0aW9uIGNvZWZmaWNpZW50IG9mIHRoZSBjb2xsaWRlciB0byBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3RpdHV0aW9uIC0gVGhlIHJlc3RpdHV0aW9uIGNvZWZmaWNpZW50IGluIGBbMCwgMV1gLiBBIHZhbHVlIG9mIDAgKHRoZSBkZWZhdWx0KSBtZWFucyBubyBib3VuY2luZyBiZWhhdmlvclxuICAgICAqICAgICAgICAgICAgICAgICAgIHdoaWxlIDEgbWVhbnMgcGVyZmVjdCBib3VuY2luZyAodGhvdWdoIGVuZXJneSBtYXkgc3RpbGwgYmUgbG9zdCBkdWUgdG8gbnVtZXJpY2FsIGVycm9ycyBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cyBzb2x2ZXIpLlxuICAgICAqL1xuICAgIHNldFJlc3RpdHV0aW9uKHJlc3RpdHV0aW9uKSB7XG4gICAgICAgIHRoaXMucmVzdGl0dXRpb24gPSByZXN0aXR1dGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZyaWN0aW9uIGNvZWZmaWNpZW50IG9mIHRoZSBjb2xsaWRlciB0byBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyaWN0aW9uIC0gVGhlIGZyaWN0aW9uIGNvZWZmaWNpZW50LiBNdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMC4gVGhpcyBpcyBnZW5lcmFsbHkgc21hbGxlciB0aGFuIDEuIFRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgIGhpZ2hlciB0aGUgY29lZmZpY2llbnQsIHRoZSBzdHJvbmdlciBmcmljdGlvbiBmb3JjZXMgd2lsbCBiZSBmb3IgY29udGFjdHMgd2l0aCB0aGUgY29sbGlkZXJcbiAgICAgKiAgICAgICAgICAgICAgICAgICBiZWluZyBidWlsdC5cbiAgICAgKi9cbiAgICBzZXRGcmljdGlvbihmcmljdGlvbikge1xuICAgICAgICB0aGlzLmZyaWN0aW9uID0gZnJpY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydWxlIHVzZWQgdG8gY29tYmluZSB0aGUgZnJpY3Rpb24gY29lZmZpY2llbnRzIG9mIHR3byBjb2xsaWRlcnNcbiAgICAgKiBjb2xsaWRlcnMgaW52b2x2ZWQgaW4gYSBjb250YWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bGUg4oiSIFRoZSBjb21iaW5lIHJ1bGUgdG8gYXBwbHkuXG4gICAgICovXG4gICAgc2V0RnJpY3Rpb25Db21iaW5lUnVsZShydWxlKSB7XG4gICAgICAgIHRoaXMuZnJpY3Rpb25Db21iaW5lUnVsZSA9IHJ1bGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBydWxlIHVzZWQgdG8gY29tYmluZSB0aGUgcmVzdGl0dXRpb24gY29lZmZpY2llbnRzIG9mIHR3byBjb2xsaWRlcnNcbiAgICAgKiBjb2xsaWRlcnMgaW52b2x2ZWQgaW4gYSBjb250YWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bGUg4oiSIFRoZSBjb21iaW5lIHJ1bGUgdG8gYXBwbHkuXG4gICAgICovXG4gICAgc2V0UmVzdGl0dXRpb25Db21iaW5lUnVsZShydWxlKSB7XG4gICAgICAgIHRoaXMucmVzdGl0dXRpb25Db21iaW5lUnVsZSA9IHJ1bGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb2xsaXNpb24gZ3JvdXBzIHVzZWQgYnkgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIFR3byBjb2xsaWRlcnMgd2lsbCBpbnRlcmFjdCBpZmYuIHRoZWlyIGNvbGxpc2lvbiBncm91cHMgYXJlIGNvbXBhdGlibGUuXG4gICAgICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIGBJbnRlcmFjdGlvbkdyb3Vwc2AgZm9yIGRldGFpbHMgb24gdGVoIHVzZWQgYml0IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JvdXBzIC0gVGhlIGNvbGxpc2lvbiBncm91cHMgdXNlZCBmb3IgdGhlIGNvbGxpZGVyIGJlaW5nIGJ1aWx0LlxuICAgICAqL1xuICAgIHNldENvbGxpc2lvbkdyb3Vwcyhncm91cHMpIHtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25Hcm91cHMgPSBncm91cHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzb2x2ZXIgZ3JvdXBzIHVzZWQgYnkgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIEZvcmNlcyBiZXR3ZWVuIHR3byBjb2xsaWRlcnMgaW4gY29udGFjdCB3aWxsIGJlIGNvbXB1dGVkIGlmZiB0aGVpciBzb2x2ZXJcbiAgICAgKiBncm91cHMgYXJlIGNvbXBhdGlibGUuXG4gICAgICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIGBJbnRlcmFjdGlvbkdyb3Vwc2AgZm9yIGRldGFpbHMgb24gdGhlIHVzZWQgYml0IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ3JvdXBzIC0gVGhlIHNvbHZlciBncm91cHMgdXNlZCBmb3IgdGhlIGNvbGxpZGVyIGJlaW5nIGJ1aWx0LlxuICAgICAqL1xuICAgIHNldFNvbHZlckdyb3Vwcyhncm91cHMpIHtcbiAgICAgICAgdGhpcy5zb2x2ZXJHcm91cHMgPSBncm91cHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBoeXNpY3MgaG9va3MgYWN0aXZlIGZvciB0aGlzIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgdG8gZW5hYmxlIGN1c3RvbSBmaWx0ZXJpbmcgcnVsZXMgZm9yIGNvbnRhY3QvaW50ZXJzZWNzdGlvbiBwYWlycyBpbnZvbHZpbmcgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3RpdmVIb29rcyAtIFRoZSBob29rcyBhY3RpdmUgZm9yIGNvbnRhY3QvaW50ZXJzZWN0aW9uIHBhaXJzIGludm9sdmluZyB0aGlzIGNvbGxpZGVyLlxuICAgICAqL1xuICAgIHNldEFjdGl2ZUhvb2tzKGFjdGl2ZUhvb2tzKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSG9va3MgPSBhY3RpdmVIb29rcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZXZlbnRzIGFjdGl2ZSBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHRvIGVuYWJsZSBjb250YWN0IGFuZC9vciBpbnRlcnNlY3Rpb24gZXZlbnQgcmVwb3J0aW5nIGZvciB0aGlzIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGl2ZUV2ZW50cyAtIFRoZSBldmVudHMgYWN0aXZlIGZvciBjb250YWN0L2ludGVyc2VjdGlvbiBwYWlycyBpbnZvbHZpbmcgdGhpcyBjb2xsaWRlci5cbiAgICAgKi9cbiAgICBzZXRBY3RpdmVFdmVudHMoYWN0aXZlRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlRXZlbnRzID0gYWN0aXZlRXZlbnRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb2xsaXNpb24gdHlwZXMgYWN0aXZlIGZvciB0aGlzIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGl2ZUNvbGxpc2lvblR5cGVzIC0gVGhlIGhvb2tzIGFjdGl2ZSBmb3IgY29udGFjdC9pbnRlcnNlY3Rpb24gcGFpcnMgaW52b2x2aW5nIHRoaXMgY29sbGlkZXIuXG4gICAgICovXG4gICAgc2V0QWN0aXZlQ29sbGlzaW9uVHlwZXMoYWN0aXZlQ29sbGlzaW9uVHlwZXMpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVDb2xsaXNpb25UeXBlcyA9IGFjdGl2ZUNvbGxpc2lvblR5cGVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdG90YWwgZm9yY2UgbWFnbml0dWRlIGJleW9uZCB3aGljaCBhIGNvbnRhY3QgZm9yY2UgZXZlbnQgY2FuIGJlIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhyZXNob2xkIC0gVGhlIGZvcmNlIHRocmVzaG9sZCB0byBzZXQuXG4gICAgICovXG4gICAgc2V0Q29udGFjdEZvcmNlRXZlbnRUaHJlc2hvbGQodGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuY29udGFjdEZvcmNlRXZlbnRUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/collider.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/collider_set.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/collider_set.js ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderSet: () => (/* binding */ ColliderSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _collider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collider */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/collider.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _collider__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _collider__WEBPACK_IMPORTED_MODULE_2__, _math__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass ColliderSet {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawColliderSet();\n        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle) => {\n                this.map.set(handle, new _collider__WEBPACK_IMPORTED_MODULE_2__.Collider(this, handle, null));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    castClosure(f) {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            }\n            else {\n                return undefined;\n            }\n        };\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((collider) => collider.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    createCollider(bodies, desc, parentHandle) {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.translation);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_3__.RotationOps.intoRaw(desc.rotation);\n        let rawCom = _math__WEBPACK_IMPORTED_MODULE_3__.VectorOps.intoRaw(desc.centerOfMass);\n        let handle = this.raw.createCollider(desc.enabled, rawShape, rawTra, rawRot, desc.massPropsMode, desc.mass, rawCom, \n        // #if DIM2\n        desc.principalAngularInertia, \n        // #endif\n        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, desc.contactForceEventThreshold, desc.contactSkin, hasParent, hasParent ? parentHandle : 0, bodies.raw);\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new _collider__WEBPACK_IMPORTED_MODULE_2__.Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * The number of colliders on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=collider_set.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L2NvbGxpZGVyX3NldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF3QztBQUNIO0FBQ1k7QUFDWDtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOEJBQThCLGdEQUFjO0FBQzVDLHVCQUF1Qiw2Q0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0NBQVE7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBUztBQUM5QixxQkFBcUIsOENBQVc7QUFDaEMscUJBQXFCLDRDQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGdlb21ldHJ5XFxjb2xsaWRlcl9zZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF3Q29sbGlkZXJTZXQgfSBmcm9tIFwiLi4vcmF3XCI7XG5pbXBvcnQgeyBDb2FyZW5hIH0gZnJvbSBcIi4uL2NvYXJlbmFcIjtcbmltcG9ydCB7IFJvdGF0aW9uT3BzLCBWZWN0b3JPcHMgfSBmcm9tIFwiLi4vbWF0aFwiO1xuaW1wb3J0IHsgQ29sbGlkZXIgfSBmcm9tIFwiLi9jb2xsaWRlclwiO1xuLyoqXG4gKiBBIHNldCBvZiByaWdpZCBib2RpZXMgdGhhdCBjYW4gYmUgaGFuZGxlZCBieSBhIHBoeXNpY3MgcGlwZWxpbmUuXG4gKlxuICogVG8gYXZvaWQgbGVha2luZyBXQVNNIHJlc291cmNlcywgdGhpcyBNVVNUIGJlIGZyZWVkIG1hbnVhbGx5IHdpdGggYGNvbGxpZGVyU2V0LmZyZWUoKWBcbiAqIG9uY2UgeW91IGFyZSBkb25lIHVzaW5nIGl0IChhbmQgYWxsIHRoZSByaWdpZC1ib2RpZXMgaXQgY3JlYXRlZCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2xsaWRlclNldCB7XG4gICAgY29uc3RydWN0b3IocmF3KSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3IHx8IG5ldyBSYXdDb2xsaWRlclNldCgpO1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBDb2FyZW5hKCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1hcCB3aXRoIHRoZSBleGlzdGluZyBlbGVtZW50cywgaWYgYW55LlxuICAgICAgICBpZiAocmF3KSB7XG4gICAgICAgICAgICByYXcuZm9yRWFjaENvbGxpZGVySGFuZGxlKChoYW5kbGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXQoaGFuZGxlLCBuZXcgQ29sbGlkZXIodGhpcywgaGFuZGxlLCBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBXQVNNIG1lbW9yeSBvY2N1cGllZCBieSB0aGlzIGNvbGxpZGVyIHNldC5cbiAgICAgKi9cbiAgICBmcmVlKCkge1xuICAgICAgICBpZiAoISF0aGlzLnJhdykge1xuICAgICAgICAgICAgdGhpcy5yYXcuZnJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmF3ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoISF0aGlzLm1hcCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNhc3RDbG9zdXJlKGYpIHtcbiAgICAgICAgcmV0dXJuIChoYW5kbGUpID0+IHtcbiAgICAgICAgICAgIGlmICghIWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZih0aGlzLmdldChoYW5kbGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmaW5hbGl6ZURlc2VyaWFsaXphdGlvbihib2RpZXMpIHtcbiAgICAgICAgdGhpcy5tYXAuZm9yRWFjaCgoY29sbGlkZXIpID0+IGNvbGxpZGVyLmZpbmFsaXplRGVzZXJpYWxpemF0aW9uKGJvZGllcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGxpZGVyIGFuZCByZXR1cm4gaXRzIGludGVnZXIgaGFuZGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJvZGllcyAtIFRoZSBzZXQgb2YgYm9kaWVzIHdoZXJlIHRoZSBjb2xsaWRlcidzIHBhcmVudCBjYW4gYmUgZm91bmQuXG4gICAgICogQHBhcmFtIGRlc2MgLSBUaGUgY29sbGlkZXIncyBkZXNjcmlwdGlvbi5cbiAgICAgKiBAcGFyYW0gcGFyZW50SGFuZGxlIC0gVGhlIGludGVnZXIgaGFuZGxlIG9mIHRoZSByaWdpZC1ib2R5IHRoaXMgY29sbGlkZXIgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgY3JlYXRlQ29sbGlkZXIoYm9kaWVzLCBkZXNjLCBwYXJlbnRIYW5kbGUpIHtcbiAgICAgICAgbGV0IGhhc1BhcmVudCA9IHBhcmVudEhhbmRsZSAhPSB1bmRlZmluZWQgJiYgcGFyZW50SGFuZGxlICE9IG51bGw7XG4gICAgICAgIGlmIChoYXNQYXJlbnQgJiYgaXNOYU4ocGFyZW50SGFuZGxlKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIGNvbGxpZGVyIHdpdGggYSBwYXJlbnQgcmlnaWQtYm9keSBoYW5kbGUgdGhhdCBpcyBub3QgYSBudW1iZXIuXCIpO1xuICAgICAgICBsZXQgcmF3U2hhcGUgPSBkZXNjLnNoYXBlLmludG9SYXcoKTtcbiAgICAgICAgbGV0IHJhd1RyYSA9IFZlY3Rvck9wcy5pbnRvUmF3KGRlc2MudHJhbnNsYXRpb24pO1xuICAgICAgICBsZXQgcmF3Um90ID0gUm90YXRpb25PcHMuaW50b1JhdyhkZXNjLnJvdGF0aW9uKTtcbiAgICAgICAgbGV0IHJhd0NvbSA9IFZlY3Rvck9wcy5pbnRvUmF3KGRlc2MuY2VudGVyT2ZNYXNzKTtcbiAgICAgICAgbGV0IGhhbmRsZSA9IHRoaXMucmF3LmNyZWF0ZUNvbGxpZGVyKGRlc2MuZW5hYmxlZCwgcmF3U2hhcGUsIHJhd1RyYSwgcmF3Um90LCBkZXNjLm1hc3NQcm9wc01vZGUsIGRlc2MubWFzcywgcmF3Q29tLCBcbiAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgZGVzYy5wcmluY2lwYWxBbmd1bGFySW5lcnRpYSwgXG4gICAgICAgIC8vICNlbmRpZlxuICAgICAgICBkZXNjLmRlbnNpdHksIGRlc2MuZnJpY3Rpb24sIGRlc2MucmVzdGl0dXRpb24sIGRlc2MuZnJpY3Rpb25Db21iaW5lUnVsZSwgZGVzYy5yZXN0aXR1dGlvbkNvbWJpbmVSdWxlLCBkZXNjLmlzU2Vuc29yLCBkZXNjLmNvbGxpc2lvbkdyb3VwcywgZGVzYy5zb2x2ZXJHcm91cHMsIGRlc2MuYWN0aXZlQ29sbGlzaW9uVHlwZXMsIGRlc2MuYWN0aXZlSG9va3MsIGRlc2MuYWN0aXZlRXZlbnRzLCBkZXNjLmNvbnRhY3RGb3JjZUV2ZW50VGhyZXNob2xkLCBkZXNjLmNvbnRhY3RTa2luLCBoYXNQYXJlbnQsIGhhc1BhcmVudCA/IHBhcmVudEhhbmRsZSA6IDAsIGJvZGllcy5yYXcpO1xuICAgICAgICByYXdTaGFwZS5mcmVlKCk7XG4gICAgICAgIHJhd1RyYS5mcmVlKCk7XG4gICAgICAgIHJhd1JvdC5mcmVlKCk7XG4gICAgICAgIHJhd0NvbS5mcmVlKCk7XG4gICAgICAgIGxldCBwYXJlbnQgPSBoYXNQYXJlbnQgPyBib2RpZXMuZ2V0KHBhcmVudEhhbmRsZSkgOiBudWxsO1xuICAgICAgICBsZXQgY29sbGlkZXIgPSBuZXcgQ29sbGlkZXIodGhpcywgaGFuZGxlLCBwYXJlbnQsIGRlc2Muc2hhcGUpO1xuICAgICAgICB0aGlzLm1hcC5zZXQoaGFuZGxlLCBjb2xsaWRlcik7XG4gICAgICAgIHJldHVybiBjb2xsaWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY29sbGlkZXIgZnJvbSB0aGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgaW50ZWdlciBoYW5kbGUgb2YgdGhlIGNvbGxpZGVyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gYm9kaWVzIC0gVGhlIHNldCBvZiByaWdpZC1ib2R5IGNvbnRhaW5pbmcgdGhlIHJpZ2lkLWJvZHkgdGhlIGNvbGxpZGVyIGlzIGF0dGFjaGVkIHRvLlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBJZiBgdHJ1ZWAsIHRoZSByaWdpZC1ib2R5IHRoZSByZW1vdmVkIGNvbGxpZGVyIGlzIGF0dGFjaGVkIHRvIHdpbGwgYmUgd29rZW4tdXAgYXV0b21hdGljYWxseS5cbiAgICAgKi9cbiAgICByZW1vdmUoaGFuZGxlLCBpc2xhbmRzLCBib2RpZXMsIHdha2VVcCkge1xuICAgICAgICB0aGlzLnJhdy5yZW1vdmUoaGFuZGxlLCBpc2xhbmRzLnJhdywgYm9kaWVzLnJhdywgd2FrZVVwKTtcbiAgICAgICAgdGhpcy51bm1hcChoYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiwgZG8gbm90IGNhbGwgZGlyZWN0bHkuXG4gICAgICogQHBhcmFtIGhhbmRsZVxuICAgICAqL1xuICAgIHVubWFwKGhhbmRsZSkge1xuICAgICAgICB0aGlzLm1hcC5kZWxldGUoaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmlnaWQtYm9keSB3aXRoIHRoZSBnaXZlbiBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlIC0gVGhlIGhhbmRsZSBvZiB0aGUgcmlnaWQtYm9keSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBnZXQoaGFuZGxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXQoaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBjb2xsaWRlcnMgb24gdGhpcyBzZXQuXG4gICAgICovXG4gICAgbGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAubGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvZXMgdGhpcyBzZXQgY29udGFpbiBhIGNvbGxpZGVyIHdpdGggdGhlIGdpdmVuIGhhbmRsZT9cbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGUgLSBUaGUgY29sbGlkZXIgaGFuZGxlIHRvIGNoZWNrLlxuICAgICAqL1xuICAgIGNvbnRhaW5zKGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoaGFuZGxlKSAhPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBjbG9zdXJlIHRvIGVhY2ggY29sbGlkZXIgY29udGFpbmVkIGJ5IHRoaXMgc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGYgLSBUaGUgY2xvc3VyZSB0byBhcHBseS5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgdGhpcy5tYXAuZm9yRWFjaChmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgY29sbGlkZXJzIGluIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgY29sbGlkZXIgbGlzdC5cbiAgICAgKi9cbiAgICBnZXRBbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRBbGwoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xsaWRlcl9zZXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/collider_set.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/contact.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/contact.js ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShapeContact: () => (/* binding */ ShapeContact)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The contact info between two shapes.\n */\nclass ShapeContact {\n    constructor(dist, point1, point2, normal1, normal2) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeContact(raw.distance(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=contact.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L2NvbnRhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw0Q0FBUyx3QkFBd0IsNENBQVMsd0JBQXdCLDRDQUFTLHlCQUF5Qiw0Q0FBUztBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGdlb21ldHJ5XFxjb250YWN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3Rvck9wcyB9IGZyb20gXCIuLi9tYXRoXCI7XG4vKipcbiAqIFRoZSBjb250YWN0IGluZm8gYmV0d2VlbiB0d28gc2hhcGVzLlxuICovXG5leHBvcnQgY2xhc3MgU2hhcGVDb250YWN0IHtcbiAgICBjb25zdHJ1Y3RvcihkaXN0LCBwb2ludDEsIHBvaW50Miwgbm9ybWFsMSwgbm9ybWFsMikge1xuICAgICAgICB0aGlzLmRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgdGhpcy5wb2ludDEgPSBwb2ludDE7XG4gICAgICAgIHRoaXMucG9pbnQyID0gcG9pbnQyO1xuICAgICAgICB0aGlzLm5vcm1hbDEgPSBub3JtYWwxO1xuICAgICAgICB0aGlzLm5vcm1hbDIgPSBub3JtYWwyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJhdyhyYXcpIHtcbiAgICAgICAgaWYgKCFyYXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNoYXBlQ29udGFjdChyYXcuZGlzdGFuY2UoKSwgVmVjdG9yT3BzLmZyb21SYXcocmF3LnBvaW50MSgpKSwgVmVjdG9yT3BzLmZyb21SYXcocmF3LnBvaW50MigpKSwgVmVjdG9yT3BzLmZyb21SYXcocmF3Lm5vcm1hbDEoKSksIFZlY3Rvck9wcy5mcm9tUmF3KHJhdy5ub3JtYWwyKCkpKTtcbiAgICAgICAgcmF3LmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/contact.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/feature.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/feature.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeatureType: () => (/* binding */ FeatureType)\n/* harmony export */ });\n// #if DIM2\nvar FeatureType;\n(function (FeatureType) {\n    FeatureType[FeatureType[\"Vertex\"] = 0] = \"Vertex\";\n    FeatureType[FeatureType[\"Face\"] = 1] = \"Face\";\n    FeatureType[FeatureType[\"Unknown\"] = 2] = \"Unknown\";\n})(FeatureType || (FeatureType = {}));\n// #endif\n//# sourceMappingURL=feature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L2ZlYXR1cmUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxcZ2VvbWV0cnlcXGZlYXR1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gI2lmIERJTTJcbmV4cG9ydCB2YXIgRmVhdHVyZVR5cGU7XG4oZnVuY3Rpb24gKEZlYXR1cmVUeXBlKSB7XG4gICAgRmVhdHVyZVR5cGVbRmVhdHVyZVR5cGVbXCJWZXJ0ZXhcIl0gPSAwXSA9IFwiVmVydGV4XCI7XG4gICAgRmVhdHVyZVR5cGVbRmVhdHVyZVR5cGVbXCJGYWNlXCJdID0gMV0gPSBcIkZhY2VcIjtcbiAgICBGZWF0dXJlVHlwZVtGZWF0dXJlVHlwZVtcIlVua25vd25cIl0gPSAyXSA9IFwiVW5rbm93blwiO1xufSkoRmVhdHVyZVR5cGUgfHwgKEZlYXR1cmVUeXBlID0ge30pKTtcbi8vICNlbmRpZlxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmVhdHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/feature.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/index.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.ActiveCollisionTypes),\n/* harmony export */   Ball: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _broad_phase__WEBPACK_IMPORTED_MODULE_0__.BroadPhase),\n/* harmony export */   Capsule: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Capsule),\n/* harmony export */   Collider: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _collider_set__WEBPACK_IMPORTED_MODULE_4__.ColliderSet),\n/* harmony export */   ColliderShapeCastHit: () => (/* reexport safe */ _toi__WEBPACK_IMPORTED_MODULE_8__.ColliderShapeCastHit),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Cuboid),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _feature__WEBPACK_IMPORTED_MODULE_5__.FeatureType),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Heightfield),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.MassPropsMode),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _narrow_phase__WEBPACK_IMPORTED_MODULE_1__.NarrowPhase),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Polyline),\n/* harmony export */   Ray: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.Ray),\n/* harmony export */   RayColliderHit: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayColliderHit),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayColliderIntersection),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayIntersection),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Segment),\n/* harmony export */   Shape: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Shape),\n/* harmony export */   ShapeCastHit: () => (/* reexport safe */ _toi__WEBPACK_IMPORTED_MODULE_8__.ShapeCastHit),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _contact__WEBPACK_IMPORTED_MODULE_9__.ShapeContact),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.ShapeType),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _narrow_phase__WEBPACK_IMPORTED_MODULE_1__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.TriMesh),\n/* harmony export */   TriMeshFlags: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.TriMeshFlags),\n/* harmony export */   Triangle: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Triangle)\n/* harmony export */ });\n/* harmony import */ var _broad_phase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broad_phase */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/broad_phase.js\");\n/* harmony import */ var _narrow_phase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./narrow_phase */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/narrow_phase.js\");\n/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shape */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/shape.js\");\n/* harmony import */ var _collider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./collider */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/collider.js\");\n/* harmony import */ var _collider_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collider_set */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/collider_set.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./feature */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/feature.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ray */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toi */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./contact */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/contact.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_broad_phase__WEBPACK_IMPORTED_MODULE_0__, _narrow_phase__WEBPACK_IMPORTED_MODULE_1__, _shape__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__, _collider_set__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_6__, _point__WEBPACK_IMPORTED_MODULE_7__, _toi__WEBPACK_IMPORTED_MODULE_8__, _contact__WEBPACK_IMPORTED_MODULE_9__]);\n([_broad_phase__WEBPACK_IMPORTED_MODULE_0__, _narrow_phase__WEBPACK_IMPORTED_MODULE_1__, _shape__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__, _collider_set__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_6__, _point__WEBPACK_IMPORTED_MODULE_7__, _toi__WEBPACK_IMPORTED_MODULE_8__, _contact__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThCO0FBQ0M7QUFDUDtBQUNHO0FBQ0k7QUFDTDtBQUNKO0FBQ0U7QUFDRjtBQUNlO0FBQ1g7QUFDMUIsaUMiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxcZ2VvbWV0cnlcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2Jyb2FkX3BoYXNlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9uYXJyb3dfcGhhc2VcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NoYXBlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb2xsaWRlclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29sbGlkZXJfc2V0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9mZWF0dXJlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9yYXlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BvaW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi90b2lcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ludGVyYWN0aW9uX2dyb3Vwc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29udGFjdFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/narrow_phase.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/narrow_phase.js ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NarrowPhase: () => (/* binding */ NarrowPhase),\n/* harmony export */   TempContactManifold: () => (/* binding */ TempContactManifold)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nclass NarrowPhase {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.raw.contact_pairs_with(collider1, f);\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.raw.intersection_pairs_with(collider1, f);\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\nclass TempContactManifold {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    normal() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.normal());\n    }\n    localNormal1() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.local_n1());\n    }\n    localNormal2() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.local_n2());\n    }\n    subshape1() {\n        return this.raw.subshape1();\n    }\n    subshape2() {\n        return this.raw.subshape2();\n    }\n    numContacts() {\n        return this.raw.num_contacts();\n    }\n    localContactPoint1(i) {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n    localContactPoint2(i) {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n    contactDist(i) {\n        return this.raw.contact_dist(i);\n    }\n    contactFid1(i) {\n        return this.raw.contact_fid1(i);\n    }\n    contactFid2(i) {\n        return this.raw.contact_fid2(i);\n    }\n    contactImpulse(i) {\n        return this.raw.contact_impulse(i);\n    }\n    // #if DIM2\n    contactTangentImpulse(i) {\n        return this.raw.contact_tangent_impulse(i);\n    }\n    // #endif\n    numSolverContacts() {\n        return this.raw.num_solver_contacts();\n    }\n    solverContactPoint(i) {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n    solverContactDist(i) {\n        return this.raw.solver_contact_dist(i);\n    }\n    solverContactFriction(i) {\n        return this.raw.solver_contact_friction(i);\n    }\n    solverContactRestitution(i) {\n        return this.raw.solver_contact_restitution(i);\n    }\n    solverContactTangentVelocity(i) {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n//# sourceMappingURL=narrow_phase.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L25hcnJvd19waGFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdDO0FBQ0o7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4QixnREFBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSw0Q0FBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSw0Q0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBUztBQUN4QjtBQUNBO0FBQ0EsZUFBZSw0Q0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQTtBQUNBLHdDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXGdlb21ldHJ5XFxuYXJyb3dfcGhhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF3TmFycm93UGhhc2UgfSBmcm9tIFwiLi4vcmF3XCI7XG5pbXBvcnQgeyBWZWN0b3JPcHMgfSBmcm9tIFwiLi4vbWF0aFwiO1xuLyoqXG4gKiBUaGUgbmFycm93LXBoYXNlIHVzZWQgZm9yIHByZWNpc2UgY29sbGlzaW9uLWRldGVjdGlvbi5cbiAqXG4gKiBUbyBhdm9pZCBsZWFraW5nIFdBU00gcmVzb3VyY2VzLCB0aGlzIE1VU1QgYmUgZnJlZWQgbWFudWFsbHkgd2l0aCBgbmFycm93UGhhc2UuZnJlZSgpYFxuICogb25jZSB5b3UgYXJlIGRvbmUgdXNpbmcgaXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBOYXJyb3dQaGFzZSB7XG4gICAgY29uc3RydWN0b3IocmF3KSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3IHx8IG5ldyBSYXdOYXJyb3dQaGFzZSgpO1xuICAgICAgICB0aGlzLnRlbXBNYW5pZm9sZCA9IG5ldyBUZW1wQ29udGFjdE1hbmlmb2xkKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBXQVNNIG1lbW9yeSBvY2N1cGllZCBieSB0aGlzIG5hcnJvdy1waGFzZS5cbiAgICAgKi9cbiAgICBmcmVlKCkge1xuICAgICAgICBpZiAoISF0aGlzLnJhdykge1xuICAgICAgICAgICAgdGhpcy5yYXcuZnJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmF3ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCB0aGUgY29sbGlkZXJzIHBvdGVudGlhbGx5IGluIGNvbnRhY3Qgd2l0aCB0aGUgZ2l2ZW4gY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sbGlkZXIxIC0gVGhlIHNlY29uZCBjb2xsaWRlciBpbnZvbHZlZCBpbiB0aGUgY29udGFjdC5cbiAgICAgKiBAcGFyYW0gZiAtIENsb3N1cmUgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGNvbGxpZGVyIHRoYXQgaXMgaW4gY29udGFjdCB3aXRoIGBjb2xsaWRlcjFgLlxuICAgICAqL1xuICAgIGNvbnRhY3RQYWlyc1dpdGgoY29sbGlkZXIxLCBmKSB7XG4gICAgICAgIHRoaXMucmF3LmNvbnRhY3RfcGFpcnNfd2l0aChjb2xsaWRlcjEsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCB0aGUgY29sbGlkZXJzIGludGVyc2VjdGluZyB0aGUgZ2l2ZW4gY29sbGlkZXJzLCBhc3N1bWluZyBvbmUgb2YgdGhlbVxuICAgICAqIGlzIGEgc2Vuc29yLlxuICAgICAqL1xuICAgIGludGVyc2VjdGlvblBhaXJzV2l0aChjb2xsaWRlcjEsIGYpIHtcbiAgICAgICAgdGhpcy5yYXcuaW50ZXJzZWN0aW9uX3BhaXJzX3dpdGgoY29sbGlkZXIxLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCBhbGwgdGhlIGNvbnRhY3QgbWFuaWZvbGRzIGJldHdlZW4gdGhlIGdpdmVuIHBhaXIgb2YgY29sbGlkZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVyMSAtIFRoZSBmaXJzdCBjb2xsaWRlciBpbnZvbHZlZCBpbiB0aGUgY29udGFjdC5cbiAgICAgKiBAcGFyYW0gY29sbGlkZXIyIC0gVGhlIHNlY29uZCBjb2xsaWRlciBpbnZvbHZlZCBpbiB0aGUgY29udGFjdC5cbiAgICAgKiBAcGFyYW0gZiAtIENsb3N1cmUgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGNvbnRhY3QgbWFuaWZvbGQgYmV0d2VlbiB0aGUgdHdvIGNvbGxpZGVycy4gSWYgdGhlIHNlY29uZCBhcmd1bWVudFxuICAgICAqICAgICAgICAgICAgcGFzc2VkIHRvIHRoaXMgY2xvc3VyZSBpcyBgdHJ1ZWAsIHRoZW4gdGhlIGNvbnRhY3QgbWFuaWZvbGQgZGF0YSBpcyBmbGlwcGVkLCBpLmUuLCBtZXRob2RzIGxpa2UgYGxvY2FsTm9ybWFsMWBcbiAgICAgKiAgICAgICAgICAgIGFjdHVhbGx5IGFwcGx5IHRvIHRoZSBgY29sbGlkZXIyYCBhbmQgZmllbGRzIGxpa2UgYGxvY2FsTm9ybWFsMmAgYXBwbHkgdG8gdGhlIGBjb2xsaWRlcjFgLlxuICAgICAqL1xuICAgIGNvbnRhY3RQYWlyKGNvbGxpZGVyMSwgY29sbGlkZXIyLCBmKSB7XG4gICAgICAgIGNvbnN0IHJhd1BhaXIgPSB0aGlzLnJhdy5jb250YWN0X3BhaXIoY29sbGlkZXIxLCBjb2xsaWRlcjIpO1xuICAgICAgICBpZiAoISFyYXdQYWlyKSB7XG4gICAgICAgICAgICBjb25zdCBmbGlwcGVkID0gcmF3UGFpci5jb2xsaWRlcjEoKSAhPSBjb2xsaWRlcjE7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByYXdQYWlyLm51bUNvbnRhY3RNYW5pZm9sZHMoKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wTWFuaWZvbGQucmF3ID0gcmF3UGFpci5jb250YWN0TWFuaWZvbGQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKCEhdGhpcy50ZW1wTWFuaWZvbGQucmF3KSB7XG4gICAgICAgICAgICAgICAgICAgIGYodGhpcy50ZW1wTWFuaWZvbGQsIGZsaXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IFRoZSBSYXdDb250YWN0TWFuaWZvbGQgc3RvcmVzIGEgcmF3IHBvaW50ZXIgdGhhdCB3aWxsIGJlIGludmFsaWRhdGVkXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBhdCB0aGUgbmV4dCB0aW1lc3RlcC4gU28gd2UgbXVzdCBiZSBzdXJlIHRvIGZyZWUgdGhlIHBhaXIgaGVyZVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgdG8gYXZvaWQgdW5zb3VuZG5lc3MgaW4gdGhlIFJ1c3QgY29kZS5cbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBNYW5pZm9sZC5mcmVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYXdQYWlyLmZyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgY29sbGlkZXIxYCBhbmQgYGNvbGxpZGVyMmAgaW50ZXJzZWN0IGFuZCBhdCBsZWFzdCBvbmUgb2YgdGhlbSBpcyBhIHNlbnNvci5cbiAgICAgKiBAcGFyYW0gY29sbGlkZXIxIOKIkiBUaGUgZmlyc3QgY29sbGlkZXIgaW52b2x2ZWQgaW4gdGhlIGludGVyc2VjdGlvbi5cbiAgICAgKiBAcGFyYW0gY29sbGlkZXIyIOKIkiBUaGUgc2Vjb25kIGNvbGxpZGVyIGludm9sdmVkIGluIHRoZSBpbnRlcnNlY3Rpb24uXG4gICAgICovXG4gICAgaW50ZXJzZWN0aW9uUGFpcihjb2xsaWRlcjEsIGNvbGxpZGVyMikge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcuaW50ZXJzZWN0aW9uX3BhaXIoY29sbGlkZXIxLCBjb2xsaWRlcjIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUZW1wQ29udGFjdE1hbmlmb2xkIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgfVxuICAgIGZyZWUoKSB7XG4gICAgICAgIGlmICghIXRoaXMucmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5mcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG5vcm1hbCgpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3Lm5vcm1hbCgpKTtcbiAgICB9XG4gICAgbG9jYWxOb3JtYWwxKCkge1xuICAgICAgICByZXR1cm4gVmVjdG9yT3BzLmZyb21SYXcodGhpcy5yYXcubG9jYWxfbjEoKSk7XG4gICAgfVxuICAgIGxvY2FsTm9ybWFsMigpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3LmxvY2FsX24yKCkpO1xuICAgIH1cbiAgICBzdWJzaGFwZTEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5zdWJzaGFwZTEoKTtcbiAgICB9XG4gICAgc3Vic2hhcGUyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcuc3Vic2hhcGUyKCk7XG4gICAgfVxuICAgIG51bUNvbnRhY3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcubnVtX2NvbnRhY3RzKCk7XG4gICAgfVxuICAgIGxvY2FsQ29udGFjdFBvaW50MShpKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyh0aGlzLnJhdy5jb250YWN0X2xvY2FsX3AxKGkpKTtcbiAgICB9XG4gICAgbG9jYWxDb250YWN0UG9pbnQyKGkpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3LmNvbnRhY3RfbG9jYWxfcDIoaSkpO1xuICAgIH1cbiAgICBjb250YWN0RGlzdChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5jb250YWN0X2Rpc3QoaSk7XG4gICAgfVxuICAgIGNvbnRhY3RGaWQxKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3LmNvbnRhY3RfZmlkMShpKTtcbiAgICB9XG4gICAgY29udGFjdEZpZDIoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcuY29udGFjdF9maWQyKGkpO1xuICAgIH1cbiAgICBjb250YWN0SW1wdWxzZShpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5jb250YWN0X2ltcHVsc2UoaSk7XG4gICAgfVxuICAgIC8vICNpZiBESU0yXG4gICAgY29udGFjdFRhbmdlbnRJbXB1bHNlKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3LmNvbnRhY3RfdGFuZ2VudF9pbXB1bHNlKGkpO1xuICAgIH1cbiAgICAvLyAjZW5kaWZcbiAgICBudW1Tb2x2ZXJDb250YWN0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3Lm51bV9zb2x2ZXJfY29udGFjdHMoKTtcbiAgICB9XG4gICAgc29sdmVyQ29udGFjdFBvaW50KGkpIHtcbiAgICAgICAgcmV0dXJuIFZlY3Rvck9wcy5mcm9tUmF3KHRoaXMucmF3LnNvbHZlcl9jb250YWN0X3BvaW50KGkpKTtcbiAgICB9XG4gICAgc29sdmVyQ29udGFjdERpc3QoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcuc29sdmVyX2NvbnRhY3RfZGlzdChpKTtcbiAgICB9XG4gICAgc29sdmVyQ29udGFjdEZyaWN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3LnNvbHZlcl9jb250YWN0X2ZyaWN0aW9uKGkpO1xuICAgIH1cbiAgICBzb2x2ZXJDb250YWN0UmVzdGl0dXRpb24oaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcuc29sdmVyX2NvbnRhY3RfcmVzdGl0dXRpb24oaSk7XG4gICAgfVxuICAgIHNvbHZlckNvbnRhY3RUYW5nZW50VmVsb2NpdHkoaSkge1xuICAgICAgICByZXR1cm4gVmVjdG9yT3BzLmZyb21SYXcodGhpcy5yYXcuc29sdmVyX2NvbnRhY3RfdGFuZ2VudF92ZWxvY2l0eShpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFycm93X3BoYXNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/narrow_phase.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/point.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/point.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointColliderProjection: () => (/* binding */ PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* binding */ PointProjection)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/feature.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/**\n * The projection of a point on a collider.\n */\nclass PointProjection {\n    constructor(point, isInside) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new PointProjection(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point()), raw.isInside());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nclass PointColliderProjection {\n    constructor(collider, point, isInside, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = _feature__WEBPACK_IMPORTED_MODULE_1__.FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new PointColliderProjection(colliderSet.get(raw.colliderHandle()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point()), raw.isInside(), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=point.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L3BvaW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0M7QUFDSTtBQUN4QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRDQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsNENBQVM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxnZW9tZXRyeVxccG9pbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yT3BzIH0gZnJvbSBcIi4uL21hdGhcIjtcbmltcG9ydCB7IEZlYXR1cmVUeXBlIH0gZnJvbSBcIi4vZmVhdHVyZVwiO1xuLyoqXG4gKiBUaGUgcHJvamVjdGlvbiBvZiBhIHBvaW50IG9uIGEgY29sbGlkZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBQb2ludFByb2plY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50LCBpc0luc2lkZSkge1xuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIHRoaXMuaXNJbnNpZGUgPSBpc0luc2lkZTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SYXcocmF3KSB7XG4gICAgICAgIGlmICghcmF3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQb2ludFByb2plY3Rpb24oVmVjdG9yT3BzLmZyb21SYXcocmF3LnBvaW50KCkpLCByYXcuaXNJbnNpZGUoKSk7XG4gICAgICAgIHJhdy5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgcHJvamVjdGlvbiBvZiBhIHBvaW50IG9uIGEgY29sbGlkZXIgKGluY2x1ZGVzIHRoZSBjb2xsaWRlciBoYW5kbGUpLlxuICovXG5leHBvcnQgY2xhc3MgUG9pbnRDb2xsaWRlclByb2plY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbGxpZGVyLCBwb2ludCwgaXNJbnNpZGUsIGZlYXR1cmVUeXBlLCBmZWF0dXJlSWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBnZW9tZXRyaWMgZmVhdHVyZSB0aGUgcG9pbnQgd2FzIHByb2plY3RlZCBvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmVhdHVyZVR5cGUgPSBGZWF0dXJlVHlwZS5Vbmtub3duO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkIG9mIHRoZSBnZW9tZXRyaWMgZmVhdHVyZSB0aGUgcG9pbnQgd2FzIHByb2plY3RlZCBvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmVhdHVyZUlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbGxpZGVyID0gY29sbGlkZXI7XG4gICAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICAgICAgdGhpcy5pc0luc2lkZSA9IGlzSW5zaWRlO1xuICAgICAgICBpZiAoZmVhdHVyZUlkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVJZCA9IGZlYXR1cmVJZDtcbiAgICAgICAgaWYgKGZlYXR1cmVUeXBlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVUeXBlID0gZmVhdHVyZVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmF3KGNvbGxpZGVyU2V0LCByYXcpIHtcbiAgICAgICAgaWYgKCFyYXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFBvaW50Q29sbGlkZXJQcm9qZWN0aW9uKGNvbGxpZGVyU2V0LmdldChyYXcuY29sbGlkZXJIYW5kbGUoKSksIFZlY3Rvck9wcy5mcm9tUmF3KHJhdy5wb2ludCgpKSwgcmF3LmlzSW5zaWRlKCksIHJhdy5mZWF0dXJlVHlwZSgpLCByYXcuZmVhdHVyZUlkKCkpO1xuICAgICAgICByYXcuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvaW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/point.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/ray.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/ray.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ray: () => (/* binding */ Ray),\n/* harmony export */   RayColliderHit: () => (/* binding */ RayColliderHit),\n/* harmony export */   RayColliderIntersection: () => (/* binding */ RayColliderIntersection),\n/* harmony export */   RayIntersection: () => (/* binding */ RayIntersection)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/feature.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_1__]);\n_math__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/**\n * A ray. This is a directed half-line.\n */\nclass Ray {\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin, dir) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n    pointAt(t) {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n        };\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nclass RayIntersection {\n    constructor(timeOfImpact, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = _feature__WEBPACK_IMPORTED_MODULE_0__.FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new RayIntersection(raw.time_of_impact(), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nclass RayColliderIntersection {\n    constructor(collider, timeOfImpact, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = _feature__WEBPACK_IMPORTED_MODULE_0__.FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderIntersection(colliderSet.get(raw.colliderHandle()), raw.time_of_impact(), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The time of impact between a ray and a collider.\n */\nclass RayColliderHit {\n    constructor(collider, timeOfImpact) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderHit(colliderSet.get(raw.colliderHandle()), raw.timeOfImpact());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=ray.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L3JheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBb0M7QUFDSTtBQUN4QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNENBQVM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCw0Q0FBUztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0IiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxcZ2VvbWV0cnlcXHJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3JPcHMgfSBmcm9tIFwiLi4vbWF0aFwiO1xuaW1wb3J0IHsgRmVhdHVyZVR5cGUgfSBmcm9tIFwiLi9mZWF0dXJlXCI7XG4vKipcbiAqIEEgcmF5LiBUaGlzIGlzIGEgZGlyZWN0ZWQgaGFsZi1saW5lLlxuICovXG5leHBvcnQgY2xhc3MgUmF5IHtcbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSByYXkgZnJvbSBpdHMgb3JpZ2luIGFuZCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIHJheSdzIHN0YXJ0aW5nIHBvaW50LlxuICAgICAqIEBwYXJhbSBkaXIgLSBUaGUgcmF5J3MgZGlyZWN0aW9uIG9mIHByb3BhZ2F0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgZGlyKSB7XG4gICAgICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICB9XG4gICAgcG9pbnRBdCh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB0aGlzLm9yaWdpbi54ICsgdGhpcy5kaXIueCAqIHQsXG4gICAgICAgICAgICB5OiB0aGlzLm9yaWdpbi55ICsgdGhpcy5kaXIueSAqIHQsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gYSByYXkgYW5kIGEgY29sbGlkZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXlJbnRlcnNlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRpbWVPZkltcGFjdCwgbm9ybWFsLCBmZWF0dXJlVHlwZSwgZmVhdHVyZUlkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgZ2VvbWV0cmljIGZlYXR1cmUgdGhlIHBvaW50IHdhcyBwcm9qZWN0ZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVUeXBlID0gRmVhdHVyZVR5cGUuVW5rbm93bjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgZ2VvbWV0cmljIGZlYXR1cmUgdGhlIHBvaW50IHdhcyBwcm9qZWN0ZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50aW1lT2ZJbXBhY3QgPSB0aW1lT2ZJbXBhY3Q7XG4gICAgICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgICAgICBpZiAoZmVhdHVyZUlkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVJZCA9IGZlYXR1cmVJZDtcbiAgICAgICAgaWYgKGZlYXR1cmVUeXBlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVUeXBlID0gZmVhdHVyZVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmF3KHJhdykge1xuICAgICAgICBpZiAoIXJhdylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmF5SW50ZXJzZWN0aW9uKHJhdy50aW1lX29mX2ltcGFjdCgpLCBWZWN0b3JPcHMuZnJvbVJhdyhyYXcubm9ybWFsKCkpLCByYXcuZmVhdHVyZVR5cGUoKSwgcmF3LmZlYXR1cmVJZCgpKTtcbiAgICAgICAgcmF3LmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBhIHJheSBhbmQgYSBjb2xsaWRlciAoaW5jbHVkZXMgdGhlIGNvbGxpZGVyIGhhbmRsZSkuXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXlDb2xsaWRlckludGVyc2VjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoY29sbGlkZXIsIHRpbWVPZkltcGFjdCwgbm9ybWFsLCBmZWF0dXJlVHlwZSwgZmVhdHVyZUlkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgZ2VvbWV0cmljIGZlYXR1cmUgdGhlIHBvaW50IHdhcyBwcm9qZWN0ZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVUeXBlID0gRmVhdHVyZVR5cGUuVW5rbm93bjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpZCBvZiB0aGUgZ2VvbWV0cmljIGZlYXR1cmUgdGhlIHBvaW50IHdhcyBwcm9qZWN0ZWQgb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IGNvbGxpZGVyO1xuICAgICAgICB0aGlzLnRpbWVPZkltcGFjdCA9IHRpbWVPZkltcGFjdDtcbiAgICAgICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgICAgIGlmIChmZWF0dXJlSWQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUlkID0gZmVhdHVyZUlkO1xuICAgICAgICBpZiAoZmVhdHVyZVR5cGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZVR5cGUgPSBmZWF0dXJlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SYXcoY29sbGlkZXJTZXQsIHJhdykge1xuICAgICAgICBpZiAoIXJhdylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUmF5Q29sbGlkZXJJbnRlcnNlY3Rpb24oY29sbGlkZXJTZXQuZ2V0KHJhdy5jb2xsaWRlckhhbmRsZSgpKSwgcmF3LnRpbWVfb2ZfaW1wYWN0KCksIFZlY3Rvck9wcy5mcm9tUmF3KHJhdy5ub3JtYWwoKSksIHJhdy5mZWF0dXJlVHlwZSgpLCByYXcuZmVhdHVyZUlkKCkpO1xuICAgICAgICByYXcuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHRpbWUgb2YgaW1wYWN0IGJldHdlZW4gYSByYXkgYW5kIGEgY29sbGlkZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBSYXlDb2xsaWRlckhpdCB7XG4gICAgY29uc3RydWN0b3IoY29sbGlkZXIsIHRpbWVPZkltcGFjdCkge1xuICAgICAgICB0aGlzLmNvbGxpZGVyID0gY29sbGlkZXI7XG4gICAgICAgIHRoaXMudGltZU9mSW1wYWN0ID0gdGltZU9mSW1wYWN0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJhdyhjb2xsaWRlclNldCwgcmF3KSB7XG4gICAgICAgIGlmICghcmF3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBSYXlDb2xsaWRlckhpdChjb2xsaWRlclNldC5nZXQocmF3LmNvbGxpZGVySGFuZGxlKCkpLCByYXcudGltZU9mSW1wYWN0KCkpO1xuICAgICAgICByYXcuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJheS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/ray.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/shape.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/shape.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ball: () => (/* binding */ Ball),\n/* harmony export */   Capsule: () => (/* binding */ Capsule),\n/* harmony export */   ConvexPolygon: () => (/* binding */ ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* binding */ Cuboid),\n/* harmony export */   HalfSpace: () => (/* binding */ HalfSpace),\n/* harmony export */   Heightfield: () => (/* binding */ Heightfield),\n/* harmony export */   Polyline: () => (/* binding */ Polyline),\n/* harmony export */   RoundConvexPolygon: () => (/* binding */ RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* binding */ RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* binding */ RoundTriangle),\n/* harmony export */   Segment: () => (/* binding */ Segment),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   ShapeType: () => (/* binding */ ShapeType),\n/* harmony export */   TriMesh: () => (/* binding */ TriMesh),\n/* harmony export */   TriMeshFlags: () => (/* binding */ TriMeshFlags),\n/* harmony export */   Triangle: () => (/* binding */ Triangle)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contact */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/contact.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./point */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ray */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toi */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/toi.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _toi__WEBPACK_IMPORTED_MODULE_2__, _contact__WEBPACK_IMPORTED_MODULE_3__, _point__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _toi__WEBPACK_IMPORTED_MODULE_2__, _contact__WEBPACK_IMPORTED_MODULE_3__, _point__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\nclass Shape {\n    /**\n     * instant mode without cache\n     */\n    static fromRaw(rawSet, handle) {\n        const rawType = rawSet.coShapeType(handle);\n        let extents;\n        let borderRadius;\n        let vs;\n        let indices;\n        let halfHeight;\n        let radius;\n        let normal;\n        switch (rawType) {\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM2\n                return new Cuboid(extents.x, extents.y);\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM2\n                return new RoundCuboid(extents.x, extents.y, borderRadius);\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n                // #if DIM2\n                return new Segment(_math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(vs[2], vs[3]));\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n                // #if DIM2\n                return new Triangle(_math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(vs[2], vs[3]), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(vs[4], vs[5]));\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM2\n                return new RoundTriangle(_math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(vs[2], vs[3]), _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(vs[4], vs[5]), borderRadius);\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.HalfSpace:\n                normal = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                const tri_flags = rawSet.coTriMeshFlags(handle);\n                return new TriMesh(vs, indices, tri_flags);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n                // #if DIM2\n                return new Heightfield(heights, scale);\n            // #endif\n            // #if DIM2\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.ConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                return new ConvexPolygon(vs, false);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawShapeType.RoundConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolygon(vs, borderRadius, false);\n            // #endif\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, targetDistance, maxToi, stopAtPenetration) {\n        let rawPos1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos1);\n        let rawRot1 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos2);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapeVel2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = _toi__WEBPACK_IMPORTED_MODULE_2__.ShapeCastHit.fromRaw(null, rawShape1.castShape(rawPos1, rawRot1, rawVel1, rawShape2, rawPos2, rawRot2, rawVel2, targetDistance, maxToi, stopAtPenetration));\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they don’t.\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        let rawPos1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos1);\n        let rawRot1 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos2);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = rawShape1.intersectsShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2);\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        let rawPos1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos1);\n        let rawRot1 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos2);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = _contact__WEBPACK_IMPORTED_MODULE_3__.ShapeContact.fromRaw(rawShape1.contactShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    containsPoint(shapePos, shapeRot, point) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    projectPoint(shapePos, shapeRot, point, solid) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = _point__WEBPACK_IMPORTED_MODULE_4__.PointProjection.fromRaw(rawShape.projectPoint(rawPos, rawRot, rawPoint, solid));\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    intersectsRay(ray, shapePos, shapeRot, maxToi) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawRayDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.intersectsRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRay(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawRayDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.castRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRayAndGetNormal(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawRayDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = _ray__WEBPACK_IMPORTED_MODULE_5__.RayIntersection.fromRaw(rawShape.castRayAndGetNormal(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid));\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n}\n// #if DIM2\n/**\n * An enumeration representing the type of a shape.\n */\nvar ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Ball\"] = 0] = \"Ball\";\n    ShapeType[ShapeType[\"Cuboid\"] = 1] = \"Cuboid\";\n    ShapeType[ShapeType[\"Capsule\"] = 2] = \"Capsule\";\n    ShapeType[ShapeType[\"Segment\"] = 3] = \"Segment\";\n    ShapeType[ShapeType[\"Polyline\"] = 4] = \"Polyline\";\n    ShapeType[ShapeType[\"Triangle\"] = 5] = \"Triangle\";\n    ShapeType[ShapeType[\"TriMesh\"] = 6] = \"TriMesh\";\n    ShapeType[ShapeType[\"HeightField\"] = 7] = \"HeightField\";\n    // Compound = 8,\n    ShapeType[ShapeType[\"ConvexPolygon\"] = 9] = \"ConvexPolygon\";\n    ShapeType[ShapeType[\"RoundCuboid\"] = 10] = \"RoundCuboid\";\n    ShapeType[ShapeType[\"RoundTriangle\"] = 11] = \"RoundTriangle\";\n    ShapeType[ShapeType[\"RoundConvexPolygon\"] = 12] = \"RoundConvexPolygon\";\n    ShapeType[ShapeType[\"HalfSpace\"] = 13] = \"HalfSpace\";\n})(ShapeType || (ShapeType = {}));\n// #endif\n// NOTE: this **must** match the TriMeshFlags on the rust side.\n/**\n * Flags controlling the behavior of the triangle mesh creation and of some\n * operations involving triangle meshes.\n */\nvar TriMeshFlags;\n(function (TriMeshFlags) {\n    // NOTE: these two flags are not really useful in JS.\n    //\n    // /**\n    //  * If set, the half-edge topology of the trimesh will be computed if possible.\n    //  */\n    // HALF_EDGE_TOPOLOGY = 0b0000_0001,\n    // /** If set, the half-edge topology and connected components of the trimesh will be computed if possible.\n    //  *\n    //  * Because of the way it is currently implemented, connected components can only be computed on\n    //  * a mesh where the half-edge topology computation succeeds. It will no longer be the case in the\n    //  * future once we decouple the computations.\n    //  */\n    // CONNECTED_COMPONENTS = 0b0000_0010,\n    /**\n     * If set, any triangle that results in a failing half-hedge topology computation will be deleted.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_BAD_TOPOLOGY_TRIANGLES\"] = 4] = \"DELETE_BAD_TOPOLOGY_TRIANGLES\";\n    /**\n     * If set, the trimesh will be assumed to be oriented (with outward normals).\n     *\n     * The pseudo-normals of its vertices and edges will be computed.\n     */\n    TriMeshFlags[TriMeshFlags[\"ORIENTED\"] = 8] = \"ORIENTED\";\n    /**\n     * If set, the duplicate vertices of the trimesh will be merged.\n     *\n     * Two vertices with the exact same coordinates will share the same entry on the\n     * vertex buffer and the index buffer is adjusted accordingly.\n     */\n    TriMeshFlags[TriMeshFlags[\"MERGE_DUPLICATE_VERTICES\"] = 16] = \"MERGE_DUPLICATE_VERTICES\";\n    /**\n     * If set, the triangles sharing two vertices with identical index values will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_DEGENERATE_TRIANGLES\"] = 32] = \"DELETE_DEGENERATE_TRIANGLES\";\n    /**\n     * If set, two triangles sharing three vertices with identical index values (in any order)\n     * will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_DUPLICATE_TRIANGLES\"] = 64] = \"DELETE_DUPLICATE_TRIANGLES\";\n    /**\n     * If set, a special treatment will be applied to contact manifold calculation to eliminate\n     * or fix contacts normals that could lead to incorrect bumps in physics simulation\n     * (especially on flat surfaces).\n     *\n     * This is achieved by taking into account adjacent triangle normals when computing contact\n     * points for a given triangle.\n     *\n     * /!\\ NOT SUPPORTED IN THE 2D VERSION OF RAPIER.\n     */\n    TriMeshFlags[TriMeshFlags[\"FIX_INTERNAL_EDGES\"] = 152] = \"FIX_INTERNAL_EDGES\";\n})(TriMeshFlags || (TriMeshFlags = {}));\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nclass Ball extends Shape {\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius) {\n        super();\n        this.type = ShapeType.Ball;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.ball(this.radius);\n    }\n}\nclass HalfSpace extends Shape {\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal) {\n        super();\n        this.type = ShapeType.HalfSpace;\n        this.normal = normal;\n    }\n    intoRaw() {\n        let n = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.normal);\n        let result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nclass Cuboid extends Shape {\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     */\n    constructor(hx, hy) {\n        super();\n        this.type = ShapeType.Cuboid;\n        this.halfExtents = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(hx, hy);\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM2\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.cuboid(this.halfExtents.x, this.halfExtents.y);\n        // #endif\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nclass RoundCuboid extends Shape {\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx, hy, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCuboid;\n        this.halfExtents = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.new(hx, hy);\n        this.borderRadius = borderRadius;\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM2\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.borderRadius);\n        // #endif\n    }\n}\n/**\n * A shape that is a capsule.\n */\nclass Capsule extends Shape {\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Capsule;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a segment.\n */\nclass Segment extends Shape {\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a, b) {\n        super();\n        this.type = ShapeType.Segment;\n        this.a = a;\n        this.b = b;\n    }\n    intoRaw() {\n        let ra = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.a);\n        let rb = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.b);\n        let result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n/**\n * A shape that is a segment.\n */\nclass Triangle extends Shape {\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a, b, c) {\n        super();\n        this.type = ShapeType.Triangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    intoRaw() {\n        let ra = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.a);\n        let rb = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.b);\n        let rc = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.c);\n        let result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nclass RoundTriangle extends Shape {\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a, b, c, borderRadius) {\n        super();\n        this.type = ShapeType.RoundTriangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        let ra = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.a);\n        let rb = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.b);\n        let rc = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.c);\n        let result = _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nclass Polyline extends Shape {\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.Polyline;\n        this.vertices = vertices;\n        this.indices = indices !== null && indices !== void 0 ? indices : new Uint32Array(0);\n    }\n    intoRaw() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.polyline(this.vertices, this.indices);\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nclass TriMesh extends Shape {\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices, indices, flags) {\n        super();\n        this.type = ShapeType.TriMesh;\n        this.vertices = vertices;\n        this.indices = indices;\n        this.flags = flags;\n    }\n    intoRaw() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.trimesh(this.vertices, this.indices, this.flags);\n    }\n}\n// #if DIM2\n/**\n * A shape that is a convex polygon.\n */\nclass ConvexPolygon extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(vertices, skipConvexHullComputation) {\n        super();\n        this.type = ShapeType.ConvexPolygon;\n        this.vertices = vertices;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n    intoRaw() {\n        if (this.skipConvexHullComputation) {\n            return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.convexPolyline(this.vertices);\n        }\n        else {\n            return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.convexHull(this.vertices);\n        }\n    }\n}\n/**\n * A shape that is a convex polygon.\n */\nclass RoundConvexPolygon extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param borderRadius - The radius of the borders of this convex polygon.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(vertices, borderRadius, skipConvexHullComputation) {\n        super();\n        this.type = ShapeType.RoundConvexPolygon;\n        this.vertices = vertices;\n        this.borderRadius = borderRadius;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n    intoRaw() {\n        if (this.skipConvexHullComputation) {\n            return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.roundConvexPolyline(this.vertices, this.borderRadius);\n        }\n        else {\n            return _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n/**\n * A shape that is a heightfield.\n */\nclass Heightfield extends Shape {\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    constructor(heights, scale) {\n        super();\n        this.type = ShapeType.HeightField;\n        this.heights = heights;\n        this.scale = scale;\n    }\n    intoRaw() {\n        let rawScale = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(this.scale);\n        let rawShape = _raw__WEBPACK_IMPORTED_MODULE_0__.RawShape.heightfield(this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n// #endif\n//# sourceMappingURL=shape.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L3NoYXBlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDRDtBQUNQO0FBQ0M7QUFDRjtBQUNIO0FBQzlCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQTtBQUNBLG1DQUFtQyw0Q0FBUyxvQkFBb0IsNENBQVM7QUFDekU7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFZO0FBQzdCO0FBQ0E7QUFDQSxvQ0FBb0MsNENBQVMsb0JBQW9CLDRDQUFTLG9CQUFvQiw0Q0FBUztBQUN2RztBQUNBLGlCQUFpQiw4Q0FBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNENBQVMsb0JBQW9CLDRDQUFTLG9CQUFvQiw0Q0FBUztBQUM1RztBQUNBLGlCQUFpQiw4Q0FBWTtBQUM3Qix5QkFBeUIsNENBQVM7QUFDbEM7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFZO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsOENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0Isc0JBQXNCLDhDQUFXO0FBQ2pDLHNCQUFzQiw0Q0FBUztBQUMvQixzQkFBc0IsNENBQVM7QUFDL0Isc0JBQXNCLDhDQUFXO0FBQ2pDLHNCQUFzQiw0Q0FBUztBQUMvQjtBQUNBO0FBQ0EscUJBQXFCLDhDQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBUztBQUMvQixzQkFBc0IsOENBQVc7QUFDakMsc0JBQXNCLDRDQUFTO0FBQy9CLHNCQUFzQiw4Q0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUFTO0FBQy9CLHNCQUFzQiw4Q0FBVztBQUNqQyxzQkFBc0IsNENBQVM7QUFDL0Isc0JBQXNCLDhDQUFXO0FBQ2pDO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUFTO0FBQzlCLHFCQUFxQiw4Q0FBVztBQUNoQyx1QkFBdUIsNENBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUFTO0FBQzlCLHFCQUFxQiw4Q0FBVztBQUNoQyx1QkFBdUIsNENBQVM7QUFDaEM7QUFDQSxxQkFBcUIsbURBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVM7QUFDOUIscUJBQXFCLDhDQUFXO0FBQ2hDLHlCQUF5Qiw0Q0FBUztBQUNsQyx3QkFBd0IsNENBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVM7QUFDOUIscUJBQXFCLDhDQUFXO0FBQ2hDLHlCQUF5Qiw0Q0FBUztBQUNsQyx3QkFBd0IsNENBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVM7QUFDOUIscUJBQXFCLDhDQUFXO0FBQ2hDLHlCQUF5Qiw0Q0FBUztBQUNsQyx3QkFBd0IsNENBQVM7QUFDakM7QUFDQSxxQkFBcUIsaURBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBUTtBQUN2QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFTO0FBQ3pCLHFCQUFxQiwwQ0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRDQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQ0FBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNENBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMENBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBUztBQUMxQixpQkFBaUIsNENBQVM7QUFDMUIscUJBQXFCLDBDQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBUztBQUMxQixpQkFBaUIsNENBQVM7QUFDMUIsaUJBQWlCLDRDQUFTO0FBQzFCLHFCQUFxQiwwQ0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBUztBQUMxQixpQkFBaUIsNENBQVM7QUFDMUIsaUJBQWlCLDRDQUFTO0FBQzFCLHFCQUFxQiwwQ0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQVE7QUFDM0I7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBUTtBQUMzQjtBQUNBO0FBQ0EsbUJBQW1CLDBDQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQVM7QUFDaEMsdUJBQXVCLDBDQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxnZW9tZXRyeVxcc2hhcGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yT3BzLCBSb3RhdGlvbk9wcyB9IGZyb20gXCIuLi9tYXRoXCI7XG5pbXBvcnQgeyBSYXdTaGFwZSwgUmF3U2hhcGVUeXBlIH0gZnJvbSBcIi4uL3Jhd1wiO1xuaW1wb3J0IHsgU2hhcGVDb250YWN0IH0gZnJvbSBcIi4vY29udGFjdFwiO1xuaW1wb3J0IHsgUG9pbnRQcm9qZWN0aW9uIH0gZnJvbSBcIi4vcG9pbnRcIjtcbmltcG9ydCB7IFJheUludGVyc2VjdGlvbiB9IGZyb20gXCIuL3JheVwiO1xuaW1wb3J0IHsgU2hhcGVDYXN0SGl0IH0gZnJvbSBcIi4vdG9pXCI7XG5leHBvcnQgY2xhc3MgU2hhcGUge1xuICAgIC8qKlxuICAgICAqIGluc3RhbnQgbW9kZSB3aXRob3V0IGNhY2hlXG4gICAgICovXG4gICAgc3RhdGljIGZyb21SYXcocmF3U2V0LCBoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmF3VHlwZSA9IHJhd1NldC5jb1NoYXBlVHlwZShoYW5kbGUpO1xuICAgICAgICBsZXQgZXh0ZW50cztcbiAgICAgICAgbGV0IGJvcmRlclJhZGl1cztcbiAgICAgICAgbGV0IHZzO1xuICAgICAgICBsZXQgaW5kaWNlcztcbiAgICAgICAgbGV0IGhhbGZIZWlnaHQ7XG4gICAgICAgIGxldCByYWRpdXM7XG4gICAgICAgIGxldCBub3JtYWw7XG4gICAgICAgIHN3aXRjaCAocmF3VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBSYXdTaGFwZVR5cGUuQmFsbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJhbGwocmF3U2V0LmNvUmFkaXVzKGhhbmRsZSkpO1xuICAgICAgICAgICAgY2FzZSBSYXdTaGFwZVR5cGUuQ3Vib2lkOlxuICAgICAgICAgICAgICAgIGV4dGVudHMgPSByYXdTZXQuY29IYWxmRXh0ZW50cyhoYW5kbGUpO1xuICAgICAgICAgICAgICAgIC8vICNpZiBESU0yXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdWJvaWQoZXh0ZW50cy54LCBleHRlbnRzLnkpO1xuICAgICAgICAgICAgLy8gI2VuZGlmXG4gICAgICAgICAgICBjYXNlIFJhd1NoYXBlVHlwZS5Sb3VuZEN1Ym9pZDpcbiAgICAgICAgICAgICAgICBleHRlbnRzID0gcmF3U2V0LmNvSGFsZkV4dGVudHMoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXMgPSByYXdTZXQuY29Sb3VuZFJhZGl1cyhoYW5kbGUpO1xuICAgICAgICAgICAgICAgIC8vICNpZiBESU0yXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSb3VuZEN1Ym9pZChleHRlbnRzLngsIGV4dGVudHMueSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgICAgIC8vICNlbmRpZlxuICAgICAgICAgICAgY2FzZSBSYXdTaGFwZVR5cGUuQ2Fwc3VsZTpcbiAgICAgICAgICAgICAgICBoYWxmSGVpZ2h0ID0gcmF3U2V0LmNvSGFsZkhlaWdodChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHJhZGl1cyA9IHJhd1NldC5jb1JhZGl1cyhoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2Fwc3VsZShoYWxmSGVpZ2h0LCByYWRpdXMpO1xuICAgICAgICAgICAgY2FzZSBSYXdTaGFwZVR5cGUuU2VnbWVudDpcbiAgICAgICAgICAgICAgICB2cyA9IHJhd1NldC5jb1ZlcnRpY2VzKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlZ21lbnQoVmVjdG9yT3BzLm5ldyh2c1swXSwgdnNbMV0pLCBWZWN0b3JPcHMubmV3KHZzWzJdLCB2c1szXSkpO1xuICAgICAgICAgICAgLy8gI2VuZGlmXG4gICAgICAgICAgICBjYXNlIFJhd1NoYXBlVHlwZS5Qb2x5bGluZTpcbiAgICAgICAgICAgICAgICB2cyA9IHJhd1NldC5jb1ZlcnRpY2VzKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcyA9IHJhd1NldC5jb0luZGljZXMoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lKHZzLCBpbmRpY2VzKTtcbiAgICAgICAgICAgIGNhc2UgUmF3U2hhcGVUeXBlLlRyaWFuZ2xlOlxuICAgICAgICAgICAgICAgIHZzID0gcmF3U2V0LmNvVmVydGljZXMoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAvLyAjaWYgRElNMlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJpYW5nbGUoVmVjdG9yT3BzLm5ldyh2c1swXSwgdnNbMV0pLCBWZWN0b3JPcHMubmV3KHZzWzJdLCB2c1szXSksIFZlY3Rvck9wcy5uZXcodnNbNF0sIHZzWzVdKSk7XG4gICAgICAgICAgICAvLyAjZW5kaWZcbiAgICAgICAgICAgIGNhc2UgUmF3U2hhcGVUeXBlLlJvdW5kVHJpYW5nbGU6XG4gICAgICAgICAgICAgICAgdnMgPSByYXdTZXQuY29WZXJ0aWNlcyhoYW5kbGUpO1xuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1cyA9IHJhd1NldC5jb1JvdW5kUmFkaXVzKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJvdW5kVHJpYW5nbGUoVmVjdG9yT3BzLm5ldyh2c1swXSwgdnNbMV0pLCBWZWN0b3JPcHMubmV3KHZzWzJdLCB2c1szXSksIFZlY3Rvck9wcy5uZXcodnNbNF0sIHZzWzVdKSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgICAgIC8vICNlbmRpZlxuICAgICAgICAgICAgY2FzZSBSYXdTaGFwZVR5cGUuSGFsZlNwYWNlOlxuICAgICAgICAgICAgICAgIG5vcm1hbCA9IFZlY3Rvck9wcy5mcm9tUmF3KHJhd1NldC5jb0hhbGZzcGFjZU5vcm1hbChoYW5kbGUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhhbGZTcGFjZShub3JtYWwpO1xuICAgICAgICAgICAgY2FzZSBSYXdTaGFwZVR5cGUuVHJpTWVzaDpcbiAgICAgICAgICAgICAgICB2cyA9IHJhd1NldC5jb1ZlcnRpY2VzKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcyA9IHJhd1NldC5jb0luZGljZXMoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmlfZmxhZ3MgPSByYXdTZXQuY29UcmlNZXNoRmxhZ3MoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyaU1lc2godnMsIGluZGljZXMsIHRyaV9mbGFncyk7XG4gICAgICAgICAgICBjYXNlIFJhd1NoYXBlVHlwZS5IZWlnaHRGaWVsZDpcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IHJhd1NldC5jb0hlaWdodGZpZWxkU2NhbGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHRzID0gcmF3U2V0LmNvSGVpZ2h0ZmllbGRIZWlnaHRzKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhlaWdodGZpZWxkKGhlaWdodHMsIHNjYWxlKTtcbiAgICAgICAgICAgIC8vICNlbmRpZlxuICAgICAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgICAgIGNhc2UgUmF3U2hhcGVUeXBlLkNvbnZleFBvbHlnb246XG4gICAgICAgICAgICAgICAgdnMgPSByYXdTZXQuY29WZXJ0aWNlcyhoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udmV4UG9seWdvbih2cywgZmFsc2UpO1xuICAgICAgICAgICAgY2FzZSBSYXdTaGFwZVR5cGUuUm91bmRDb252ZXhQb2x5Z29uOlxuICAgICAgICAgICAgICAgIHZzID0gcmF3U2V0LmNvVmVydGljZXMoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXMgPSByYXdTZXQuY29Sb3VuZFJhZGl1cyhoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUm91bmRDb252ZXhQb2x5Z29uKHZzLCBib3JkZXJSYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vICNlbmRpZlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHNoYXBlIHR5cGU6IFwiICsgcmF3VHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHRpbWUgb2YgaW1wYWN0IGJldHdlZW4gdHdvIG1vdmluZyBzaGFwZXMuXG4gICAgICogQHBhcmFtIHNoYXBlUG9zMSAtIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoaXMgc2FocGUuXG4gICAgICogQHBhcmFtIHNoYXBlUm90MSAtIFRoZSByb3RhdGlvbiBvZiB0aGlzIHNoYXBlLlxuICAgICAqIEBwYXJhbSBzaGFwZVZlbDEgLSBUaGUgdmVsb2NpdHkgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcGFyYW0gc2hhcGUyIC0gVGhlIHNlY29uZCBtb3Zpbmcgc2hhcGUuXG4gICAgICogQHBhcmFtIHNoYXBlUG9zMiAtIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgc2hhcGUuXG4gICAgICogQHBhcmFtIHNoYXBlUm90MiAtIFRoZSByb3RhdGlvbiBvZiB0aGUgc2Vjb25kIHNoYXBlLlxuICAgICAqIEBwYXJhbSBzaGFwZVZlbDIgLSBUaGUgdmVsb2NpdHkgb2YgdGhlIHNlY29uZCBzaGFwZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0RGlzdGFuY2Ug4oiSIElmIHRoZSBzaGFwZSBtb3ZlcyBjbG9zZXIgdG8gdGhpcyBkaXN0YW5jZSBmcm9tIGEgY29sbGlkZXIsIGEgaGl0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gbWF4VG9pIC0gVGhlIG1heGltdW0gdGltZSB3aGVuIHRoZSBpbXBhY3QgY2FuIGhhcHBlbi5cbiAgICAgKiBAcGFyYW0gc3RvcEF0UGVuZXRyYXRpb24gLSBJZiBzZXQgdG8gYGZhbHNlYCwgdGhlIGxpbmVhciBzaGFwZS1jYXN0IHdvbuKAmXQgaW1tZWRpYXRlbHkgc3RvcCBpZlxuICAgICAqICAgdGhlIHNoYXBlIGlzIHBlbmV0cmF0aW5nIGFub3RoZXIgc2hhcGUgYXQgaXRzIHN0YXJ0aW5nIHBvaW50ICoqYW5kKiogaXRzIHRyYWplY3RvcnkgaXMgc3VjaFxuICAgICAqICAgdGhhdCBpdOKAmXMgb24gYSBwYXRoIHRvIGV4aXQgdGhhdCBwZW5ldHJhdGlvbiBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgdHdvIG1vdmluZyBzaGFwZXMgY29sbGlkZXIgYXQgc29tZSBwb2ludCBhbG9uZyB0aGVpciB0cmFqZWN0b3JpZXMsIHRoaXMgcmV0dXJucyB0aGVcbiAgICAgKiAgdGltZSBhdCB3aGljaCB0aGUgdHdvIHNoYXBlIGNvbGxpZGVyIGFzIHdlbGwgYXMgdGhlIGNvbnRhY3QgaW5mb3JtYXRpb24gZHVyaW5nIHRoZSBpbXBhY3QuIFJldHVybnNcbiAgICAgKiAgYG51bGxgaWYgdGhlIHR3byBzaGFwZXMgbmV2ZXIgY29sbGlkZSBhbG9uZyB0aGVpciBwYXRocy5cbiAgICAgKi9cbiAgICBjYXN0U2hhcGUoc2hhcGVQb3MxLCBzaGFwZVJvdDEsIHNoYXBlVmVsMSwgc2hhcGUyLCBzaGFwZVBvczIsIHNoYXBlUm90Miwgc2hhcGVWZWwyLCB0YXJnZXREaXN0YW5jZSwgbWF4VG9pLCBzdG9wQXRQZW5ldHJhdGlvbikge1xuICAgICAgICBsZXQgcmF3UG9zMSA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlUG9zMSk7XG4gICAgICAgIGxldCByYXdSb3QxID0gUm90YXRpb25PcHMuaW50b1JhdyhzaGFwZVJvdDEpO1xuICAgICAgICBsZXQgcmF3VmVsMSA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlVmVsMSk7XG4gICAgICAgIGxldCByYXdQb3MyID0gVmVjdG9yT3BzLmludG9SYXcoc2hhcGVQb3MyKTtcbiAgICAgICAgbGV0IHJhd1JvdDIgPSBSb3RhdGlvbk9wcy5pbnRvUmF3KHNoYXBlUm90Mik7XG4gICAgICAgIGxldCByYXdWZWwyID0gVmVjdG9yT3BzLmludG9SYXcoc2hhcGVWZWwyKTtcbiAgICAgICAgbGV0IHJhd1NoYXBlMSA9IHRoaXMuaW50b1JhdygpO1xuICAgICAgICBsZXQgcmF3U2hhcGUyID0gc2hhcGUyLmludG9SYXcoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFNoYXBlQ2FzdEhpdC5mcm9tUmF3KG51bGwsIHJhd1NoYXBlMS5jYXN0U2hhcGUocmF3UG9zMSwgcmF3Um90MSwgcmF3VmVsMSwgcmF3U2hhcGUyLCByYXdQb3MyLCByYXdSb3QyLCByYXdWZWwyLCB0YXJnZXREaXN0YW5jZSwgbWF4VG9pLCBzdG9wQXRQZW5ldHJhdGlvbikpO1xuICAgICAgICByYXdQb3MxLmZyZWUoKTtcbiAgICAgICAgcmF3Um90MS5mcmVlKCk7XG4gICAgICAgIHJhd1ZlbDEuZnJlZSgpO1xuICAgICAgICByYXdQb3MyLmZyZWUoKTtcbiAgICAgICAgcmF3Um90Mi5mcmVlKCk7XG4gICAgICAgIHJhd1ZlbDIuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZTEuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZTIuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIHNoYXBlIGludGVyc2VjdHMgYW5vdGhlciBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaGFwZVBvczEgLSBUaGUgcG9zaXRpb24gb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcGFyYW0gc2hhcGVSb3QxIC0gVGhlIHJvdGF0aW9uIG9mIHRoaXMgc2hhcGUuXG4gICAgICogQHBhcmFtIHNoYXBlMiAgLSBUaGUgc2Vjb25kIHNoYXBlIHRvIHRlc3QuXG4gICAgICogQHBhcmFtIHNoYXBlUG9zMiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHNoYXBlLlxuICAgICAqIEBwYXJhbSBzaGFwZVJvdDIgLSBUaGUgcm90YXRpb24gb2YgdGhlIHNlY29uZCBzaGFwZS5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byBzaGFwZXMgaW50ZXJzZWN0LCBgZmFsc2VgIGlmIHRoZXkgZG9u4oCZdC5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzU2hhcGUoc2hhcGVQb3MxLCBzaGFwZVJvdDEsIHNoYXBlMiwgc2hhcGVQb3MyLCBzaGFwZVJvdDIpIHtcbiAgICAgICAgbGV0IHJhd1BvczEgPSBWZWN0b3JPcHMuaW50b1JhdyhzaGFwZVBvczEpO1xuICAgICAgICBsZXQgcmF3Um90MSA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QxKTtcbiAgICAgICAgbGV0IHJhd1BvczIgPSBWZWN0b3JPcHMuaW50b1JhdyhzaGFwZVBvczIpO1xuICAgICAgICBsZXQgcmF3Um90MiA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QyKTtcbiAgICAgICAgbGV0IHJhd1NoYXBlMSA9IHRoaXMuaW50b1JhdygpO1xuICAgICAgICBsZXQgcmF3U2hhcGUyID0gc2hhcGUyLmludG9SYXcoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJhd1NoYXBlMS5pbnRlcnNlY3RzU2hhcGUocmF3UG9zMSwgcmF3Um90MSwgcmF3U2hhcGUyLCByYXdQb3MyLCByYXdSb3QyKTtcbiAgICAgICAgcmF3UG9zMS5mcmVlKCk7XG4gICAgICAgIHJhd1JvdDEuZnJlZSgpO1xuICAgICAgICByYXdQb3MyLmZyZWUoKTtcbiAgICAgICAgcmF3Um90Mi5mcmVlKCk7XG4gICAgICAgIHJhd1NoYXBlMS5mcmVlKCk7XG4gICAgICAgIHJhd1NoYXBlMi5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIG9uZSBwYWlyIG9mIGNvbnRhY3QgcG9pbnRzIGJldHdlZW4gdHdvIHNoYXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaGFwZVBvczEgLSBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGlzIHNhaHBlLlxuICAgICAqIEBwYXJhbSBzaGFwZVJvdDEgLSBUaGUgcm90YXRpb24gb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcGFyYW0gc2hhcGUyIC0gVGhlIHNlY29uZCBzaGFwZS5cbiAgICAgKiBAcGFyYW0gc2hhcGVQb3MyIC0gVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBzaGFwZS5cbiAgICAgKiBAcGFyYW0gc2hhcGVSb3QyIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBzZWNvbmQgc2hhcGUuXG4gICAgICogQHBhcmFtIHByZWRpY3Rpb24gLSBUaGUgcHJlZGljdGlvbiB2YWx1ZSwgaWYgdGhlIHNoYXBlcyBhcmUgc2VwYXJhdGVkIGJ5IGEgZGlzdGFuY2UgZ3JlYXRlciB0aGFuIHRoaXMgdmFsdWUsIHRlc3Qgd2lsbCBmYWlsLlxuICAgICAqIEByZXR1cm5zIGBudWxsYCBpZiB0aGUgc2hhcGVzIGFyZSBzZXBhcmF0ZWQgYnkgYSBkaXN0YW5jZSBncmVhdGVyIHRoYW4gcHJlZGljdGlvbiwgb3RoZXJ3aXNlIGNvbnRhY3QgZGV0YWlscy4gVGhlIHJlc3VsdCBpcyBnaXZlbiBpbiB3b3JsZC1zcGFjZS5cbiAgICAgKi9cbiAgICBjb250YWN0U2hhcGUoc2hhcGVQb3MxLCBzaGFwZVJvdDEsIHNoYXBlMiwgc2hhcGVQb3MyLCBzaGFwZVJvdDIsIHByZWRpY3Rpb24pIHtcbiAgICAgICAgbGV0IHJhd1BvczEgPSBWZWN0b3JPcHMuaW50b1JhdyhzaGFwZVBvczEpO1xuICAgICAgICBsZXQgcmF3Um90MSA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QxKTtcbiAgICAgICAgbGV0IHJhd1BvczIgPSBWZWN0b3JPcHMuaW50b1JhdyhzaGFwZVBvczIpO1xuICAgICAgICBsZXQgcmF3Um90MiA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QyKTtcbiAgICAgICAgbGV0IHJhd1NoYXBlMSA9IHRoaXMuaW50b1JhdygpO1xuICAgICAgICBsZXQgcmF3U2hhcGUyID0gc2hhcGUyLmludG9SYXcoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFNoYXBlQ29udGFjdC5mcm9tUmF3KHJhd1NoYXBlMS5jb250YWN0U2hhcGUocmF3UG9zMSwgcmF3Um90MSwgcmF3U2hhcGUyLCByYXdQb3MyLCByYXdSb3QyLCBwcmVkaWN0aW9uKSk7XG4gICAgICAgIHJhd1BvczEuZnJlZSgpO1xuICAgICAgICByYXdSb3QxLmZyZWUoKTtcbiAgICAgICAgcmF3UG9zMi5mcmVlKCk7XG4gICAgICAgIHJhd1JvdDIuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZTEuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZTIuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb250YWluc1BvaW50KHNoYXBlUG9zLCBzaGFwZVJvdCwgcG9pbnQpIHtcbiAgICAgICAgbGV0IHJhd1BvcyA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlUG9zKTtcbiAgICAgICAgbGV0IHJhd1JvdCA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QpO1xuICAgICAgICBsZXQgcmF3UG9pbnQgPSBWZWN0b3JPcHMuaW50b1Jhdyhwb2ludCk7XG4gICAgICAgIGxldCByYXdTaGFwZSA9IHRoaXMuaW50b1JhdygpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmF3U2hhcGUuY29udGFpbnNQb2ludChyYXdQb3MsIHJhd1JvdCwgcmF3UG9pbnQpO1xuICAgICAgICByYXdQb3MuZnJlZSgpO1xuICAgICAgICByYXdSb3QuZnJlZSgpO1xuICAgICAgICByYXdQb2ludC5mcmVlKCk7XG4gICAgICAgIHJhd1NoYXBlLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcHJvamVjdFBvaW50KHNoYXBlUG9zLCBzaGFwZVJvdCwgcG9pbnQsIHNvbGlkKSB7XG4gICAgICAgIGxldCByYXdQb3MgPSBWZWN0b3JPcHMuaW50b1JhdyhzaGFwZVBvcyk7XG4gICAgICAgIGxldCByYXdSb3QgPSBSb3RhdGlvbk9wcy5pbnRvUmF3KHNoYXBlUm90KTtcbiAgICAgICAgbGV0IHJhd1BvaW50ID0gVmVjdG9yT3BzLmludG9SYXcocG9pbnQpO1xuICAgICAgICBsZXQgcmF3U2hhcGUgPSB0aGlzLmludG9SYXcoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFBvaW50UHJvamVjdGlvbi5mcm9tUmF3KHJhd1NoYXBlLnByb2plY3RQb2ludChyYXdQb3MsIHJhd1JvdCwgcmF3UG9pbnQsIHNvbGlkKSk7XG4gICAgICAgIHJhd1Bvcy5mcmVlKCk7XG4gICAgICAgIHJhd1JvdC5mcmVlKCk7XG4gICAgICAgIHJhd1BvaW50LmZyZWUoKTtcbiAgICAgICAgcmF3U2hhcGUuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpbnRlcnNlY3RzUmF5KHJheSwgc2hhcGVQb3MsIHNoYXBlUm90LCBtYXhUb2kpIHtcbiAgICAgICAgbGV0IHJhd1BvcyA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlUG9zKTtcbiAgICAgICAgbGV0IHJhd1JvdCA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QpO1xuICAgICAgICBsZXQgcmF3UmF5T3JpZyA9IFZlY3Rvck9wcy5pbnRvUmF3KHJheS5vcmlnaW4pO1xuICAgICAgICBsZXQgcmF3UmF5RGlyID0gVmVjdG9yT3BzLmludG9SYXcocmF5LmRpcik7XG4gICAgICAgIGxldCByYXdTaGFwZSA9IHRoaXMuaW50b1JhdygpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcmF3U2hhcGUuaW50ZXJzZWN0c1JheShyYXdQb3MsIHJhd1JvdCwgcmF3UmF5T3JpZywgcmF3UmF5RGlyLCBtYXhUb2kpO1xuICAgICAgICByYXdQb3MuZnJlZSgpO1xuICAgICAgICByYXdSb3QuZnJlZSgpO1xuICAgICAgICByYXdSYXlPcmlnLmZyZWUoKTtcbiAgICAgICAgcmF3UmF5RGlyLmZyZWUoKTtcbiAgICAgICAgcmF3U2hhcGUuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXN0UmF5KHJheSwgc2hhcGVQb3MsIHNoYXBlUm90LCBtYXhUb2ksIHNvbGlkKSB7XG4gICAgICAgIGxldCByYXdQb3MgPSBWZWN0b3JPcHMuaW50b1JhdyhzaGFwZVBvcyk7XG4gICAgICAgIGxldCByYXdSb3QgPSBSb3RhdGlvbk9wcy5pbnRvUmF3KHNoYXBlUm90KTtcbiAgICAgICAgbGV0IHJhd1JheU9yaWcgPSBWZWN0b3JPcHMuaW50b1JhdyhyYXkub3JpZ2luKTtcbiAgICAgICAgbGV0IHJhd1JheURpciA9IFZlY3Rvck9wcy5pbnRvUmF3KHJheS5kaXIpO1xuICAgICAgICBsZXQgcmF3U2hhcGUgPSB0aGlzLmludG9SYXcoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJhd1NoYXBlLmNhc3RSYXkocmF3UG9zLCByYXdSb3QsIHJhd1JheU9yaWcsIHJhd1JheURpciwgbWF4VG9pLCBzb2xpZCk7XG4gICAgICAgIHJhd1Bvcy5mcmVlKCk7XG4gICAgICAgIHJhd1JvdC5mcmVlKCk7XG4gICAgICAgIHJhd1JheU9yaWcuZnJlZSgpO1xuICAgICAgICByYXdSYXlEaXIuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZS5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhc3RSYXlBbmRHZXROb3JtYWwocmF5LCBzaGFwZVBvcywgc2hhcGVSb3QsIG1heFRvaSwgc29saWQpIHtcbiAgICAgICAgbGV0IHJhd1BvcyA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlUG9zKTtcbiAgICAgICAgbGV0IHJhd1JvdCA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QpO1xuICAgICAgICBsZXQgcmF3UmF5T3JpZyA9IFZlY3Rvck9wcy5pbnRvUmF3KHJheS5vcmlnaW4pO1xuICAgICAgICBsZXQgcmF3UmF5RGlyID0gVmVjdG9yT3BzLmludG9SYXcocmF5LmRpcik7XG4gICAgICAgIGxldCByYXdTaGFwZSA9IHRoaXMuaW50b1JhdygpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gUmF5SW50ZXJzZWN0aW9uLmZyb21SYXcocmF3U2hhcGUuY2FzdFJheUFuZEdldE5vcm1hbChyYXdQb3MsIHJhd1JvdCwgcmF3UmF5T3JpZywgcmF3UmF5RGlyLCBtYXhUb2ksIHNvbGlkKSk7XG4gICAgICAgIHJhd1Bvcy5mcmVlKCk7XG4gICAgICAgIHJhd1JvdC5mcmVlKCk7XG4gICAgICAgIHJhd1JheU9yaWcuZnJlZSgpO1xuICAgICAgICByYXdSYXlEaXIuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZS5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8gI2lmIERJTTJcbi8qKlxuICogQW4gZW51bWVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGEgc2hhcGUuXG4gKi9cbmV4cG9ydCB2YXIgU2hhcGVUeXBlO1xuKGZ1bmN0aW9uIChTaGFwZVR5cGUpIHtcbiAgICBTaGFwZVR5cGVbU2hhcGVUeXBlW1wiQmFsbFwiXSA9IDBdID0gXCJCYWxsXCI7XG4gICAgU2hhcGVUeXBlW1NoYXBlVHlwZVtcIkN1Ym9pZFwiXSA9IDFdID0gXCJDdWJvaWRcIjtcbiAgICBTaGFwZVR5cGVbU2hhcGVUeXBlW1wiQ2Fwc3VsZVwiXSA9IDJdID0gXCJDYXBzdWxlXCI7XG4gICAgU2hhcGVUeXBlW1NoYXBlVHlwZVtcIlNlZ21lbnRcIl0gPSAzXSA9IFwiU2VnbWVudFwiO1xuICAgIFNoYXBlVHlwZVtTaGFwZVR5cGVbXCJQb2x5bGluZVwiXSA9IDRdID0gXCJQb2x5bGluZVwiO1xuICAgIFNoYXBlVHlwZVtTaGFwZVR5cGVbXCJUcmlhbmdsZVwiXSA9IDVdID0gXCJUcmlhbmdsZVwiO1xuICAgIFNoYXBlVHlwZVtTaGFwZVR5cGVbXCJUcmlNZXNoXCJdID0gNl0gPSBcIlRyaU1lc2hcIjtcbiAgICBTaGFwZVR5cGVbU2hhcGVUeXBlW1wiSGVpZ2h0RmllbGRcIl0gPSA3XSA9IFwiSGVpZ2h0RmllbGRcIjtcbiAgICAvLyBDb21wb3VuZCA9IDgsXG4gICAgU2hhcGVUeXBlW1NoYXBlVHlwZVtcIkNvbnZleFBvbHlnb25cIl0gPSA5XSA9IFwiQ29udmV4UG9seWdvblwiO1xuICAgIFNoYXBlVHlwZVtTaGFwZVR5cGVbXCJSb3VuZEN1Ym9pZFwiXSA9IDEwXSA9IFwiUm91bmRDdWJvaWRcIjtcbiAgICBTaGFwZVR5cGVbU2hhcGVUeXBlW1wiUm91bmRUcmlhbmdsZVwiXSA9IDExXSA9IFwiUm91bmRUcmlhbmdsZVwiO1xuICAgIFNoYXBlVHlwZVtTaGFwZVR5cGVbXCJSb3VuZENvbnZleFBvbHlnb25cIl0gPSAxMl0gPSBcIlJvdW5kQ29udmV4UG9seWdvblwiO1xuICAgIFNoYXBlVHlwZVtTaGFwZVR5cGVbXCJIYWxmU3BhY2VcIl0gPSAxM10gPSBcIkhhbGZTcGFjZVwiO1xufSkoU2hhcGVUeXBlIHx8IChTaGFwZVR5cGUgPSB7fSkpO1xuLy8gI2VuZGlmXG4vLyBOT1RFOiB0aGlzICoqbXVzdCoqIG1hdGNoIHRoZSBUcmlNZXNoRmxhZ3Mgb24gdGhlIHJ1c3Qgc2lkZS5cbi8qKlxuICogRmxhZ3MgY29udHJvbGxpbmcgdGhlIGJlaGF2aW9yIG9mIHRoZSB0cmlhbmdsZSBtZXNoIGNyZWF0aW9uIGFuZCBvZiBzb21lXG4gKiBvcGVyYXRpb25zIGludm9sdmluZyB0cmlhbmdsZSBtZXNoZXMuXG4gKi9cbmV4cG9ydCB2YXIgVHJpTWVzaEZsYWdzO1xuKGZ1bmN0aW9uIChUcmlNZXNoRmxhZ3MpIHtcbiAgICAvLyBOT1RFOiB0aGVzZSB0d28gZmxhZ3MgYXJlIG5vdCByZWFsbHkgdXNlZnVsIGluIEpTLlxuICAgIC8vXG4gICAgLy8gLyoqXG4gICAgLy8gICogSWYgc2V0LCB0aGUgaGFsZi1lZGdlIHRvcG9sb2d5IG9mIHRoZSB0cmltZXNoIHdpbGwgYmUgY29tcHV0ZWQgaWYgcG9zc2libGUuXG4gICAgLy8gICovXG4gICAgLy8gSEFMRl9FREdFX1RPUE9MT0dZID0gMGIwMDAwXzAwMDEsXG4gICAgLy8gLyoqIElmIHNldCwgdGhlIGhhbGYtZWRnZSB0b3BvbG9neSBhbmQgY29ubmVjdGVkIGNvbXBvbmVudHMgb2YgdGhlIHRyaW1lc2ggd2lsbCBiZSBjb21wdXRlZCBpZiBwb3NzaWJsZS5cbiAgICAvLyAgKlxuICAgIC8vICAqIEJlY2F1c2Ugb2YgdGhlIHdheSBpdCBpcyBjdXJyZW50bHkgaW1wbGVtZW50ZWQsIGNvbm5lY3RlZCBjb21wb25lbnRzIGNhbiBvbmx5IGJlIGNvbXB1dGVkIG9uXG4gICAgLy8gICogYSBtZXNoIHdoZXJlIHRoZSBoYWxmLWVkZ2UgdG9wb2xvZ3kgY29tcHV0YXRpb24gc3VjY2VlZHMuIEl0IHdpbGwgbm8gbG9uZ2VyIGJlIHRoZSBjYXNlIGluIHRoZVxuICAgIC8vICAqIGZ1dHVyZSBvbmNlIHdlIGRlY291cGxlIHRoZSBjb21wdXRhdGlvbnMuXG4gICAgLy8gICovXG4gICAgLy8gQ09OTkVDVEVEX0NPTVBPTkVOVFMgPSAwYjAwMDBfMDAxMCxcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIGFueSB0cmlhbmdsZSB0aGF0IHJlc3VsdHMgaW4gYSBmYWlsaW5nIGhhbGYtaGVkZ2UgdG9wb2xvZ3kgY29tcHV0YXRpb24gd2lsbCBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIFRyaU1lc2hGbGFnc1tUcmlNZXNoRmxhZ3NbXCJERUxFVEVfQkFEX1RPUE9MT0dZX1RSSUFOR0xFU1wiXSA9IDRdID0gXCJERUxFVEVfQkFEX1RPUE9MT0dZX1RSSUFOR0xFU1wiO1xuICAgIC8qKlxuICAgICAqIElmIHNldCwgdGhlIHRyaW1lc2ggd2lsbCBiZSBhc3N1bWVkIHRvIGJlIG9yaWVudGVkICh3aXRoIG91dHdhcmQgbm9ybWFscykuXG4gICAgICpcbiAgICAgKiBUaGUgcHNldWRvLW5vcm1hbHMgb2YgaXRzIHZlcnRpY2VzIGFuZCBlZGdlcyB3aWxsIGJlIGNvbXB1dGVkLlxuICAgICAqL1xuICAgIFRyaU1lc2hGbGFnc1tUcmlNZXNoRmxhZ3NbXCJPUklFTlRFRFwiXSA9IDhdID0gXCJPUklFTlRFRFwiO1xuICAgIC8qKlxuICAgICAqIElmIHNldCwgdGhlIGR1cGxpY2F0ZSB2ZXJ0aWNlcyBvZiB0aGUgdHJpbWVzaCB3aWxsIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIFR3byB2ZXJ0aWNlcyB3aXRoIHRoZSBleGFjdCBzYW1lIGNvb3JkaW5hdGVzIHdpbGwgc2hhcmUgdGhlIHNhbWUgZW50cnkgb24gdGhlXG4gICAgICogdmVydGV4IGJ1ZmZlciBhbmQgdGhlIGluZGV4IGJ1ZmZlciBpcyBhZGp1c3RlZCBhY2NvcmRpbmdseS5cbiAgICAgKi9cbiAgICBUcmlNZXNoRmxhZ3NbVHJpTWVzaEZsYWdzW1wiTUVSR0VfRFVQTElDQVRFX1ZFUlRJQ0VTXCJdID0gMTZdID0gXCJNRVJHRV9EVVBMSUNBVEVfVkVSVElDRVNcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSB0cmlhbmdsZXMgc2hhcmluZyB0d28gdmVydGljZXMgd2l0aCBpZGVudGljYWwgaW5kZXggdmFsdWVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEJlY2F1c2Ugb2YgdGhlIHdheSBpdCBpcyBjdXJyZW50bHkgaW1wbGVtZW50ZWQsIHRoaXMgbWV0aG9kcyBpbXBsaWVzIHRoYXQgZHVwbGljYXRlXG4gICAgICogdmVydGljZXMgd2lsbCBiZSBtZXJnZWQuIEl0IHdpbGwgbm8gbG9uZ2VyIGJlIHRoZSBjYXNlIGluIHRoZSBmdXR1cmUgb25jZSB3ZSBkZWNvdXBsZVxuICAgICAqIHRoZSBjb21wdXRhdGlvbnMuXG4gICAgICovXG4gICAgVHJpTWVzaEZsYWdzW1RyaU1lc2hGbGFnc1tcIkRFTEVURV9ERUdFTkVSQVRFX1RSSUFOR0xFU1wiXSA9IDMyXSA9IFwiREVMRVRFX0RFR0VORVJBVEVfVFJJQU5HTEVTXCI7XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCB0d28gdHJpYW5nbGVzIHNoYXJpbmcgdGhyZWUgdmVydGljZXMgd2l0aCBpZGVudGljYWwgaW5kZXggdmFsdWVzIChpbiBhbnkgb3JkZXIpXG4gICAgICogd2lsbCBiZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQmVjYXVzZSBvZiB0aGUgd2F5IGl0IGlzIGN1cnJlbnRseSBpbXBsZW1lbnRlZCwgdGhpcyBtZXRob2RzIGltcGxpZXMgdGhhdCBkdXBsaWNhdGVcbiAgICAgKiB2ZXJ0aWNlcyB3aWxsIGJlIG1lcmdlZC4gSXQgd2lsbCBubyBsb25nZXIgYmUgdGhlIGNhc2UgaW4gdGhlIGZ1dHVyZSBvbmNlIHdlIGRlY291cGxlXG4gICAgICogdGhlIGNvbXB1dGF0aW9ucy5cbiAgICAgKi9cbiAgICBUcmlNZXNoRmxhZ3NbVHJpTWVzaEZsYWdzW1wiREVMRVRFX0RVUExJQ0FURV9UUklBTkdMRVNcIl0gPSA2NF0gPSBcIkRFTEVURV9EVVBMSUNBVEVfVFJJQU5HTEVTXCI7XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCBhIHNwZWNpYWwgdHJlYXRtZW50IHdpbGwgYmUgYXBwbGllZCB0byBjb250YWN0IG1hbmlmb2xkIGNhbGN1bGF0aW9uIHRvIGVsaW1pbmF0ZVxuICAgICAqIG9yIGZpeCBjb250YWN0cyBub3JtYWxzIHRoYXQgY291bGQgbGVhZCB0byBpbmNvcnJlY3QgYnVtcHMgaW4gcGh5c2ljcyBzaW11bGF0aW9uXG4gICAgICogKGVzcGVjaWFsbHkgb24gZmxhdCBzdXJmYWNlcykuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFjaGlldmVkIGJ5IHRha2luZyBpbnRvIGFjY291bnQgYWRqYWNlbnQgdHJpYW5nbGUgbm9ybWFscyB3aGVuIGNvbXB1dGluZyBjb250YWN0XG4gICAgICogcG9pbnRzIGZvciBhIGdpdmVuIHRyaWFuZ2xlLlxuICAgICAqXG4gICAgICogLyFcXCBOT1QgU1VQUE9SVEVEIElOIFRIRSAyRCBWRVJTSU9OIE9GIFJBUElFUi5cbiAgICAgKi9cbiAgICBUcmlNZXNoRmxhZ3NbVHJpTWVzaEZsYWdzW1wiRklYX0lOVEVSTkFMX0VER0VTXCJdID0gMTUyXSA9IFwiRklYX0lOVEVSTkFMX0VER0VTXCI7XG59KShUcmlNZXNoRmxhZ3MgfHwgKFRyaU1lc2hGbGFncyA9IHt9KSk7XG4vKipcbiAqIEEgc2hhcGUgdGhhdCBpcyBhIHNwaGVyZSBpbiAzRCBhbmQgYSBjaXJjbGUgaW4gMkQuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYWxsIGV4dGVuZHMgU2hhcGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYmFsbCB3aXRoIHRoZSBnaXZlbiByYWRpdXMuXG4gICAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBiYWxscyByYWRpdXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmFkaXVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlVHlwZS5CYWxsO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB9XG4gICAgaW50b1JhdygpIHtcbiAgICAgICAgcmV0dXJuIFJhd1NoYXBlLmJhbGwodGhpcy5yYWRpdXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBIYWxmU3BhY2UgZXh0ZW5kcyBTaGFwZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBoYWxmc3BhY2UgZGVsaW1pdGVkIGJ5IGFuIGluZmluaXRlIHBsYW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vcm1hbCAtIFRoZSBvdXR3YXJkIG5vcm1hbCBvZiB0aGUgcGxhbmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm9ybWFsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlVHlwZS5IYWxmU3BhY2U7XG4gICAgICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgIH1cbiAgICBpbnRvUmF3KCkge1xuICAgICAgICBsZXQgbiA9IFZlY3Rvck9wcy5pbnRvUmF3KHRoaXMubm9ybWFsKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhd1NoYXBlLmhhbGZzcGFjZShuKTtcbiAgICAgICAgbi5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNoYXBlIHRoYXQgaXMgYSBib3ggaW4gM0QgYW5kIGEgcmVjdGFuZ2xlIGluIDJELlxuICovXG5leHBvcnQgY2xhc3MgQ3Vib2lkIGV4dGVuZHMgU2hhcGUge1xuICAgIC8vICNpZiBESU0yXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyAyRCByZWN0YW5nbGUuXG4gICAgICogQHBhcmFtIGh4IC0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0gaHkgLSBUaGUgaGVsZiBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoeCwgaHkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVUeXBlLkN1Ym9pZDtcbiAgICAgICAgdGhpcy5oYWxmRXh0ZW50cyA9IFZlY3Rvck9wcy5uZXcoaHgsIGh5KTtcbiAgICB9XG4gICAgLy8gI2VuZGlmXG4gICAgaW50b1JhdygpIHtcbiAgICAgICAgLy8gI2lmIERJTTJcbiAgICAgICAgcmV0dXJuIFJhd1NoYXBlLmN1Ym9pZCh0aGlzLmhhbGZFeHRlbnRzLngsIHRoaXMuaGFsZkV4dGVudHMueSk7XG4gICAgICAgIC8vICNlbmRpZlxuICAgIH1cbn1cbi8qKlxuICogQSBzaGFwZSB0aGF0IGlzIGEgYm94IGluIDNEIGFuZCBhIHJlY3RhbmdsZSBpbiAyRCwgd2l0aCByb3VuZCBjb3JuZXJzLlxuICovXG5leHBvcnQgY2xhc3MgUm91bmRDdWJvaWQgZXh0ZW5kcyBTaGFwZSB7XG4gICAgLy8gI2lmIERJTTJcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IDJEIHJlY3RhbmdsZS5cbiAgICAgKiBAcGFyYW0gaHggLSBUaGUgaGFsZiB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqIEBwYXJhbSBoeSAtIFRoZSBoZWxmIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqIEBwYXJhbSBib3JkZXJSYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBib3JkZXJzIG9mIHRoaXMgY3Vib2lkLiBUaGlzIHdpbGxcbiAgICAgKiAgIGVmZmVjdGl2ZWx5IGluY3JlYXNlIHRoZSBoYWxmLWV4dGVudHMgb2YgdGhlIGN1Ym9pZCBieSB0aGlzIHJhZGl1cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihoeCwgaHksIGJvcmRlclJhZGl1cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVR5cGUuUm91bmRDdWJvaWQ7XG4gICAgICAgIHRoaXMuaGFsZkV4dGVudHMgPSBWZWN0b3JPcHMubmV3KGh4LCBoeSk7XG4gICAgICAgIHRoaXMuYm9yZGVyUmFkaXVzID0gYm9yZGVyUmFkaXVzO1xuICAgIH1cbiAgICAvLyAjZW5kaWZcbiAgICBpbnRvUmF3KCkge1xuICAgICAgICAvLyAjaWYgRElNMlxuICAgICAgICByZXR1cm4gUmF3U2hhcGUucm91bmRDdWJvaWQodGhpcy5oYWxmRXh0ZW50cy54LCB0aGlzLmhhbGZFeHRlbnRzLnksIHRoaXMuYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgLy8gI2VuZGlmXG4gICAgfVxufVxuLyoqXG4gKiBBIHNoYXBlIHRoYXQgaXMgYSBjYXBzdWxlLlxuICovXG5leHBvcnQgY2xhc3MgQ2Fwc3VsZSBleHRlbmRzIFNoYXBlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNhcHN1bGUgd2l0aCB0aGUgZ2l2ZW4gcmFkaXVzIGFuZCBoYWxmLWhlaWdodC5cbiAgICAgKiBAcGFyYW0gaGFsZkhlaWdodCAtIFRoZSBiYWxscyBoYWxmLWhlaWdodCBhbG9uZyB0aGUgYHlgIGF4aXMuXG4gICAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSBiYWxscyByYWRpdXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaGFsZkhlaWdodCwgcmFkaXVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlVHlwZS5DYXBzdWxlO1xuICAgICAgICB0aGlzLmhhbGZIZWlnaHQgPSBoYWxmSGVpZ2h0O1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB9XG4gICAgaW50b1JhdygpIHtcbiAgICAgICAgcmV0dXJuIFJhd1NoYXBlLmNhcHN1bGUodGhpcy5oYWxmSGVpZ2h0LCB0aGlzLnJhZGl1cyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNoYXBlIHRoYXQgaXMgYSBzZWdtZW50LlxuICovXG5leHBvcnQgY2xhc3MgU2VnbWVudCBleHRlbmRzIFNoYXBlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNlZ21lbnQgc2hhcGUuXG4gICAgICogQHBhcmFtIGEgLSBUaGUgZmlyc3QgcG9pbnQgb2YgdGhlIHNlZ21lbnQuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBzZWdtZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGEsIGIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVUeXBlLlNlZ21lbnQ7XG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgfVxuICAgIGludG9SYXcoKSB7XG4gICAgICAgIGxldCByYSA9IFZlY3Rvck9wcy5pbnRvUmF3KHRoaXMuYSk7XG4gICAgICAgIGxldCByYiA9IFZlY3Rvck9wcy5pbnRvUmF3KHRoaXMuYik7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYXdTaGFwZS5zZWdtZW50KHJhLCByYik7XG4gICAgICAgIHJhLmZyZWUoKTtcbiAgICAgICAgcmIuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogQSBzaGFwZSB0aGF0IGlzIGEgc2VnbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyaWFuZ2xlIGV4dGVuZHMgU2hhcGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJpYW5nbGUgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBwb2ludCBvZiB0aGUgdHJpYW5nbGUuXG4gICAgICogQHBhcmFtIGIgLSBUaGUgc2Vjb25kIHBvaW50IG9mIHRoZSB0cmlhbmdsZS5cbiAgICAgKiBAcGFyYW0gYyAtIFRoZSB0aGlyZCBwb2ludCBvZiB0aGUgdHJpYW5nbGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYSwgYiwgYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVR5cGUuVHJpYW5nbGU7XG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIHRoaXMuYyA9IGM7XG4gICAgfVxuICAgIGludG9SYXcoKSB7XG4gICAgICAgIGxldCByYSA9IFZlY3Rvck9wcy5pbnRvUmF3KHRoaXMuYSk7XG4gICAgICAgIGxldCByYiA9IFZlY3Rvck9wcy5pbnRvUmF3KHRoaXMuYik7XG4gICAgICAgIGxldCByYyA9IFZlY3Rvck9wcy5pbnRvUmF3KHRoaXMuYyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYXdTaGFwZS50cmlhbmdsZShyYSwgcmIsIHJjKTtcbiAgICAgICAgcmEuZnJlZSgpO1xuICAgICAgICByYi5mcmVlKCk7XG4gICAgICAgIHJjLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIEEgc2hhcGUgdGhhdCBpcyBhIHRyaWFuZ2xlIHdpdGggcm91bmQgYm9yZGVycyBhbmQgYSBub24temVybyB0aGlja25lc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb3VuZFRyaWFuZ2xlIGV4dGVuZHMgU2hhcGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJpYW5nbGUgc2hhcGUgd2l0aCByb3VuZCBjb3JuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGEgLSBUaGUgZmlyc3QgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlLlxuICAgICAqIEBwYXJhbSBiIC0gVGhlIHNlY29uZCBwb2ludCBvZiB0aGUgdHJpYW5nbGUuXG4gICAgICogQHBhcmFtIGMgLSBUaGUgdGhpcmQgcG9pbnQgb2YgdGhlIHRyaWFuZ2xlLlxuICAgICAqIEBwYXJhbSBib3JkZXJSYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBib3JkZXJzIG9mIHRoaXMgdHJpYW5nbGUuIEluIDNELFxuICAgICAqICAgdGhpcyBpcyBhbHNvIGVxdWFsIHRvIGhhbGYgdGhlIHRoaWNrbmVzcyBvZiB0aGUgdHJpYW5nbGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYSwgYiwgYywgYm9yZGVyUmFkaXVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlVHlwZS5Sb3VuZFRyaWFuZ2xlO1xuICAgICAgICB0aGlzLmEgPSBhO1xuICAgICAgICB0aGlzLmIgPSBiO1xuICAgICAgICB0aGlzLmMgPSBjO1xuICAgICAgICB0aGlzLmJvcmRlclJhZGl1cyA9IGJvcmRlclJhZGl1cztcbiAgICB9XG4gICAgaW50b1JhdygpIHtcbiAgICAgICAgbGV0IHJhID0gVmVjdG9yT3BzLmludG9SYXcodGhpcy5hKTtcbiAgICAgICAgbGV0IHJiID0gVmVjdG9yT3BzLmludG9SYXcodGhpcy5iKTtcbiAgICAgICAgbGV0IHJjID0gVmVjdG9yT3BzLmludG9SYXcodGhpcy5jKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhd1NoYXBlLnJvdW5kVHJpYW5nbGUocmEsIHJiLCByYywgdGhpcy5ib3JkZXJSYWRpdXMpO1xuICAgICAgICByYS5mcmVlKCk7XG4gICAgICAgIHJiLmZyZWUoKTtcbiAgICAgICAgcmMuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogQSBzaGFwZSB0aGF0IGlzIGEgdHJpYW5nbGUgbWVzaC5cbiAqL1xuZXhwb3J0IGNsYXNzIFBvbHlsaW5lIGV4dGVuZHMgU2hhcGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcG9seWxpbmUgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmVydGljZXMgLSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlsaW5lJ3MgdmVydGljZXMuXG4gICAgICogQHBhcmFtIGluZGljZXMgLSBUaGUgaW5kaWNlcyBvZiB0aGUgcG9seWxpbmUncyBzZWdtZW50cy4gSWYgdGhpcyBpcyBgbnVsbGAgb3Igbm90IHByb3ZpZGVkLCB0aGVuXG4gICAgICogICAgdGhlIHZlcnRpY2VzIGFyZSBhc3N1bWVkIHRvIGZvcm0gYSBsaW5lIHN0cmlwLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCBpbmRpY2VzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlVHlwZS5Qb2x5bGluZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzICE9PSBudWxsICYmIGluZGljZXMgIT09IHZvaWQgMCA/IGluZGljZXMgOiBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgfVxuICAgIGludG9SYXcoKSB7XG4gICAgICAgIHJldHVybiBSYXdTaGFwZS5wb2x5bGluZSh0aGlzLnZlcnRpY2VzLCB0aGlzLmluZGljZXMpO1xuICAgIH1cbn1cbi8qKlxuICogQSBzaGFwZSB0aGF0IGlzIGEgdHJpYW5nbGUgbWVzaC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyaU1lc2ggZXh0ZW5kcyBTaGFwZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0cmlhbmdsZSBtZXNoIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZlcnRpY2VzIC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSB0cmlhbmdsZSBtZXNoJ3MgdmVydGljZXMuXG4gICAgICogQHBhcmFtIGluZGljZXMgLSBUaGUgaW5kaWNlcyBvZiB0aGUgdHJpYW5nbGUgbWVzaCdzIHRyaWFuZ2xlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgaW5kaWNlcywgZmxhZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVUeXBlLlRyaU1lc2g7XG4gICAgICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICBpbnRvUmF3KCkge1xuICAgICAgICByZXR1cm4gUmF3U2hhcGUudHJpbWVzaCh0aGlzLnZlcnRpY2VzLCB0aGlzLmluZGljZXMsIHRoaXMuZmxhZ3MpO1xuICAgIH1cbn1cbi8vICNpZiBESU0yXG4vKipcbiAqIEEgc2hhcGUgdGhhdCBpcyBhIGNvbnZleCBwb2x5Z29uLlxuICovXG5leHBvcnQgY2xhc3MgQ29udmV4UG9seWdvbiBleHRlbmRzIFNoYXBlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbnZleCBwb2x5Z29uIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZlcnRpY2VzIC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjb252ZXggcG9seWdvbidzIHZlcnRpY2VzLlxuICAgICAqIEBwYXJhbSBza2lwQ29udmV4SHVsbENvbXB1dGF0aW9uIC0gSWYgc2V0IHRvIGB0cnVlYCwgdGhlIGlucHV0IHBvaW50cyB3aWxsXG4gICAgICogICBiZSBhc3N1bWVkIHRvIGZvcm0gYSBjb252ZXggcG9seWxpbmUgYW5kIG5vIGNvbnZleC1odWxsIGNvbXB1dGF0aW9uIHdpbGxcbiAgICAgKiAgIGJlIGRvbmUgYXV0b21hdGljYWxseS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcywgc2tpcENvbnZleEh1bGxDb21wdXRhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVR5cGUuQ29udmV4UG9seWdvbjtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICB0aGlzLnNraXBDb252ZXhIdWxsQ29tcHV0YXRpb24gPSAhIXNraXBDb252ZXhIdWxsQ29tcHV0YXRpb247XG4gICAgfVxuICAgIGludG9SYXcoKSB7XG4gICAgICAgIGlmICh0aGlzLnNraXBDb252ZXhIdWxsQ29tcHV0YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBSYXdTaGFwZS5jb252ZXhQb2x5bGluZSh0aGlzLnZlcnRpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSYXdTaGFwZS5jb252ZXhIdWxsKHRoaXMudmVydGljZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIHNoYXBlIHRoYXQgaXMgYSBjb252ZXggcG9seWdvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJvdW5kQ29udmV4UG9seWdvbiBleHRlbmRzIFNoYXBlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbnZleCBwb2x5Z29uIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZlcnRpY2VzIC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjb252ZXggcG9seWdvbidzIHZlcnRpY2VzLlxuICAgICAqIEBwYXJhbSBib3JkZXJSYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBib3JkZXJzIG9mIHRoaXMgY29udmV4IHBvbHlnb24uXG4gICAgICogQHBhcmFtIHNraXBDb252ZXhIdWxsQ29tcHV0YXRpb24gLSBJZiBzZXQgdG8gYHRydWVgLCB0aGUgaW5wdXQgcG9pbnRzIHdpbGxcbiAgICAgKiAgIGJlIGFzc3VtZWQgdG8gZm9ybSBhIGNvbnZleCBwb2x5bGluZSBhbmQgbm8gY29udmV4LWh1bGwgY29tcHV0YXRpb24gd2lsbFxuICAgICAqICAgYmUgZG9uZSBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzLCBib3JkZXJSYWRpdXMsIHNraXBDb252ZXhIdWxsQ29tcHV0YXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVUeXBlLlJvdW5kQ29udmV4UG9seWdvbjtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICB0aGlzLmJvcmRlclJhZGl1cyA9IGJvcmRlclJhZGl1cztcbiAgICAgICAgdGhpcy5za2lwQ29udmV4SHVsbENvbXB1dGF0aW9uID0gISFza2lwQ29udmV4SHVsbENvbXB1dGF0aW9uO1xuICAgIH1cbiAgICBpbnRvUmF3KCkge1xuICAgICAgICBpZiAodGhpcy5za2lwQ29udmV4SHVsbENvbXB1dGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gUmF3U2hhcGUucm91bmRDb252ZXhQb2x5bGluZSh0aGlzLnZlcnRpY2VzLCB0aGlzLmJvcmRlclJhZGl1cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUmF3U2hhcGUucm91bmRDb252ZXhIdWxsKHRoaXMudmVydGljZXMsIHRoaXMuYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBzaGFwZSB0aGF0IGlzIGEgaGVpZ2h0ZmllbGQuXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWlnaHRmaWVsZCBleHRlbmRzIFNoYXBlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGhlaWdodGZpZWxkIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhlaWdodHMgLSBUaGUgaGVpZ2h0cyBvZiB0aGUgaGVpZ2h0ZmllbGQsIGFsb25nIGl0cyBsb2NhbCBgeWAgYXhpcy5cbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBUaGUgc2NhbGUgZmFjdG9yIGFwcGxpZWQgdG8gdGhlIGhlaWdodGZpZWxkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhlaWdodHMsIHNjYWxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlVHlwZS5IZWlnaHRGaWVsZDtcbiAgICAgICAgdGhpcy5oZWlnaHRzID0gaGVpZ2h0cztcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIH1cbiAgICBpbnRvUmF3KCkge1xuICAgICAgICBsZXQgcmF3U2NhbGUgPSBWZWN0b3JPcHMuaW50b1Jhdyh0aGlzLnNjYWxlKTtcbiAgICAgICAgbGV0IHJhd1NoYXBlID0gUmF3U2hhcGUuaGVpZ2h0ZmllbGQodGhpcy5oZWlnaHRzLCByYXdTY2FsZSk7XG4gICAgICAgIHJhd1NjYWxlLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJhd1NoYXBlO1xuICAgIH1cbn1cbi8vICNlbmRpZlxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/shape.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/toi.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/geometry/toi.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderShapeCastHit: () => (/* binding */ ColliderShapeCastHit),\n/* harmony export */   ShapeCastHit: () => (/* binding */ ShapeCastHit)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The intersection between a ray and a collider.\n */\nclass ShapeCastHit {\n    constructor(time_of_impact, witness1, witness2, normal1, normal2) {\n        this.time_of_impact = time_of_impact;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeCastHit(raw.time_of_impact(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nclass ColliderShapeCastHit extends ShapeCastHit {\n    constructor(collider, time_of_impact, witness1, witness2, normal1, normal2) {\n        super(time_of_impact, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ColliderShapeCastHit(colliderSet.get(raw.colliderHandle()), raw.time_of_impact(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=toi.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL2dlb21ldHJ5L3RvaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw0Q0FBUywwQkFBMEIsNENBQVMsMEJBQTBCLDRDQUFTLHlCQUF5Qiw0Q0FBUztBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsNENBQVMsMEJBQTBCLDRDQUFTLDBCQUEwQiw0Q0FBUyx5QkFBeUIsNENBQVM7QUFDOU47QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQiIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxnZW9tZXRyeVxcdG9pLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3Rvck9wcyB9IGZyb20gXCIuLi9tYXRoXCI7XG4vKipcbiAqIFRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiBhIHJheSBhbmQgYSBjb2xsaWRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFNoYXBlQ2FzdEhpdCB7XG4gICAgY29uc3RydWN0b3IodGltZV9vZl9pbXBhY3QsIHdpdG5lc3MxLCB3aXRuZXNzMiwgbm9ybWFsMSwgbm9ybWFsMikge1xuICAgICAgICB0aGlzLnRpbWVfb2ZfaW1wYWN0ID0gdGltZV9vZl9pbXBhY3Q7XG4gICAgICAgIHRoaXMud2l0bmVzczEgPSB3aXRuZXNzMTtcbiAgICAgICAgdGhpcy53aXRuZXNzMiA9IHdpdG5lc3MyO1xuICAgICAgICB0aGlzLm5vcm1hbDEgPSBub3JtYWwxO1xuICAgICAgICB0aGlzLm5vcm1hbDIgPSBub3JtYWwyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJhdyhjb2xsaWRlclNldCwgcmF3KSB7XG4gICAgICAgIGlmICghcmF3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTaGFwZUNhc3RIaXQocmF3LnRpbWVfb2ZfaW1wYWN0KCksIFZlY3Rvck9wcy5mcm9tUmF3KHJhdy53aXRuZXNzMSgpKSwgVmVjdG9yT3BzLmZyb21SYXcocmF3LndpdG5lc3MyKCkpLCBWZWN0b3JPcHMuZnJvbVJhdyhyYXcubm9ybWFsMSgpKSwgVmVjdG9yT3BzLmZyb21SYXcocmF3Lm5vcm1hbDIoKSkpO1xuICAgICAgICByYXcuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIGEgcmF5IGFuZCBhIGNvbGxpZGVyLlxuICovXG5leHBvcnQgY2xhc3MgQ29sbGlkZXJTaGFwZUNhc3RIaXQgZXh0ZW5kcyBTaGFwZUNhc3RIaXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbGxpZGVyLCB0aW1lX29mX2ltcGFjdCwgd2l0bmVzczEsIHdpdG5lc3MyLCBub3JtYWwxLCBub3JtYWwyKSB7XG4gICAgICAgIHN1cGVyKHRpbWVfb2ZfaW1wYWN0LCB3aXRuZXNzMSwgd2l0bmVzczIsIG5vcm1hbDEsIG5vcm1hbDIpO1xuICAgICAgICB0aGlzLmNvbGxpZGVyID0gY29sbGlkZXI7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmF3KGNvbGxpZGVyU2V0LCByYXcpIHtcbiAgICAgICAgaWYgKCFyYXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IENvbGxpZGVyU2hhcGVDYXN0SGl0KGNvbGxpZGVyU2V0LmdldChyYXcuY29sbGlkZXJIYW5kbGUoKSksIHJhdy50aW1lX29mX2ltcGFjdCgpLCBWZWN0b3JPcHMuZnJvbVJhdyhyYXcud2l0bmVzczEoKSksIFZlY3Rvck9wcy5mcm9tUmF3KHJhdy53aXRuZXNzMigpKSwgVmVjdG9yT3BzLmZyb21SYXcocmF3Lm5vcm1hbDEoKSksIFZlY3Rvck9wcy5mcm9tUmF3KHJhdy5ub3JtYWwyKCkpKTtcbiAgICAgICAgcmF3LmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2kuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/toi.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js":
/*!*****************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/math.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RotationOps: () => (/* binding */ RotationOps),\n/* harmony export */   Vector2: () => (/* binding */ Vector2),\n/* harmony export */   VectorOps: () => (/* binding */ VectorOps)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * A 2D vector.\n */\nclass Vector2 {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\nclass VectorOps {\n    static new(x, y) {\n        return new Vector2(x, y);\n    }\n    static zeros() {\n        return VectorOps.new(0.0, 0.0);\n    }\n    // FIXME: type ram: RawVector?\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = VectorOps.new(raw.x, raw.y);\n        raw.free();\n        return res;\n    }\n    static intoRaw(v) {\n        return new _raw__WEBPACK_IMPORTED_MODULE_0__.RawVector(v.x, v.y);\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n    }\n}\nclass RotationOps {\n    static identity() {\n        return 0.0;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = raw.angle;\n        raw.free();\n        return res;\n    }\n    static intoRaw(angle) {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawRotation.fromAngle(angle);\n    }\n}\n// #endif\n//# sourceMappingURL=math.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL21hdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXG1hdGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF3VmVjdG9yLCBSYXdSb3RhdGlvbiB9IGZyb20gXCIuL3Jhd1wiO1xuLyoqXG4gKiBBIDJEIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFZlY3RvcjIge1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmVjdG9yT3BzIHtcbiAgICBzdGF0aWMgbmV3KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHgsIHkpO1xuICAgIH1cbiAgICBzdGF0aWMgemVyb3MoKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMubmV3KDAuMCwgMC4wKTtcbiAgICB9XG4gICAgLy8gRklYTUU6IHR5cGUgcmFtOiBSYXdWZWN0b3I/XG4gICAgc3RhdGljIGZyb21SYXcocmF3KSB7XG4gICAgICAgIGlmICghcmF3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCByZXMgPSBWZWN0b3JPcHMubmV3KHJhdy54LCByYXcueSk7XG4gICAgICAgIHJhdy5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBpbnRvUmF3KHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYXdWZWN0b3Iodi54LCB2LnkpO1xuICAgIH1cbiAgICBzdGF0aWMgY29weShvdXQsIGlucHV0KSB7XG4gICAgICAgIG91dC54ID0gaW5wdXQueDtcbiAgICAgICAgb3V0LnkgPSBpbnB1dC55O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSb3RhdGlvbk9wcyB7XG4gICAgc3RhdGljIGlkZW50aXR5KCkge1xuICAgICAgICByZXR1cm4gMC4wO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJhdyhyYXcpIHtcbiAgICAgICAgaWYgKCFyYXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHJlcyA9IHJhdy5hbmdsZTtcbiAgICAgICAgcmF3LmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGludG9SYXcoYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIFJhd1JvdGF0aW9uLmZyb21BbmdsZShhbmdsZSk7XG4gICAgfVxufVxuLy8gI2VuZGlmXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DebugRenderBuffers: () => (/* binding */ DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* binding */ DebugRenderPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nclass DebugRenderBuffers {\n    constructor(vertices, colors) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass DebugRenderPipeline {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawDebugRenderPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n//# sourceMappingURL=debug_render_pipeline.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3BpcGVsaW5lL2RlYnVnX3JlbmRlcl9waXBlbGluZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4Qix3REFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUQiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxccGlwZWxpbmVcXGRlYnVnX3JlbmRlcl9waXBlbGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXdEZWJ1Z1JlbmRlclBpcGVsaW5lIH0gZnJvbSBcIi4uL3Jhd1wiO1xuLyoqXG4gKiBUaGUgdmVydGV4IGFuZCBjb2xvciBidWZmZXJzIGZvciBkZWJ1Zy1yZWRlcmluZyB0aGUgcGh5c2ljcyBzY2VuZS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlYnVnUmVuZGVyQnVmZmVycyB7XG4gICAgY29uc3RydWN0b3IodmVydGljZXMsIGNvbG9ycykge1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgICAgIHRoaXMuY29sb3JzID0gY29sb3JzO1xuICAgIH1cbn1cbi8qKlxuICogQSBwaXBlbGluZSBmb3IgcmVuZGVyaW5nIHRoZSBwaHlzaWNzIHNjZW5lLlxuICpcbiAqIFRvIGF2b2lkIGxlYWtpbmcgV0FTTSByZXNvdXJjZXMsIHRoaXMgTVVTVCBiZSBmcmVlZCBtYW51YWxseSB3aXRoIGBkZWJ1Z1JlbmRlclBpcGVsaW5lLmZyZWUoKWBcbiAqIG9uY2UgeW91IGFyZSBkb25lIHVzaW5nIGl0IChhbmQgYWxsIHRoZSByaWdpZC1ib2RpZXMgaXQgY3JlYXRlZCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWJ1Z1JlbmRlclBpcGVsaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXcgfHwgbmV3IFJhd0RlYnVnUmVuZGVyUGlwZWxpbmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsZWFzZSB0aGUgV0FTTSBtZW1vcnkgb2NjdXBpZWQgYnkgdGhpcyBzZXJpYWxpemF0aW9uIHBpcGVsaW5lLlxuICAgICAqL1xuICAgIGZyZWUoKSB7XG4gICAgICAgIGlmICghIXRoaXMucmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5mcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmVydGljZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29sb3JzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZW5kZXIoYm9kaWVzLCBjb2xsaWRlcnMsIGltcHVsc2Vfam9pbnRzLCBtdWx0aWJvZHlfam9pbnRzLCBuYXJyb3dfcGhhc2UpIHtcbiAgICAgICAgdGhpcy5yYXcucmVuZGVyKGJvZGllcy5yYXcsIGNvbGxpZGVycy5yYXcsIGltcHVsc2Vfam9pbnRzLnJhdywgbXVsdGlib2R5X2pvaW50cy5yYXcsIG5hcnJvd19waGFzZS5yYXcpO1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0gdGhpcy5yYXcudmVydGljZXMoKTtcbiAgICAgICAgdGhpcy5jb2xvcnMgPSB0aGlzLnJhdy5jb2xvcnMoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJ1Z19yZW5kZXJfcGlwZWxpbmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/event_queue.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/pipeline/event_queue.js ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveEvents: () => (/* binding */ ActiveEvents),\n/* harmony export */   EventQueue: () => (/* binding */ EventQueue),\n/* harmony export */   TempContactForceEvent: () => (/* binding */ TempContactForceEvent)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__]);\n([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nvar ActiveEvents;\n(function (ActiveEvents) {\n    ActiveEvents[ActiveEvents[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Enable collision events.\n     */\n    ActiveEvents[ActiveEvents[\"COLLISION_EVENTS\"] = 1] = \"COLLISION_EVENTS\";\n    /**\n     * Enable contact force events.\n     */\n    ActiveEvents[ActiveEvents[\"CONTACT_FORCE_EVENTS\"] = 2] = \"CONTACT_FORCE_EVENTS\";\n})(ActiveEvents || (ActiveEvents = {}));\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nclass TempContactForceEvent {\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The first collider involved in the contact.\n     */\n    collider1() {\n        return this.raw.collider1();\n    }\n    /**\n     * The second collider involved in the contact.\n     */\n    collider2() {\n        return this.raw.collider2();\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    totalForce() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.raw.total_force());\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    totalForceMagnitude() {\n        return this.raw.total_force_magnitude();\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    maxForceDirection() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    maxForceMagnitude() {\n        return this.raw.max_force_magnitude();\n    }\n}\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nclass EventQueue {\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain, raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_1__.RawEventQueue(autoDrain);\n    }\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    drainCollisionEvents(f) {\n        this.raw.drainCollisionEvents(f);\n    }\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    drainContactForceEvents(f) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n    /**\n     * Removes all events contained by this collector\n     */\n    clear() {\n        this.raw.clear();\n    }\n}\n//# sourceMappingURL=event_queue.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3BpcGVsaW5lL2V2ZW50X3F1ZXVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ0g7QUFDcEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXHBpcGVsaW5lXFxldmVudF9xdWV1ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXdFdmVudFF1ZXVlIH0gZnJvbSBcIi4uL3Jhd1wiO1xuaW1wb3J0IHsgVmVjdG9yT3BzIH0gZnJvbSBcIi4uL21hdGhcIjtcbi8qKlxuICogRmxhZ3MgaW5kaWNhdGluZyB3aGF0IGV2ZW50cyBhcmUgZW5hYmxlZCBmb3IgY29sbGlkZXJzLlxuICovXG5leHBvcnQgdmFyIEFjdGl2ZUV2ZW50cztcbihmdW5jdGlvbiAoQWN0aXZlRXZlbnRzKSB7XG4gICAgQWN0aXZlRXZlbnRzW0FjdGl2ZUV2ZW50c1tcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBjb2xsaXNpb24gZXZlbnRzLlxuICAgICAqL1xuICAgIEFjdGl2ZUV2ZW50c1tBY3RpdmVFdmVudHNbXCJDT0xMSVNJT05fRVZFTlRTXCJdID0gMV0gPSBcIkNPTExJU0lPTl9FVkVOVFNcIjtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgY29udGFjdCBmb3JjZSBldmVudHMuXG4gICAgICovXG4gICAgQWN0aXZlRXZlbnRzW0FjdGl2ZUV2ZW50c1tcIkNPTlRBQ1RfRk9SQ0VfRVZFTlRTXCJdID0gMl0gPSBcIkNPTlRBQ1RfRk9SQ0VfRVZFTlRTXCI7XG59KShBY3RpdmVFdmVudHMgfHwgKEFjdGl2ZUV2ZW50cyA9IHt9KSk7XG4vKipcbiAqIEV2ZW50IG9jY3VycmluZyB3aGVuIHRoZSBzdW0gb2YgdGhlIG1hZ25pdHVkZXMgb2YgdGhlXG4gKiBjb250YWN0IGZvcmNlcyBiZXR3ZWVuIHR3byBjb2xsaWRlcnMgZXhjZWVkIGEgdGhyZXNob2xkLlxuICpcbiAqIFRoaXMgb2JqZWN0IHNob3VsZCAqKm5vdCoqIGJlIHN0b3JlZCBhbnl3aGVyZS4gSXRzIHByb3BlcnRpZXMgY2FuIG9ubHkgYmVcbiAqIHJlYWQgZnJvbSB3aXRoaW4gdGhlIGNsb3N1cmUgZ2l2ZW4gdG8gYEV2ZW50SGFuZGxlci5kcmFpbkNvbnRhY3RGb3JjZUV2ZW50c2AuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wQ29udGFjdEZvcmNlRXZlbnQge1xuICAgIGZyZWUoKSB7XG4gICAgICAgIGlmICghIXRoaXMucmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5mcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYXcgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCBjb2xsaWRlciBpbnZvbHZlZCBpbiB0aGUgY29udGFjdC5cbiAgICAgKi9cbiAgICBjb2xsaWRlcjEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5jb2xsaWRlcjEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNlY29uZCBjb2xsaWRlciBpbnZvbHZlZCBpbiB0aGUgY29udGFjdC5cbiAgICAgKi9cbiAgICBjb2xsaWRlcjIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhdy5jb2xsaWRlcjIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHN1bSBvZiBhbGwgdGhlIGZvcmNlcyBiZXR3ZWVuIHRoZSB0d28gY29sbGlkZXJzLlxuICAgICAqL1xuICAgIHRvdGFsRm9yY2UoKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyh0aGlzLnJhdy50b3RhbF9mb3JjZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHN1bSBvZiB0aGUgbWFnbml0dWRlcyBvZiBlYWNoIGZvcmNlIGJldHdlZW4gdGhlIHR3byBjb2xsaWRlcnMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBpcyAqKm5vdCoqIHRoZSBzYW1lIGFzIHRoZSBtYWduaXR1ZGUgb2YgYHNlbGYudG90YWxfZm9yY2VgLlxuICAgICAqIEhlcmUgd2UgYXJlIHN1bW1pbmcgdGhlIG1hZ25pdHVkZSBvZiBhbGwgdGhlIGZvcmNlcywgaW5zdGVhZCBvZiB0YWtpbmdcbiAgICAgKiB0aGUgbWFnbml0dWRlIG9mIHRoZWlyIHN1bS5cbiAgICAgKi9cbiAgICB0b3RhbEZvcmNlTWFnbml0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXcudG90YWxfZm9yY2VfbWFnbml0dWRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZC1zcGFjZSAodW5pdCkgZGlyZWN0aW9uIG9mIHRoZSBmb3JjZSB3aXRoIHN0cm9uZ2VzdCBtYWduaXR1ZGUuXG4gICAgICovXG4gICAgbWF4Rm9yY2VEaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3JPcHMuZnJvbVJhdyh0aGlzLnJhdy5tYXhfZm9yY2VfZGlyZWN0aW9uKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0IGZvcmNlIGF0IGEgY29udGFjdCBwb2ludCBvZiB0aGlzIGNvbnRhY3QgcGFpci5cbiAgICAgKi9cbiAgICBtYXhGb3JjZU1hZ25pdHVkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3Lm1heF9mb3JjZV9tYWduaXR1ZGUoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgc3RydWN0dXJlIHJlc3BvbnNpYmxlIGZvciBjb2xsZWN0aW5nIGV2ZW50cyBnZW5lcmF0ZWRcbiAqIGJ5IHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqXG4gKiBUbyBhdm9pZCBsZWFraW5nIFdBU00gcmVzb3VyY2VzLCB0aGlzIE1VU1QgYmUgZnJlZWQgbWFudWFsbHkgd2l0aCBgZXZlbnRRdWV1ZS5mcmVlKClgXG4gKiBvbmNlIHlvdSBhcmUgZG9uZSB1c2luZyBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50UXVldWUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZXZlbnQgY29sbGVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dG9EcmFpbiAtc2V0dGluZyB0aGlzIHRvIGB0cnVlYCBpcyBzdHJvbmdseSByZWNvbW1lbmRlZC4gSWYgdHJ1ZSwgdGhlIGNvbGxlY3RvciB3aWxsXG4gICAgICogYmUgYXV0b21hdGljYWxseSBkcmFpbmVkIGJlZm9yZSBlYWNoIGB3b3JsZC5zdGVwKGNvbGxlY3RvcilgLiBJZiBmYWxzZSwgdGhlIGNvbGxlY3RvciB3aWxsXG4gICAgICoga2VlcCBhbGwgZXZlbnRzIGluIG1lbW9yeSB1bmxlc3MgaXQgaXMgbWFudWFsbHkgZHJhaW5lZC9jbGVhcmVkOyB0aGlzIG1heSBsZWFkIHRvIHVuYm91bmRlZCB1c2Ugb2ZcbiAgICAgKiBSQU0gaWYgbm8gZHJhaW4gaXMgcGVyZm9ybWVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGF1dG9EcmFpbiwgcmF3KSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3IHx8IG5ldyBSYXdFdmVudFF1ZXVlKGF1dG9EcmFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGhlIFdBU00gbWVtb3J5IG9jY3VwaWVkIGJ5IHRoaXMgZXZlbnQtcXVldWUuXG4gICAgICovXG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKCEhdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LmZyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gamF2YXNjcmlwdCBjbG9zdXJlIG9uIGVhY2ggY29sbGlzaW9uIGV2ZW50IG9mIHRoaXMgY29sbGVjdG9yLCB0aGVuIGNsZWFyXG4gICAgICogdGhlIGludGVybmFsIGNvbGxpc2lvbiBldmVudCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZiAtIEphdmFTY3JpcHQgY2xvc3VyZSBhcHBsaWVkIHRvIGVhY2ggY29sbGlzaW9uIGV2ZW50LiBUaGVcbiAgICAgKiBjbG9zdXJlIG11c3QgdGFrZSB0aHJlZSBhcmd1bWVudHM6IHR3byBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIGhhbmRsZXMgb2YgdGhlIGNvbGxpZGVyc1xuICAgICAqIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24sIGFuZCBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgY29sbGlzaW9uIHN0YXJ0ZWQgKHRydWUpIG9yIHN0b3BwZWRcbiAgICAgKiAoZmFsc2UpLlxuICAgICAqL1xuICAgIGRyYWluQ29sbGlzaW9uRXZlbnRzKGYpIHtcbiAgICAgICAgdGhpcy5yYXcuZHJhaW5Db2xsaXNpb25FdmVudHMoZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGphdmFzY3JpcHQgY2xvc3VyZSBvbiBlYWNoIGNvbnRhY3QgZm9yY2UgZXZlbnQgb2YgdGhpcyBjb2xsZWN0b3IsIHRoZW4gY2xlYXJcbiAgICAgKiB0aGUgaW50ZXJuYWwgY29sbGlzaW9uIGV2ZW50IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmIC0gSmF2YVNjcmlwdCBjbG9zdXJlIGFwcGxpZWQgdG8gZWFjaCBjb2xsaXNpb24gZXZlbnQuIFRoZVxuICAgICAqICAgICAgICAgICAgY2xvc3VyZSBtdXN0IHRha2Ugb25lIGBUZW1wQ29udGFjdEZvcmNlRXZlbnRgIGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGRyYWluQ29udGFjdEZvcmNlRXZlbnRzKGYpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IFRlbXBDb250YWN0Rm9yY2VFdmVudCgpO1xuICAgICAgICB0aGlzLnJhdy5kcmFpbkNvbnRhY3RGb3JjZUV2ZW50cygocmF3KSA9PiB7XG4gICAgICAgICAgICBldmVudC5yYXcgPSByYXc7XG4gICAgICAgICAgICBmKGV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50LmZyZWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50cyBjb250YWluZWQgYnkgdGhpcyBjb2xsZWN0b3JcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5yYXcuY2xlYXIoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudF9xdWV1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/event_queue.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/pipeline/index.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _physics_hooks__WEBPACK_IMPORTED_MODULE_4__.ActiveHooks),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.EventQueue),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__.PhysicsPipeline),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _query_pipeline__WEBPACK_IMPORTED_MODULE_6__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _query_pipeline__WEBPACK_IMPORTED_MODULE_6__.QueryPipeline),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__.SerializationPipeline),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _physics_hooks__WEBPACK_IMPORTED_MODULE_4__.SolverFlags),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.TempContactForceEvent),\n/* harmony export */   World: () => (/* reexport safe */ _world__WEBPACK_IMPORTED_MODULE_0__.World)\n/* harmony export */ });\n/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./world */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/world.js\");\n/* harmony import */ var _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./physics_pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js\");\n/* harmony import */ var _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serialization_pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js\");\n/* harmony import */ var _event_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./event_queue */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/event_queue.js\");\n/* harmony import */ var _physics_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./physics_hooks */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js\");\n/* harmony import */ var _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug_render_pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js\");\n/* harmony import */ var _query_pipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./query_pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_world__WEBPACK_IMPORTED_MODULE_0__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__, _event_queue__WEBPACK_IMPORTED_MODULE_3__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__, _query_pipeline__WEBPACK_IMPORTED_MODULE_6__]);\n([_world__WEBPACK_IMPORTED_MODULE_0__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__, _event_queue__WEBPACK_IMPORTED_MODULE_3__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__, _query_pipeline__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3BpcGVsaW5lL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0I7QUFDVztBQUNNO0FBQ1g7QUFDRTtBQUNRO0FBQ1A7QUFDakMsaUMiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxccGlwZWxpbmVcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL3dvcmxkXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9waHlzaWNzX3BpcGVsaW5lXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXJpYWxpemF0aW9uX3BpcGVsaW5lXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9ldmVudF9xdWV1ZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcGh5c2ljc19ob29rc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZGVidWdfcmVuZGVyX3BpcGVsaW5lXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9xdWVyeV9waXBlbGluZVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveHooks: () => (/* binding */ ActiveHooks),\n/* harmony export */   SolverFlags: () => (/* binding */ SolverFlags)\n/* harmony export */ });\nvar ActiveHooks;\n(function (ActiveHooks) {\n    ActiveHooks[ActiveHooks[\"NONE\"] = 0] = \"NONE\";\n    ActiveHooks[ActiveHooks[\"FILTER_CONTACT_PAIRS\"] = 1] = \"FILTER_CONTACT_PAIRS\";\n    ActiveHooks[ActiveHooks[\"FILTER_INTERSECTION_PAIRS\"] = 2] = \"FILTER_INTERSECTION_PAIRS\";\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n})(ActiveHooks || (ActiveHooks = {}));\nvar SolverFlags;\n(function (SolverFlags) {\n    SolverFlags[SolverFlags[\"EMPTY\"] = 0] = \"EMPTY\";\n    SolverFlags[SolverFlags[\"COMPUTE_IMPULSE\"] = 1] = \"COMPUTE_IMPULSE\";\n})(SolverFlags || (SolverFlags = {}));\n//# sourceMappingURL=physics_hooks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3BpcGVsaW5lL3BoeXNpY3NfaG9va3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUM1QjtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXHBpcGVsaW5lXFxwaHlzaWNzX2hvb2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgQWN0aXZlSG9va3M7XG4oZnVuY3Rpb24gKEFjdGl2ZUhvb2tzKSB7XG4gICAgQWN0aXZlSG9va3NbQWN0aXZlSG9va3NbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBBY3RpdmVIb29rc1tBY3RpdmVIb29rc1tcIkZJTFRFUl9DT05UQUNUX1BBSVJTXCJdID0gMV0gPSBcIkZJTFRFUl9DT05UQUNUX1BBSVJTXCI7XG4gICAgQWN0aXZlSG9va3NbQWN0aXZlSG9va3NbXCJGSUxURVJfSU5URVJTRUNUSU9OX1BBSVJTXCJdID0gMl0gPSBcIkZJTFRFUl9JTlRFUlNFQ1RJT05fUEFJUlNcIjtcbiAgICAvLyBNT0RJRllfU09MVkVSX0NPTlRBQ1RTID0gMGIwMTAwLCAvKiBOb3Qgc3VwcG9ydGVkIHlldCBpbiBKUy4gKi9cbn0pKEFjdGl2ZUhvb2tzIHx8IChBY3RpdmVIb29rcyA9IHt9KSk7XG5leHBvcnQgdmFyIFNvbHZlckZsYWdzO1xuKGZ1bmN0aW9uIChTb2x2ZXJGbGFncykge1xuICAgIFNvbHZlckZsYWdzW1NvbHZlckZsYWdzW1wiRU1QVFlcIl0gPSAwXSA9IFwiRU1QVFlcIjtcbiAgICBTb2x2ZXJGbGFnc1tTb2x2ZXJGbGFnc1tcIkNPTVBVVEVfSU1QVUxTRVwiXSA9IDFdID0gXCJDT01QVVRFX0lNUFVMU0VcIjtcbn0pKFNvbHZlckZsYWdzIHx8IChTb2x2ZXJGbGFncyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waHlzaWNzX2hvb2tzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsPipeline: () => (/* binding */ PhysicsPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\nclass PhysicsPipeline {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawPhysicsPipeline();\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {\n        let rawG = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(gravity);\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);\n        }\n        else {\n            this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);\n        }\n        rawG.free();\n    }\n}\n//# sourceMappingURL=physics_pipeline.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3BpcGVsaW5lL3BoeXNpY3NfcGlwZWxpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQ1I7QUFDN0I7QUFDUDtBQUNBLDhCQUE4QixvREFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxwaXBlbGluZVxccGh5c2ljc19waXBlbGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXdQaHlzaWNzUGlwZWxpbmUgfSBmcm9tIFwiLi4vcmF3XCI7XG5pbXBvcnQgeyBWZWN0b3JPcHMgfSBmcm9tIFwiLi4vbWF0aFwiO1xuZXhwb3J0IGNsYXNzIFBoeXNpY3NQaXBlbGluZSB7XG4gICAgY29uc3RydWN0b3IocmF3KSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3IHx8IG5ldyBSYXdQaHlzaWNzUGlwZWxpbmUoKTtcbiAgICB9XG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKCEhdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LmZyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3RlcChncmF2aXR5LCBpbnRlZ3JhdGlvblBhcmFtZXRlcnMsIGlzbGFuZHMsIGJyb2FkUGhhc2UsIG5hcnJvd1BoYXNlLCBib2RpZXMsIGNvbGxpZGVycywgaW1wdWxzZUpvaW50cywgbXVsdGlib2R5Sm9pbnRzLCBjY2RTb2x2ZXIsIGV2ZW50UXVldWUsIGhvb2tzKSB7XG4gICAgICAgIGxldCByYXdHID0gVmVjdG9yT3BzLmludG9SYXcoZ3Jhdml0eSk7XG4gICAgICAgIGlmICghIWV2ZW50UXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LnN0ZXBXaXRoRXZlbnRzKHJhd0csIGludGVncmF0aW9uUGFyYW1ldGVycy5yYXcsIGlzbGFuZHMucmF3LCBicm9hZFBoYXNlLnJhdywgbmFycm93UGhhc2UucmF3LCBib2RpZXMucmF3LCBjb2xsaWRlcnMucmF3LCBpbXB1bHNlSm9pbnRzLnJhdywgbXVsdGlib2R5Sm9pbnRzLnJhdywgY2NkU29sdmVyLnJhdywgZXZlbnRRdWV1ZS5yYXcsIGhvb2tzLCAhIWhvb2tzID8gaG9va3MuZmlsdGVyQ29udGFjdFBhaXIgOiBudWxsLCAhIWhvb2tzID8gaG9va3MuZmlsdGVySW50ZXJzZWN0aW9uUGFpciA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYXcuc3RlcChyYXdHLCBpbnRlZ3JhdGlvblBhcmFtZXRlcnMucmF3LCBpc2xhbmRzLnJhdywgYnJvYWRQaGFzZS5yYXcsIG5hcnJvd1BoYXNlLnJhdywgYm9kaWVzLnJhdywgY29sbGlkZXJzLnJhdywgaW1wdWxzZUpvaW50cy5yYXcsIG11bHRpYm9keUpvaW50cy5yYXcsIGNjZFNvbHZlci5yYXcpO1xuICAgICAgICB9XG4gICAgICAgIHJhd0cuZnJlZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBoeXNpY3NfcGlwZWxpbmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryFilterFlags: () => (/* binding */ QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* binding */ QueryPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geometry */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nvar QueryFilterFlags;\n(function (QueryFilterFlags) {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_FIXED\"] = 1] = \"EXCLUDE_FIXED\";\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_KINEMATIC\"] = 2] = \"EXCLUDE_KINEMATIC\";\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_DYNAMIC\"] = 4] = \"EXCLUDE_DYNAMIC\";\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SENSORS\"] = 8] = \"EXCLUDE_SENSORS\";\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SOLIDS\"] = 16] = \"EXCLUDE_SOLIDS\";\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_DYNAMIC\"] = 3] = \"ONLY_DYNAMIC\";\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_KINEMATIC\"] = 5] = \"ONLY_KINEMATIC\";\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_FIXED\"] = 6] = \"ONLY_FIXED\";\n})(QueryFilterFlags || (QueryFilterFlags = {}));\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass QueryPipeline {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawQueryPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    update(colliders) {\n        this.raw.update(colliders.raw);\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderHit.fromRaw(colliders, this.raw.castRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(bodies, colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter) => {\n            return callback(_geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderIntersection.fromRaw(colliders, rawInter));\n        };\n        this.raw.intersectionsWithRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, rawCallback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawOrig.free();\n        rawDir.free();\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(bodies, colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(bodies.raw, colliders.raw, rawPoint, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(bodies, colliders, point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(bodies.raw, colliders.raw, rawPoint, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(bodies, colliders, point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        this.raw.intersectionsWithPoint(bodies.raw, colliders.raw, rawPoint, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPoint.free();\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                       will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawVel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_4__.ColliderShapeCastHit.fromRaw(colliders, this.raw.castShape(bodies.raw, colliders.raw, rawPos, rawRot, rawVel, rawShape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        this.raw.intersectionsWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        let rawCenter = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n//# sourceMappingURL=query_pipeline.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3BpcGVsaW5lL3F1ZXJ5X3BpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFDNEU7QUFDckU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4QixrREFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0IscUJBQXFCLDRDQUFTO0FBQzlCLHFCQUFxQixxREFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0IscUJBQXFCLDRDQUFTO0FBQzlCLHFCQUFxQiw4REFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQVM7QUFDL0IscUJBQXFCLDRDQUFTO0FBQzlCO0FBQ0EsNEJBQTRCLDhEQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBUztBQUM5QixxQkFBcUIsOENBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFTO0FBQ2hDLHFCQUFxQiw4REFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUFTO0FBQ2hDLHFCQUFxQiw4REFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVM7QUFDOUIscUJBQXFCLDhDQUFXO0FBQ2hDLHFCQUFxQiw0Q0FBUztBQUM5QjtBQUNBLHFCQUFxQiwyREFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUFTO0FBQzlCLHFCQUFxQiw4Q0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNENBQVM7QUFDakMsNkJBQTZCLDRDQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxwaXBlbGluZVxccXVlcnlfcGlwZWxpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmF3UXVlcnlQaXBlbGluZSB9IGZyb20gXCIuLi9yYXdcIjtcbmltcG9ydCB7IFBvaW50Q29sbGlkZXJQcm9qZWN0aW9uLCBSYXlDb2xsaWRlckludGVyc2VjdGlvbiwgUmF5Q29sbGlkZXJIaXQsIENvbGxpZGVyU2hhcGVDYXN0SGl0LCB9IGZyb20gXCIuLi9nZW9tZXRyeVwiO1xuaW1wb3J0IHsgUm90YXRpb25PcHMsIFZlY3Rvck9wcyB9IGZyb20gXCIuLi9tYXRoXCI7XG4vLyBOT1RFOiBtdXN0IG1hdGNoIHRoZSBiaXRzIGluIHRoZSBRdWVyeUZpbHRlckZsYWdzIG9uIHRoZSBSdXN0IHNpZGUuXG4vKipcbiAqIEZsYWdzIGZvciBleGNsdWRpbmcgd2hvbGUgc2V0cyBvZiBjb2xsaWRlcnMgZnJvbSBhIHNjZW5lIHF1ZXJ5LlxuICovXG5leHBvcnQgdmFyIFF1ZXJ5RmlsdGVyRmxhZ3M7XG4oZnVuY3Rpb24gKFF1ZXJ5RmlsdGVyRmxhZ3MpIHtcbiAgICAvKipcbiAgICAgKiBFeGNsdWRlIGZyb20gdGhlIHF1ZXJ5IGFueSBjb2xsaWRlciBhdHRhY2hlZCB0byBhIGZpeGVkIHJpZ2lkLWJvZHkgYW5kIGNvbGxpZGVycyB3aXRoIG5vIHJpZ2lkLWJvZHkgYXR0YWNoZWQuXG4gICAgICovXG4gICAgUXVlcnlGaWx0ZXJGbGFnc1tRdWVyeUZpbHRlckZsYWdzW1wiRVhDTFVERV9GSVhFRFwiXSA9IDFdID0gXCJFWENMVURFX0ZJWEVEXCI7XG4gICAgLyoqXG4gICAgICogRXhjbHVkZSBmcm9tIHRoZSBxdWVyeSBhbnkgY29sbGlkZXIgYXR0YWNoZWQgdG8gYSBkeW5hbWljIHJpZ2lkLWJvZHkuXG4gICAgICovXG4gICAgUXVlcnlGaWx0ZXJGbGFnc1tRdWVyeUZpbHRlckZsYWdzW1wiRVhDTFVERV9LSU5FTUFUSUNcIl0gPSAyXSA9IFwiRVhDTFVERV9LSU5FTUFUSUNcIjtcbiAgICAvKipcbiAgICAgKiBFeGNsdWRlIGZyb20gdGhlIHF1ZXJ5IGFueSBjb2xsaWRlciBhdHRhY2hlZCB0byBhIGtpbmVtYXRpYyByaWdpZC1ib2R5LlxuICAgICAqL1xuICAgIFF1ZXJ5RmlsdGVyRmxhZ3NbUXVlcnlGaWx0ZXJGbGFnc1tcIkVYQ0xVREVfRFlOQU1JQ1wiXSA9IDRdID0gXCJFWENMVURFX0RZTkFNSUNcIjtcbiAgICAvKipcbiAgICAgKiBFeGNsdWRlIGZyb20gdGhlIHF1ZXJ5IGFueSBjb2xsaWRlciB0aGF0IGlzIGEgc2Vuc29yLlxuICAgICAqL1xuICAgIFF1ZXJ5RmlsdGVyRmxhZ3NbUXVlcnlGaWx0ZXJGbGFnc1tcIkVYQ0xVREVfU0VOU09SU1wiXSA9IDhdID0gXCJFWENMVURFX1NFTlNPUlNcIjtcbiAgICAvKipcbiAgICAgKiBFeGNsdWRlIGZyb20gdGhlIHF1ZXJ5IGFueSBjb2xsaWRlciB0aGF0IGlzIG5vdCBhIHNlbnNvci5cbiAgICAgKi9cbiAgICBRdWVyeUZpbHRlckZsYWdzW1F1ZXJ5RmlsdGVyRmxhZ3NbXCJFWENMVURFX1NPTElEU1wiXSA9IDE2XSA9IFwiRVhDTFVERV9TT0xJRFNcIjtcbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhbGwgY29sbGlkZXJzIG5vdCBhdHRhY2hlZCB0byBhIGR5bmFtaWMgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICBRdWVyeUZpbHRlckZsYWdzW1F1ZXJ5RmlsdGVyRmxhZ3NbXCJPTkxZX0RZTkFNSUNcIl0gPSAzXSA9IFwiT05MWV9EWU5BTUlDXCI7XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYWxsIGNvbGxpZGVycyBub3QgYXR0YWNoZWQgdG8gYSBraW5lbWF0aWMgcmlnaWQtYm9keS5cbiAgICAgKi9cbiAgICBRdWVyeUZpbHRlckZsYWdzW1F1ZXJ5RmlsdGVyRmxhZ3NbXCJPTkxZX0tJTkVNQVRJQ1wiXSA9IDVdID0gXCJPTkxZX0tJTkVNQVRJQ1wiO1xuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGUgYWxsIGNvbGxpZGVycyBhdHRhY2hlZCB0byBhIG5vbi1maXhlZCByaWdpZC1ib2R5XG4gICAgICogKHRoaXMgd2lsbCBub3QgZXhjbHVkZSBjb2xsaWRlcnMgbm90IGF0dGFjaGVkIHRvIGFueSByaWdpZC1ib2R5KS5cbiAgICAgKi9cbiAgICBRdWVyeUZpbHRlckZsYWdzW1F1ZXJ5RmlsdGVyRmxhZ3NbXCJPTkxZX0ZJWEVEXCJdID0gNl0gPSBcIk9OTFlfRklYRURcIjtcbn0pKFF1ZXJ5RmlsdGVyRmxhZ3MgfHwgKFF1ZXJ5RmlsdGVyRmxhZ3MgPSB7fSkpO1xuLyoqXG4gKiBBIHBpcGVsaW5lIGZvciBwZXJmb3JtaW5nIHF1ZXJpZXMgb24gYWxsIHRoZSBjb2xsaWRlcnMgb2YgYSBzY2VuZS5cbiAqXG4gKiBUbyBhdm9pZCBsZWFraW5nIFdBU00gcmVzb3VyY2VzLCB0aGlzIE1VU1QgYmUgZnJlZWQgbWFudWFsbHkgd2l0aCBgcXVlcnlQaXBlbGluZS5mcmVlKClgXG4gKiBvbmNlIHlvdSBhcmUgZG9uZSB1c2luZyBpdCAoYW5kIGFsbCB0aGUgcmlnaWQtYm9kaWVzIGl0IGNyZWF0ZWQpLlxuICovXG5leHBvcnQgY2xhc3MgUXVlcnlQaXBlbGluZSB7XG4gICAgY29uc3RydWN0b3IocmF3KSB7XG4gICAgICAgIHRoaXMucmF3ID0gcmF3IHx8IG5ldyBSYXdRdWVyeVBpcGVsaW5lKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGhlIFdBU00gbWVtb3J5IG9jY3VwaWVkIGJ5IHRoaXMgcXVlcnkgcGlwZWxpbmUuXG4gICAgICovXG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKCEhdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LmZyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYWNjZWxlcmF0aW9uIHN0cnVjdHVyZSBvZiB0aGUgcXVlcnkgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIGNvbGxpZGVycyAtIFRoZSBzZXQgb2YgY29sbGlkZXJzIHRha2luZyBwYXJ0IGluIHRoaXMgcGlwZWxpbmUuXG4gICAgICovXG4gICAgdXBkYXRlKGNvbGxpZGVycykge1xuICAgICAgICB0aGlzLnJhdy51cGRhdGUoY29sbGlkZXJzLnJhdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uIGJldHdlZW4gYSByYXkgYW5kIGEgc2V0IG9mIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVycyAtIFRoZSBzZXQgb2YgY29sbGlkZXJzIHRha2luZyBwYXJ0IGluIHRoaXMgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHJheSAtIFRoZSByYXkgdG8gY2FzdC5cbiAgICAgKiBAcGFyYW0gbWF4VG9pIC0gVGhlIG1heGltdW0gdGltZS1vZi1pbXBhY3QgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgdGhpcyBjYXN0LiBUaGlzIGVmZmVjdGl2ZWx5XG4gICAgICogICBsaW1pdHMgdGhlIGxlbmd0aCBvZiB0aGUgcmF5IHRvIGByYXkuZGlyLm5vcm0oKSAqIG1heFRvaWAuXG4gICAgICogQHBhcmFtIHNvbGlkIC0gSWYgYGZhbHNlYCB0aGVuIHRoZSByYXkgd2lsbCBhdHRlbXB0IHRvIGhpdCB0aGUgYm91bmRhcnkgb2YgYSBzaGFwZSwgZXZlbiBpZiBpdHNcbiAgICAgKiAgIG9yaWdpbiBhbHJlYWR5IGxpZXMgaW5zaWRlIG9mIGEgc2hhcGUuIEluIG90aGVyIHRlcm1zLCBgdHJ1ZWAgaW1wbGllcyB0aGF0IGFsbCBzaGFwZXMgYXJlIHBsYWluLFxuICAgICAqICAgd2hlcmVhcyBgZmFsc2VgIGltcGxpZXMgdGhhdCBhbGwgc2hhcGVzIGFyZSBob2xsb3cgZm9yIHRoaXMgcmF5LWNhc3QuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFVzZWQgdG8gZmlsdGVyIHRoZSBjb2xsaWRlcnMgdGhhdCBjYW4gb3IgY2Fubm90IGJlIGhpdCBieSB0aGUgcmF5LlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBUaGUgY2FsbGJhY2sgdG8gZmlsdGVyIG91dCB3aGljaCBjb2xsaWRlciB3aWxsIGJlIGhpdC5cbiAgICAgKi9cbiAgICBjYXN0UmF5KGJvZGllcywgY29sbGlkZXJzLCByYXksIG1heFRvaSwgc29saWQsIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSwgZmlsdGVyUHJlZGljYXRlKSB7XG4gICAgICAgIGxldCByYXdPcmlnID0gVmVjdG9yT3BzLmludG9SYXcocmF5Lm9yaWdpbik7XG4gICAgICAgIGxldCByYXdEaXIgPSBWZWN0b3JPcHMuaW50b1JhdyhyYXkuZGlyKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJheUNvbGxpZGVySGl0LmZyb21SYXcoY29sbGlkZXJzLCB0aGlzLnJhdy5jYXN0UmF5KGJvZGllcy5yYXcsIGNvbGxpZGVycy5yYXcsIHJhd09yaWcsIHJhd0RpciwgbWF4VG9pLCBzb2xpZCwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpKTtcbiAgICAgICAgcmF3T3JpZy5mcmVlKCk7XG4gICAgICAgIHJhd0Rpci5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uIGJldHdlZW4gYSByYXkgYW5kIGEgc2V0IG9mIGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogVGhpcyBhbHNvIGNvbXB1dGVzIHRoZSBub3JtYWwgYXQgdGhlIGhpdCBwb2ludC5cbiAgICAgKiBAcGFyYW0gY29sbGlkZXJzIC0gVGhlIHNldCBvZiBjb2xsaWRlcnMgdGFraW5nIHBhcnQgaW4gdGhpcyBwaXBlbGluZS5cbiAgICAgKiBAcGFyYW0gcmF5IC0gVGhlIHJheSB0byBjYXN0LlxuICAgICAqIEBwYXJhbSBtYXhUb2kgLSBUaGUgbWF4aW11bSB0aW1lLW9mLWltcGFjdCB0aGF0IGNhbiBiZSByZXBvcnRlZCBieSB0aGlzIGNhc3QuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgKiAgIGxpbWl0cyB0aGUgbGVuZ3RoIG9mIHRoZSByYXkgdG8gYHJheS5kaXIubm9ybSgpICogbWF4VG9pYC5cbiAgICAgKiBAcGFyYW0gc29saWQgLSBJZiBgZmFsc2VgIHRoZW4gdGhlIHJheSB3aWxsIGF0dGVtcHQgdG8gaGl0IHRoZSBib3VuZGFyeSBvZiBhIHNoYXBlLCBldmVuIGlmIGl0c1xuICAgICAqICAgb3JpZ2luIGFscmVhZHkgbGllcyBpbnNpZGUgb2YgYSBzaGFwZS4gSW4gb3RoZXIgdGVybXMsIGB0cnVlYCBpbXBsaWVzIHRoYXQgYWxsIHNoYXBlcyBhcmUgcGxhaW4sXG4gICAgICogICB3aGVyZWFzIGBmYWxzZWAgaW1wbGllcyB0aGF0IGFsbCBzaGFwZXMgYXJlIGhvbGxvdyBmb3IgdGhpcyByYXktY2FzdC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBzIC0gVXNlZCB0byBmaWx0ZXIgdGhlIGNvbGxpZGVycyB0aGF0IGNhbiBvciBjYW5ub3QgYmUgaGl0IGJ5IHRoZSByYXkuXG4gICAgICovXG4gICAgY2FzdFJheUFuZEdldE5vcm1hbChib2RpZXMsIGNvbGxpZGVycywgcmF5LCBtYXhUb2ksIHNvbGlkLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHksIGZpbHRlclByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmF3T3JpZyA9IFZlY3Rvck9wcy5pbnRvUmF3KHJheS5vcmlnaW4pO1xuICAgICAgICBsZXQgcmF3RGlyID0gVmVjdG9yT3BzLmludG9SYXcocmF5LmRpcik7XG4gICAgICAgIGxldCByZXN1bHQgPSBSYXlDb2xsaWRlckludGVyc2VjdGlvbi5mcm9tUmF3KGNvbGxpZGVycywgdGhpcy5yYXcuY2FzdFJheUFuZEdldE5vcm1hbChib2RpZXMucmF3LCBjb2xsaWRlcnMucmF3LCByYXdPcmlnLCByYXdEaXIsIG1heFRvaSwgc29saWQsIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSwgZmlsdGVyUHJlZGljYXRlKSk7XG4gICAgICAgIHJhd09yaWcuZnJlZSgpO1xuICAgICAgICByYXdEaXIuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXN0IGEgcmF5IGFuZCBjb2xsZWN0cyBhbGwgdGhlIGludGVyc2VjdGlvbnMgYmV0d2VlbiBhIHJheSBhbmQgdGhlIHNjZW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVycyAtIFRoZSBzZXQgb2YgY29sbGlkZXJzIHRha2luZyBwYXJ0IGluIHRoaXMgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHJheSAtIFRoZSByYXkgdG8gY2FzdC5cbiAgICAgKiBAcGFyYW0gbWF4VG9pIC0gVGhlIG1heGltdW0gdGltZS1vZi1pbXBhY3QgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgdGhpcyBjYXN0LiBUaGlzIGVmZmVjdGl2ZWx5XG4gICAgICogICBsaW1pdHMgdGhlIGxlbmd0aCBvZiB0aGUgcmF5IHRvIGByYXkuZGlyLm5vcm0oKSAqIG1heFRvaWAuXG4gICAgICogQHBhcmFtIHNvbGlkIC0gSWYgYGZhbHNlYCB0aGVuIHRoZSByYXkgd2lsbCBhdHRlbXB0IHRvIGhpdCB0aGUgYm91bmRhcnkgb2YgYSBzaGFwZSwgZXZlbiBpZiBpdHNcbiAgICAgKiAgIG9yaWdpbiBhbHJlYWR5IGxpZXMgaW5zaWRlIG9mIGEgc2hhcGUuIEluIG90aGVyIHRlcm1zLCBgdHJ1ZWAgaW1wbGllcyB0aGF0IGFsbCBzaGFwZXMgYXJlIHBsYWluLFxuICAgICAqICAgd2hlcmVhcyBgZmFsc2VgIGltcGxpZXMgdGhhdCBhbGwgc2hhcGVzIGFyZSBob2xsb3cgZm9yIHRoaXMgcmF5LWNhc3QuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFVzZWQgdG8gZmlsdGVyIHRoZSBjb2xsaWRlcnMgdGhhdCBjYW4gb3IgY2Fubm90IGJlIGhpdCBieSB0aGUgcmF5LlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBjYWxsZWQgb25jZSBwZXIgaGl0IChpbiBubyBwYXJ0aWN1bGFyIG9yZGVyKSBiZXR3ZWVuIGEgcmF5IGFuZCBhIGNvbGxpZGVyLlxuICAgICAqICAgSWYgdGhpcyBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRoZW4gdGhlIGNhc3Qgd2lsbCBzdG9wIGFuZCBubyBmdXJ0aGVyIGhpdHMgd2lsbCBiZSBkZXRlY3RlZC9yZXBvcnRlZC5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3Rpb25zV2l0aFJheShib2RpZXMsIGNvbGxpZGVycywgcmF5LCBtYXhUb2ksIHNvbGlkLCBjYWxsYmFjaywgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJhd09yaWcgPSBWZWN0b3JPcHMuaW50b1JhdyhyYXkub3JpZ2luKTtcbiAgICAgICAgbGV0IHJhd0RpciA9IFZlY3Rvck9wcy5pbnRvUmF3KHJheS5kaXIpO1xuICAgICAgICBsZXQgcmF3Q2FsbGJhY2sgPSAocmF3SW50ZXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhSYXlDb2xsaWRlckludGVyc2VjdGlvbi5mcm9tUmF3KGNvbGxpZGVycywgcmF3SW50ZXIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yYXcuaW50ZXJzZWN0aW9uc1dpdGhSYXkoYm9kaWVzLnJhdywgY29sbGlkZXJzLnJhdywgcmF3T3JpZywgcmF3RGlyLCBtYXhUb2ksIHNvbGlkLCByYXdDYWxsYmFjaywgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpO1xuICAgICAgICByYXdPcmlnLmZyZWUoKTtcbiAgICAgICAgcmF3RGlyLmZyZWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFuZGxlIG9mIHVwIHRvIG9uZSBjb2xsaWRlciBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVycyAtIFRoZSBzZXQgb2YgY29sbGlkZXJzIHRha2luZyBwYXJ0IGluIHRoaXMgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHNoYXBlUG9zIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzaGFwZSB1c2VkIGZvciB0aGUgaW50ZXJzZWN0aW9uIHRlc3QuXG4gICAgICogQHBhcmFtIHNoYXBlUm90IC0gVGhlIG9yaWVudGF0aW9uIG9mIHRoZSBzaGFwZSB1c2VkIGZvciB0aGUgaW50ZXJzZWN0aW9uIHRlc3QuXG4gICAgICogQHBhcmFtIHNoYXBlIC0gVGhlIHNoYXBlIHVzZWQgZm9yIHRoZSBpbnRlcnNlY3Rpb24gdGVzdC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBzIC0gVGhlIGJpdCBncm91cHMgYW5kIGZpbHRlciBhc3NvY2lhdGVkIHRvIHRoZSByYXksIGluIG9yZGVyIHRvIG9ubHlcbiAgICAgKiAgIGhpdCB0aGUgY29sbGlkZXJzIHdpdGggY29sbGlzaW9uIGdyb3VwcyBjb21wYXRpYmxlIHdpdGggdGhlIHJheSdzIGdyb3VwLlxuICAgICAqL1xuICAgIGludGVyc2VjdGlvbldpdGhTaGFwZShib2RpZXMsIGNvbGxpZGVycywgc2hhcGVQb3MsIHNoYXBlUm90LCBzaGFwZSwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJhd1BvcyA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlUG9zKTtcbiAgICAgICAgbGV0IHJhd1JvdCA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QpO1xuICAgICAgICBsZXQgcmF3U2hhcGUgPSBzaGFwZS5pbnRvUmF3KCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJhdy5pbnRlcnNlY3Rpb25XaXRoU2hhcGUoYm9kaWVzLnJhdywgY29sbGlkZXJzLnJhdywgcmF3UG9zLCByYXdSb3QsIHJhd1NoYXBlLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHksIGZpbHRlclByZWRpY2F0ZSk7XG4gICAgICAgIHJhd1Bvcy5mcmVlKCk7XG4gICAgICAgIHJhd1JvdC5mcmVlKCk7XG4gICAgICAgIHJhd1NoYXBlLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgcHJvamVjdGlvbiBvZiBhIHBvaW50IG9uIHRoZSBjbG9zZXN0IGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVycyAtIFRoZSBzZXQgb2YgY29sbGlkZXJzIHRha2luZyBwYXJ0IGluIHRoaXMgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHByb2plY3QuXG4gICAgICogQHBhcmFtIHNvbGlkIC0gSWYgdGhpcyBpcyBzZXQgdG8gYHRydWVgIHRoZW4gdGhlIGNvbGxpZGVyIHNoYXBlcyBhcmUgY29uc2lkZXJlZCB0b1xuICAgICAqICAgYmUgcGxhaW4gKGlmIHRoZSBwb2ludCBpcyBsb2NhdGVkIGluc2lkZSBvZiBhIHBsYWluIHNoYXBlLCBpdHMgcHJvamVjdGlvbiBpcyB0aGUgcG9pbnRcbiAgICAgKiAgIGl0c2VsZikuIElmIGl0IGlzIHNldCB0byBgZmFsc2VgIHRoZSBjb2xsaWRlciBzaGFwZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgaG9sbG93XG4gICAgICogICAoaWYgdGhlIHBvaW50IGlzIGxvY2F0ZWQgaW5zaWRlIG9mIGFuIGhvbGxvdyBzaGFwZSwgaXQgaXMgcHJvamVjdGVkIG9uIHRoZSBzaGFwZSdzXG4gICAgICogICBib3VuZGFyeSkuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFRoZSBiaXQgZ3JvdXBzIGFuZCBmaWx0ZXIgYXNzb2NpYXRlZCB0byB0aGUgcG9pbnQgdG8gcHJvamVjdCwgaW4gb3JkZXIgdG8gb25seVxuICAgICAqICAgcHJvamVjdCBvbiBjb2xsaWRlcnMgd2l0aCBjb2xsaXNpb24gZ3JvdXBzIGNvbXBhdGlibGUgd2l0aCB0aGUgcmF5J3MgZ3JvdXAuXG4gICAgICovXG4gICAgcHJvamVjdFBvaW50KGJvZGllcywgY29sbGlkZXJzLCBwb2ludCwgc29saWQsIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSwgZmlsdGVyUHJlZGljYXRlKSB7XG4gICAgICAgIGxldCByYXdQb2ludCA9IFZlY3Rvck9wcy5pbnRvUmF3KHBvaW50KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFBvaW50Q29sbGlkZXJQcm9qZWN0aW9uLmZyb21SYXcoY29sbGlkZXJzLCB0aGlzLnJhdy5wcm9qZWN0UG9pbnQoYm9kaWVzLnJhdywgY29sbGlkZXJzLnJhdywgcmF3UG9pbnQsIHNvbGlkLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHksIGZpbHRlclByZWRpY2F0ZSkpO1xuICAgICAgICByYXdQb2ludC5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHByb2plY3Rpb24gb2YgYSBwb2ludCBvbiB0aGUgY2xvc2VzdCBjb2xsaWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xsaWRlcnMgLSBUaGUgc2V0IG9mIGNvbGxpZGVycyB0YWtpbmcgcGFydCBpbiB0aGlzIHBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byBwcm9qZWN0LlxuICAgICAqIEBwYXJhbSBncm91cHMgLSBUaGUgYml0IGdyb3VwcyBhbmQgZmlsdGVyIGFzc29jaWF0ZWQgdG8gdGhlIHBvaW50IHRvIHByb2plY3QsIGluIG9yZGVyIHRvIG9ubHlcbiAgICAgKiAgIHByb2plY3Qgb24gY29sbGlkZXJzIHdpdGggY29sbGlzaW9uIGdyb3VwcyBjb21wYXRpYmxlIHdpdGggdGhlIHJheSdzIGdyb3VwLlxuICAgICAqL1xuICAgIHByb2plY3RQb2ludEFuZEdldEZlYXR1cmUoYm9kaWVzLCBjb2xsaWRlcnMsIHBvaW50LCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHksIGZpbHRlclByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmF3UG9pbnQgPSBWZWN0b3JPcHMuaW50b1Jhdyhwb2ludCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBQb2ludENvbGxpZGVyUHJvamVjdGlvbi5mcm9tUmF3KGNvbGxpZGVycywgdGhpcy5yYXcucHJvamVjdFBvaW50QW5kR2V0RmVhdHVyZShib2RpZXMucmF3LCBjb2xsaWRlcnMucmF3LCByYXdQb2ludCwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpKTtcbiAgICAgICAgcmF3UG9pbnQuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGFsbCB0aGUgY29sbGlkZXJzIGNvbnRhaW5pbmcgdGhlIGdpdmVuIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVycyAtIFRoZSBzZXQgb2YgY29sbGlkZXJzIHRha2luZyBwYXJ0IGluIHRoaXMgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHVzZWQgZm9yIHRoZSBjb250YWlubWVudCB0ZXN0LlxuICAgICAqIEBwYXJhbSBncm91cHMgLSBUaGUgYml0IGdyb3VwcyBhbmQgZmlsdGVyIGFzc29jaWF0ZWQgdG8gdGhlIHBvaW50IHRvIHRlc3QsIGluIG9yZGVyIHRvIG9ubHlcbiAgICAgKiAgIHRlc3Qgb24gY29sbGlkZXJzIHdpdGggY29sbGlzaW9uIGdyb3VwcyBjb21wYXRpYmxlIHdpdGggdGhlIHJheSdzIGdyb3VwLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIGhhbmRsZXMgb2YgZWFjaCBjb2xsaWRlciB3aXRoIGEgc2hhcGVcbiAgICAgKiAgIGNvbnRhaW5pbmcgdGhlIGBwb2ludGAuXG4gICAgICovXG4gICAgaW50ZXJzZWN0aW9uc1dpdGhQb2ludChib2RpZXMsIGNvbGxpZGVycywgcG9pbnQsIGNhbGxiYWNrLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHksIGZpbHRlclByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmF3UG9pbnQgPSBWZWN0b3JPcHMuaW50b1Jhdyhwb2ludCk7XG4gICAgICAgIHRoaXMucmF3LmludGVyc2VjdGlvbnNXaXRoUG9pbnQoYm9kaWVzLnJhdywgY29sbGlkZXJzLnJhdywgcmF3UG9pbnQsIGNhbGxiYWNrLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHksIGZpbHRlclByZWRpY2F0ZSk7XG4gICAgICAgIHJhd1BvaW50LmZyZWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FzdHMgYSBzaGFwZSBhdCBhIGNvbnN0YW50IGxpbmVhciB2ZWxvY2l0eSBhbmQgcmV0cmlldmUgdGhlIGZpcnN0IGNvbGxpZGVyIGl0IGhpdHMuXG4gICAgICogVGhpcyBpcyBzaW1pbGFyIHRvIHJheS1jYXN0aW5nIGV4Y2VwdCB0aGF0IHdlIGFyZSBjYXN0aW5nIGEgd2hvbGUgc2hhcGUgaW5zdGVhZCBvZlxuICAgICAqIGp1c3QgYSBwb2ludCAodGhlIHJheSBvcmlnaW4pLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVycyAtIFRoZSBzZXQgb2YgY29sbGlkZXJzIHRha2luZyBwYXJ0IGluIHRoaXMgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHNoYXBlUG9zIC0gVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHNoYXBlIHRvIGNhc3QuXG4gICAgICogQHBhcmFtIHNoYXBlUm90IC0gVGhlIGluaXRpYWwgcm90YXRpb24gb2YgdGhlIHNoYXBlIHRvIGNhc3QuXG4gICAgICogQHBhcmFtIHNoYXBlVmVsIC0gVGhlIGNvbnN0YW50IHZlbG9jaXR5IG9mIHRoZSBzaGFwZSB0byBjYXN0IChpLmUuIHRoZSBjYXN0IGRpcmVjdGlvbikuXG4gICAgICogQHBhcmFtIHNoYXBlIC0gVGhlIHNoYXBlIHRvIGNhc3QuXG4gICAgICogQHBhcmFtIHRhcmdldERpc3RhbmNlIOKIkiBJZiB0aGUgc2hhcGUgbW92ZXMgY2xvc2VyIHRvIHRoaXMgZGlzdGFuY2UgZnJvbSBhIGNvbGxpZGVyLCBhIGhpdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSBtYXhUb2kgLSBUaGUgbWF4aW11bSB0aW1lLW9mLWltcGFjdCB0aGF0IGNhbiBiZSByZXBvcnRlZCBieSB0aGlzIGNhc3QuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgKiAgIGxpbWl0cyB0aGUgZGlzdGFuY2UgdHJhdmVsZWQgYnkgdGhlIHNoYXBlIHRvIGBzaGFwZVZlbC5ub3JtKCkgKiBtYXhUb2lgLlxuICAgICAqIEBwYXJhbSBzdG9wQXRQZW5ldHJhdGlvbiAtIElmIHNldCB0byBgZmFsc2VgLCB0aGUgbGluZWFyIHNoYXBlLWNhc3Qgd29u4oCZdCBpbW1lZGlhdGVseSBzdG9wIGlmXG4gICAgICogICB0aGUgc2hhcGUgaXMgcGVuZXRyYXRpbmcgYW5vdGhlciBzaGFwZSBhdCBpdHMgc3RhcnRpbmcgcG9pbnQgKiphbmQqKiBpdHMgdHJhamVjdG9yeSBpcyBzdWNoXG4gICAgICogICB0aGF0IGl04oCZcyBvbiBhIHBhdGggdG8gZXhpdCB0aGF0IHBlbmV0cmF0aW9uIHN0YXRlLlxuICAgICAqIEBwYXJhbSBncm91cHMgLSBUaGUgYml0IGdyb3VwcyBhbmQgZmlsdGVyIGFzc29jaWF0ZWQgdG8gdGhlIHNoYXBlIHRvIGNhc3QsIGluIG9yZGVyIHRvIG9ubHlcbiAgICAgKiAgIHRlc3Qgb24gY29sbGlkZXJzIHdpdGggY29sbGlzaW9uIGdyb3VwcyBjb21wYXRpYmxlIHdpdGggdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICBjYXN0U2hhcGUoYm9kaWVzLCBjb2xsaWRlcnMsIHNoYXBlUG9zLCBzaGFwZVJvdCwgc2hhcGVWZWwsIHNoYXBlLCB0YXJnZXREaXN0YW5jZSwgbWF4VG9pLCBzdG9wQXRQZW5ldHJhdGlvbiwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJhd1BvcyA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlUG9zKTtcbiAgICAgICAgbGV0IHJhd1JvdCA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QpO1xuICAgICAgICBsZXQgcmF3VmVsID0gVmVjdG9yT3BzLmludG9SYXcoc2hhcGVWZWwpO1xuICAgICAgICBsZXQgcmF3U2hhcGUgPSBzaGFwZS5pbnRvUmF3KCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBDb2xsaWRlclNoYXBlQ2FzdEhpdC5mcm9tUmF3KGNvbGxpZGVycywgdGhpcy5yYXcuY2FzdFNoYXBlKGJvZGllcy5yYXcsIGNvbGxpZGVycy5yYXcsIHJhd1BvcywgcmF3Um90LCByYXdWZWwsIHJhd1NoYXBlLCB0YXJnZXREaXN0YW5jZSwgbWF4VG9pLCBzdG9wQXRQZW5ldHJhdGlvbiwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpKTtcbiAgICAgICAgcmF3UG9zLmZyZWUoKTtcbiAgICAgICAgcmF3Um90LmZyZWUoKTtcbiAgICAgICAgcmF3VmVsLmZyZWUoKTtcbiAgICAgICAgcmF3U2hhcGUuZnJlZSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhbGwgdGhlIGNvbGxpZGVycyBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVycyAtIFRoZSBzZXQgb2YgY29sbGlkZXJzIHRha2luZyBwYXJ0IGluIHRoaXMgcGlwZWxpbmUuXG4gICAgICogQHBhcmFtIHNoYXBlUG9zIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzaGFwZSB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSBzaGFwZVJvdCAtIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc2hhcGUgdG8gdGVzdC5cbiAgICAgKiBAcGFyYW0gc2hhcGUgLSBUaGUgc2hhcGUgdG8gdGVzdC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBzIC0gVGhlIGJpdCBncm91cHMgYW5kIGZpbHRlciBhc3NvY2lhdGVkIHRvIHRoZSBzaGFwZSB0byB0ZXN0LCBpbiBvcmRlciB0byBvbmx5XG4gICAgICogICB0ZXN0IG9uIGNvbGxpZGVycyB3aXRoIGNvbGxpc2lvbiBncm91cHMgY29tcGF0aWJsZSB3aXRoIHRoaXMgZ3JvdXAuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgaGFuZGxlcyBvZiBlYWNoIGNvbGxpZGVyIGludGVyc2VjdGluZyB0aGUgYHNoYXBlYC5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3Rpb25zV2l0aFNoYXBlKGJvZGllcywgY29sbGlkZXJzLCBzaGFwZVBvcywgc2hhcGVSb3QsIHNoYXBlLCBjYWxsYmFjaywgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJhd1BvcyA9IFZlY3Rvck9wcy5pbnRvUmF3KHNoYXBlUG9zKTtcbiAgICAgICAgbGV0IHJhd1JvdCA9IFJvdGF0aW9uT3BzLmludG9SYXcoc2hhcGVSb3QpO1xuICAgICAgICBsZXQgcmF3U2hhcGUgPSBzaGFwZS5pbnRvUmF3KCk7XG4gICAgICAgIHRoaXMucmF3LmludGVyc2VjdGlvbnNXaXRoU2hhcGUoYm9kaWVzLnJhdywgY29sbGlkZXJzLnJhdywgcmF3UG9zLCByYXdSb3QsIHJhd1NoYXBlLCBjYWxsYmFjaywgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpO1xuICAgICAgICByYXdQb3MuZnJlZSgpO1xuICAgICAgICByYXdSb3QuZnJlZSgpO1xuICAgICAgICByYXdTaGFwZS5mcmVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBoYW5kbGVzIG9mIGFsbCB0aGUgY29sbGlkZXJzIHdpdGggYW4gQUFCQiBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIEFBQkIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWFiYkNlbnRlciAtIFRoZSBjZW50ZXIgb2YgdGhlIEFBQkIgdG8gdGVzdC5cbiAgICAgKiBAcGFyYW0gYWFiYkhhbGZFeHRlbnRzIC0gVGhlIGhhbGYtZXh0ZW50cyBvZiB0aGUgQUFCQiB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGhhbmRsZXMgb2YgYWxsIHRoZSBjb2xsaWRlcnNcbiAgICAgKiAgICAgICAgICAgICAgICAgICBjdXJyZW50bHkgaW50ZXJzZWN0aW5nIHRoZSBnaXZlbiBBQUJCLlxuICAgICAqL1xuICAgIGNvbGxpZGVyc1dpdGhBYWJiSW50ZXJzZWN0aW5nQWFiYihhYWJiQ2VudGVyLCBhYWJiSGFsZkV4dGVudHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCByYXdDZW50ZXIgPSBWZWN0b3JPcHMuaW50b1JhdyhhYWJiQ2VudGVyKTtcbiAgICAgICAgbGV0IHJhd0hhbGZFeHRlbnRzID0gVmVjdG9yT3BzLmludG9SYXcoYWFiYkhhbGZFeHRlbnRzKTtcbiAgICAgICAgdGhpcy5yYXcuY29sbGlkZXJzV2l0aEFhYmJJbnRlcnNlY3RpbmdBYWJiKHJhd0NlbnRlciwgcmF3SGFsZkV4dGVudHMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmF3Q2VudGVyLmZyZWUoKTtcbiAgICAgICAgcmF3SGFsZkV4dGVudHMuZnJlZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5X3BpcGVsaW5lLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js ***!
  \********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SerializationPipeline: () => (/* binding */ SerializationPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./world */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/world.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _world__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _world__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass SerializationPipeline {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawSerializationPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {\n        let rawGra = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(gravity);\n        const res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        rawGra.free();\n        return res;\n    }\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    deserializeAll(data) {\n        return _world__WEBPACK_IMPORTED_MODULE_2__.World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n//# sourceMappingURL=serialization_pipeline.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3BpcGVsaW5lL3NlcmlhbGl6YXRpb25fcGlwZWxpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrRDtBQUNkO0FBQ0o7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhCQUE4QiwwREFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlDQUFLO0FBQ3BCO0FBQ0E7QUFDQSxrRCIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxAZGltZm9yZ2VcXHJhcGllcjJkXFxwaXBlbGluZVxcc2VyaWFsaXphdGlvbl9waXBlbGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXdTZXJpYWxpemF0aW9uUGlwZWxpbmUgfSBmcm9tIFwiLi4vcmF3XCI7XG5pbXBvcnQgeyBWZWN0b3JPcHMgfSBmcm9tIFwiLi4vbWF0aFwiO1xuaW1wb3J0IHsgV29ybGQgfSBmcm9tIFwiLi93b3JsZFwiO1xuLyoqXG4gKiBBIHBpcGVsaW5lIGZvciBzZXJpYWxpemluZyB0aGUgcGh5c2ljcyBzY2VuZS5cbiAqXG4gKiBUbyBhdm9pZCBsZWFraW5nIFdBU00gcmVzb3VyY2VzLCB0aGlzIE1VU1QgYmUgZnJlZWQgbWFudWFsbHkgd2l0aCBgcXVlcnlQaXBlbGluZS5mcmVlKClgXG4gKiBvbmNlIHlvdSBhcmUgZG9uZSB1c2luZyBpdCAoYW5kIGFsbCB0aGUgcmlnaWQtYm9kaWVzIGl0IGNyZWF0ZWQpLlxuICovXG5leHBvcnQgY2xhc3MgU2VyaWFsaXphdGlvblBpcGVsaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihyYXcpIHtcbiAgICAgICAgdGhpcy5yYXcgPSByYXcgfHwgbmV3IFJhd1NlcmlhbGl6YXRpb25QaXBlbGluZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBXQVNNIG1lbW9yeSBvY2N1cGllZCBieSB0aGlzIHNlcmlhbGl6YXRpb24gcGlwZWxpbmUuXG4gICAgICovXG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKCEhdGhpcy5yYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LmZyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhdyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIGEgY29tcGxldGUgcGh5c2ljcyBzdGF0ZSBpbnRvIGEgc2luZ2xlIGJ5dGUgYXJyYXkuXG4gICAgICogQHBhcmFtIGdyYXZpdHkgLSBUaGUgY3VycmVudCBncmF2aXR5IGFmZmVjdGluZyB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW50ZWdyYXRpb25QYXJhbWV0ZXJzIC0gVGhlIGludGVncmF0aW9uIHBhcmFtZXRlcnMgb2YgdGhlIHNpbXVsYXRpb24uXG4gICAgICogQHBhcmFtIGJyb2FkUGhhc2UgLSBUaGUgYnJvYWQtcGhhc2Ugb2YgdGhlIHNpbXVsYXRpb24uXG4gICAgICogQHBhcmFtIG5hcnJvd1BoYXNlIC0gVGhlIG5hcnJvdy1waGFzZSBvZiB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBAcGFyYW0gYm9kaWVzIC0gVGhlIHJpZ2lkLWJvZGllcyB0YWtpbmcgcGFydCBpbnRvIHRoZSBzaW11bGF0aW9uLlxuICAgICAqIEBwYXJhbSBjb2xsaWRlcnMgLSBUaGUgY29sbGlkZXJzIHRha2luZyBwYXJ0IGludG8gdGhlIHNpbXVsYXRpb24uXG4gICAgICogQHBhcmFtIGltcHVsc2VKb2ludHMgLSBUaGUgaW1wdWxzZSBqb2ludHMgdGFraW5nIHBhcnQgaW50byB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKiBAcGFyYW0gbXVsdGlib2R5Sm9pbnRzIC0gVGhlIG11bHRpYm9keSBqb2ludHMgdGFraW5nIHBhcnQgaW50byB0aGUgc2ltdWxhdGlvbi5cbiAgICAgKi9cbiAgICBzZXJpYWxpemVBbGwoZ3Jhdml0eSwgaW50ZWdyYXRpb25QYXJhbWV0ZXJzLCBpc2xhbmRzLCBicm9hZFBoYXNlLCBuYXJyb3dQaGFzZSwgYm9kaWVzLCBjb2xsaWRlcnMsIGltcHVsc2VKb2ludHMsIG11bHRpYm9keUpvaW50cykge1xuICAgICAgICBsZXQgcmF3R3JhID0gVmVjdG9yT3BzLmludG9SYXcoZ3Jhdml0eSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmF3LnNlcmlhbGl6ZUFsbChyYXdHcmEsIGludGVncmF0aW9uUGFyYW1ldGVycy5yYXcsIGlzbGFuZHMucmF3LCBicm9hZFBoYXNlLnJhdywgbmFycm93UGhhc2UucmF3LCBib2RpZXMucmF3LCBjb2xsaWRlcnMucmF3LCBpbXB1bHNlSm9pbnRzLnJhdywgbXVsdGlib2R5Sm9pbnRzLnJhdyk7XG4gICAgICAgIHJhd0dyYS5mcmVlKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplIHRoZSBjb21wbGV0ZSBwaHlzaWNzIHN0YXRlIGZyb20gYSBzaW5nbGUgYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGJ5dGUgYXJyYXkgdG8gZGVzZXJpYWxpemUuXG4gICAgICovXG4gICAgZGVzZXJpYWxpemVBbGwoZGF0YSkge1xuICAgICAgICByZXR1cm4gV29ybGQuZnJvbVJhdyh0aGlzLnJhdy5kZXNlcmlhbGl6ZUFsbChkYXRhKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXphdGlvbl9waXBlbGluZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/world.js":
/*!***************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/pipeline/world.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: () => (/* binding */ World)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/broad_phase.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/narrow_phase.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geometry */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/geometry/collider_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dynamics */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dynamics */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/island_manager.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dynamics */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamics */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../dynamics */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dynamics */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../math */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./physics_pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js\");\n/* harmony import */ var _query_pipeline__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./query_pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js\");\n/* harmony import */ var _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./serialization_pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js\");\n/* harmony import */ var _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./debug_render_pipeline */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js\");\n/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../control */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/control/character_controller.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_dynamics__WEBPACK_IMPORTED_MODULE_0__, _dynamics__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _dynamics__WEBPACK_IMPORTED_MODULE_4__, _geometry__WEBPACK_IMPORTED_MODULE_5__, _dynamics__WEBPACK_IMPORTED_MODULE_6__, _dynamics__WEBPACK_IMPORTED_MODULE_7__, _dynamics__WEBPACK_IMPORTED_MODULE_8__, _query_pipeline__WEBPACK_IMPORTED_MODULE_9__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__, _math__WEBPACK_IMPORTED_MODULE_13__, _control__WEBPACK_IMPORTED_MODULE_14__]);\n([_dynamics__WEBPACK_IMPORTED_MODULE_0__, _dynamics__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _dynamics__WEBPACK_IMPORTED_MODULE_4__, _geometry__WEBPACK_IMPORTED_MODULE_5__, _dynamics__WEBPACK_IMPORTED_MODULE_6__, _dynamics__WEBPACK_IMPORTED_MODULE_7__, _dynamics__WEBPACK_IMPORTED_MODULE_8__, _query_pipeline__WEBPACK_IMPORTED_MODULE_9__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__, _math__WEBPACK_IMPORTED_MODULE_13__, _control__WEBPACK_IMPORTED_MODULE_14__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nclass World {\n    constructor(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {\n        this.gravity = gravity;\n        this.integrationParameters = new _dynamics__WEBPACK_IMPORTED_MODULE_0__.IntegrationParameters(rawIntegrationParameters);\n        this.islands = new _dynamics__WEBPACK_IMPORTED_MODULE_1__.IslandManager(rawIslands);\n        this.broadPhase = new _geometry__WEBPACK_IMPORTED_MODULE_2__.BroadPhase(rawBroadPhase);\n        this.narrowPhase = new _geometry__WEBPACK_IMPORTED_MODULE_3__.NarrowPhase(rawNarrowPhase);\n        this.bodies = new _dynamics__WEBPACK_IMPORTED_MODULE_4__.RigidBodySet(rawBodies);\n        this.colliders = new _geometry__WEBPACK_IMPORTED_MODULE_5__.ColliderSet(rawColliders);\n        this.impulseJoints = new _dynamics__WEBPACK_IMPORTED_MODULE_6__.ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new _dynamics__WEBPACK_IMPORTED_MODULE_7__.MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new _dynamics__WEBPACK_IMPORTED_MODULE_8__.CCDSolver(rawCCDSolver);\n        this.queryPipeline = new _query_pipeline__WEBPACK_IMPORTED_MODULE_9__.QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new _physics_pipeline__WEBPACK_IMPORTED_MODULE_10__.PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__.SerializationPipeline(rawSerializationPipeline);\n        this.debugRenderPipeline = new _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__.DebugRenderPipeline(rawDebugRenderPipeline);\n        this.characterControllers = new Set();\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        return new World(_math__WEBPACK_IMPORTED_MODULE_13__.VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());\n    }\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    takeSnapshot() {\n        return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);\n    }\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    static restoreSnapshot(data) {\n        let deser = new _serialization_pipeline__WEBPACK_IMPORTED_MODULE_11__.SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    debugRender() {\n        this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);\n        return new _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_12__.DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);\n    }\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    step(eventQueue, hooks) {\n        this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);\n        this.queryPipeline.update(this.colliders);\n    }\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);\n    }\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.colliders);\n    }\n    /**\n     * The current simulation timestep.\n     */\n    get timestep() {\n        return this.integrationParameters.dt;\n    }\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt) {\n        this.integrationParameters.dt = dt;\n    }\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * See the documentation of the `World.lengthUnit` setter for further details.\n     */\n    get lengthUnit() {\n        return this.integrationParameters.lengthUnit;\n    }\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * This value is used internally to estimate some length-based tolerance. In particular, the\n     * values `IntegrationParameters.allowedLinearError`,\n     * `IntegrationParameters.maxPenetrationCorrection`,\n     * `IntegrationParameters.predictionDistance`, `RigidBodyActivation.linearThreshold`\n     * are scaled by this value implicitly.\n     *\n     * This value can be understood as the number of units-per-meter in your physical world compared\n     * to a human-sized world in meter. For example, in a 2d game, if your typical object size is 100\n     * pixels, set the `[`Self::length_unit`]` parameter to 100.0. The physics engine will interpret\n     * it as if 100 pixels is equivalent to 1 meter in its various internal threshold.\n     * (default `1.0`).\n     */\n    set lengthUnit(unitsPerMeter) {\n        this.integrationParameters.lengthUnit = unitsPerMeter;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.integrationParameters.numSolverIterations;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */\n    set numSolverIterations(niter) {\n        this.integrationParameters.numSolverIterations = niter;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */\n    set numAdditionalFrictionIterations(niter) {\n        this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.integrationParameters.numInternalPgsIterations;\n    }\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */\n    set numInternalPgsIterations(niter) {\n        this.integrationParameters.numInternalPgsIterations = niter;\n    }\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n    switchToStandardPgsSolver() {\n        this.integrationParameters.switchToStandardPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    switchToSmallStepsPgsSolver() {\n        this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12. Warmstarting is disabled.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    createRigidBody(body) {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the character’s chape and its environment.\n     */\n    createCharacterController(offset) {\n        let controller = new _control__WEBPACK_IMPORTED_MODULE_14__.KinematicCharacterController(offset, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);\n        this.characterControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    removeCharacterController(controller) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    createCollider(desc, parent) {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createImpulseJoint(params, parent1, parent2, wakeUp) {\n        return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createMultibodyJoint(params, parent1, parent2, wakeUp) {\n        return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    getRigidBody(handle) {\n        return this.bodies.get(handle);\n    }\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    getCollider(handle) {\n        return this.colliders.get(handle);\n    }\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    getImpulseJoint(handle) {\n        return this.impulseJoints.get(handle);\n    }\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    getMultibodyJoint(handle) {\n        return this.multibodyJoints.get(handle);\n    }\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    removeRigidBody(body) {\n        if (this.bodies) {\n            this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);\n        }\n    }\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    removeCollider(collider, wakeUp) {\n        if (this.colliders) {\n            this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);\n        }\n    }\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeImpulseJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeMultibodyJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    forEachCollider(f) {\n        this.colliders.forEach(f);\n    }\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachRigidBody(f) {\n        this.bodies.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachActiveRigidBody(f) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRay(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let handle = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPoint(this.bodies, this.colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, point, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, point, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castShape(this.bodies, this.colliders, shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, this.colliders.castClosure(callback));\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.narrowPhase.contactPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.narrowPhase.intersectionPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);\n    }\n}\n//# sourceMappingURL=world.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3BpcGVsaW5lL3dvcmxkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0U7QUFDNkQ7QUFDN0Y7QUFDaUI7QUFDSjtBQUNnQjtBQUNpQjtBQUN4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx5Q0FBeUMsNERBQXFCO0FBQzlELDJCQUEyQixvREFBYTtBQUN4Qyw4QkFBOEIsaURBQVU7QUFDeEMsK0JBQStCLGtEQUFXO0FBQzFDLDBCQUEwQixtREFBWTtBQUN0Qyw2QkFBNkIsa0RBQVc7QUFDeEMsaUNBQWlDLHNEQUFlO0FBQ2hELG1DQUFtQyx3REFBaUI7QUFDcEQsNkJBQTZCLGdEQUFTO0FBQ3RDLGlDQUFpQywwREFBYTtBQUM5QyxtQ0FBbUMsK0RBQWU7QUFDbEQseUNBQXlDLDJFQUFxQjtBQUM5RCx1Q0FBdUMsd0VBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkVBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVFQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1FQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUMiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxccGlwZWxpbmVcXHdvcmxkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJyb2FkUGhhc2UsIENvbGxpZGVyU2V0LCBOYXJyb3dQaGFzZSwgfSBmcm9tIFwiLi4vZ2VvbWV0cnlcIjtcbmltcG9ydCB7IENDRFNvbHZlciwgSW50ZWdyYXRpb25QYXJhbWV0ZXJzLCBJc2xhbmRNYW5hZ2VyLCBJbXB1bHNlSm9pbnRTZXQsIE11bHRpYm9keUpvaW50U2V0LCBSaWdpZEJvZHlTZXQsIH0gZnJvbSBcIi4uL2R5bmFtaWNzXCI7XG5pbXBvcnQgeyBWZWN0b3JPcHMgfSBmcm9tIFwiLi4vbWF0aFwiO1xuaW1wb3J0IHsgUGh5c2ljc1BpcGVsaW5lIH0gZnJvbSBcIi4vcGh5c2ljc19waXBlbGluZVwiO1xuaW1wb3J0IHsgUXVlcnlQaXBlbGluZSB9IGZyb20gXCIuL3F1ZXJ5X3BpcGVsaW5lXCI7XG5pbXBvcnQgeyBTZXJpYWxpemF0aW9uUGlwZWxpbmUgfSBmcm9tIFwiLi9zZXJpYWxpemF0aW9uX3BpcGVsaW5lXCI7XG5pbXBvcnQgeyBEZWJ1Z1JlbmRlckJ1ZmZlcnMsIERlYnVnUmVuZGVyUGlwZWxpbmUgfSBmcm9tIFwiLi9kZWJ1Z19yZW5kZXJfcGlwZWxpbmVcIjtcbmltcG9ydCB7IEtpbmVtYXRpY0NoYXJhY3RlckNvbnRyb2xsZXIgfSBmcm9tIFwiLi4vY29udHJvbFwiO1xuLyoqXG4gKiBUaGUgcGh5c2ljcyB3b3JsZC5cbiAqXG4gKiBUaGlzIGNvbnRhaW5zIGFsbCB0aGUgZGF0YS1zdHJ1Y3R1cmVzIG5lY2Vzc2FyeSBmb3IgY3JlYXRpbmcgYW5kIHNpbXVsYXRpbmdcbiAqIGJvZGllcyB3aXRoIGNvbnRhY3RzLCBqb2ludHMsIGFuZCBleHRlcm5hbCBmb3JjZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JsZCB7XG4gICAgY29uc3RydWN0b3IoZ3Jhdml0eSwgcmF3SW50ZWdyYXRpb25QYXJhbWV0ZXJzLCByYXdJc2xhbmRzLCByYXdCcm9hZFBoYXNlLCByYXdOYXJyb3dQaGFzZSwgcmF3Qm9kaWVzLCByYXdDb2xsaWRlcnMsIHJhd0ltcHVsc2VKb2ludHMsIHJhd011bHRpYm9keUpvaW50cywgcmF3Q0NEU29sdmVyLCByYXdRdWVyeVBpcGVsaW5lLCByYXdQaHlzaWNzUGlwZWxpbmUsIHJhd1NlcmlhbGl6YXRpb25QaXBlbGluZSwgcmF3RGVidWdSZW5kZXJQaXBlbGluZSkge1xuICAgICAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICAgICAgICB0aGlzLmludGVncmF0aW9uUGFyYW1ldGVycyA9IG5ldyBJbnRlZ3JhdGlvblBhcmFtZXRlcnMocmF3SW50ZWdyYXRpb25QYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pc2xhbmRzID0gbmV3IElzbGFuZE1hbmFnZXIocmF3SXNsYW5kcyk7XG4gICAgICAgIHRoaXMuYnJvYWRQaGFzZSA9IG5ldyBCcm9hZFBoYXNlKHJhd0Jyb2FkUGhhc2UpO1xuICAgICAgICB0aGlzLm5hcnJvd1BoYXNlID0gbmV3IE5hcnJvd1BoYXNlKHJhd05hcnJvd1BoYXNlKTtcbiAgICAgICAgdGhpcy5ib2RpZXMgPSBuZXcgUmlnaWRCb2R5U2V0KHJhd0JvZGllcyk7XG4gICAgICAgIHRoaXMuY29sbGlkZXJzID0gbmV3IENvbGxpZGVyU2V0KHJhd0NvbGxpZGVycyk7XG4gICAgICAgIHRoaXMuaW1wdWxzZUpvaW50cyA9IG5ldyBJbXB1bHNlSm9pbnRTZXQocmF3SW1wdWxzZUpvaW50cyk7XG4gICAgICAgIHRoaXMubXVsdGlib2R5Sm9pbnRzID0gbmV3IE11bHRpYm9keUpvaW50U2V0KHJhd011bHRpYm9keUpvaW50cyk7XG4gICAgICAgIHRoaXMuY2NkU29sdmVyID0gbmV3IENDRFNvbHZlcihyYXdDQ0RTb2x2ZXIpO1xuICAgICAgICB0aGlzLnF1ZXJ5UGlwZWxpbmUgPSBuZXcgUXVlcnlQaXBlbGluZShyYXdRdWVyeVBpcGVsaW5lKTtcbiAgICAgICAgdGhpcy5waHlzaWNzUGlwZWxpbmUgPSBuZXcgUGh5c2ljc1BpcGVsaW5lKHJhd1BoeXNpY3NQaXBlbGluZSk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXphdGlvblBpcGVsaW5lID0gbmV3IFNlcmlhbGl6YXRpb25QaXBlbGluZShyYXdTZXJpYWxpemF0aW9uUGlwZWxpbmUpO1xuICAgICAgICB0aGlzLmRlYnVnUmVuZGVyUGlwZWxpbmUgPSBuZXcgRGVidWdSZW5kZXJQaXBlbGluZShyYXdEZWJ1Z1JlbmRlclBpcGVsaW5lKTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXJDb250cm9sbGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5pbXB1bHNlSm9pbnRzLmZpbmFsaXplRGVzZXJpYWxpemF0aW9uKHRoaXMuYm9kaWVzKTtcbiAgICAgICAgdGhpcy5ib2RpZXMuZmluYWxpemVEZXNlcmlhbGl6YXRpb24odGhpcy5jb2xsaWRlcnMpO1xuICAgICAgICB0aGlzLmNvbGxpZGVycy5maW5hbGl6ZURlc2VyaWFsaXphdGlvbih0aGlzLmJvZGllcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgdGhlIFdBU00gbWVtb3J5IG9jY3VwaWVkIGJ5IHRoaXMgcGh5c2ljcyB3b3JsZC5cbiAgICAgKlxuICAgICAqIEFsbCB0aGUgZmllbGRzIG9mIHRoaXMgcGh5c2ljcyB3b3JsZCB3aWxsIGJlIGZyZWVkIGFzIHdlbGwsXG4gICAgICogc28gdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIHRoZWlyIGAuZnJlZSgpYCBtZXRob2RzIGluZGl2aWR1YWxseS5cbiAgICAgKi9cbiAgICBmcmVlKCkge1xuICAgICAgICB0aGlzLmludGVncmF0aW9uUGFyYW1ldGVycy5mcmVlKCk7XG4gICAgICAgIHRoaXMuaXNsYW5kcy5mcmVlKCk7XG4gICAgICAgIHRoaXMuYnJvYWRQaGFzZS5mcmVlKCk7XG4gICAgICAgIHRoaXMubmFycm93UGhhc2UuZnJlZSgpO1xuICAgICAgICB0aGlzLmJvZGllcy5mcmVlKCk7XG4gICAgICAgIHRoaXMuY29sbGlkZXJzLmZyZWUoKTtcbiAgICAgICAgdGhpcy5pbXB1bHNlSm9pbnRzLmZyZWUoKTtcbiAgICAgICAgdGhpcy5tdWx0aWJvZHlKb2ludHMuZnJlZSgpO1xuICAgICAgICB0aGlzLmNjZFNvbHZlci5mcmVlKCk7XG4gICAgICAgIHRoaXMucXVlcnlQaXBlbGluZS5mcmVlKCk7XG4gICAgICAgIHRoaXMucGh5c2ljc1BpcGVsaW5lLmZyZWUoKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemF0aW9uUGlwZWxpbmUuZnJlZSgpO1xuICAgICAgICB0aGlzLmRlYnVnUmVuZGVyUGlwZWxpbmUuZnJlZSgpO1xuICAgICAgICB0aGlzLmNoYXJhY3RlckNvbnRyb2xsZXJzLmZvckVhY2goKGNvbnRyb2xsZXIpID0+IGNvbnRyb2xsZXIuZnJlZSgpKTtcbiAgICAgICAgdGhpcy5pbnRlZ3JhdGlvblBhcmFtZXRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNsYW5kcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5icm9hZFBoYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5hcnJvd1BoYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmJvZGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb2xsaWRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2NkU29sdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmltcHVsc2VKb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubXVsdGlib2R5Sm9pbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnF1ZXJ5UGlwZWxpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGh5c2ljc1BpcGVsaW5lID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNlcmlhbGl6YXRpb25QaXBlbGluZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kZWJ1Z1JlbmRlclBpcGVsaW5lID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNoYXJhY3RlckNvbnRyb2xsZXJzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJhdyhyYXcpIHtcbiAgICAgICAgaWYgKCFyYXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JsZChWZWN0b3JPcHMuZnJvbVJhdyhyYXcudGFrZUdyYXZpdHkoKSksIHJhdy50YWtlSW50ZWdyYXRpb25QYXJhbWV0ZXJzKCksIHJhdy50YWtlSXNsYW5kTWFuYWdlcigpLCByYXcudGFrZUJyb2FkUGhhc2UoKSwgcmF3LnRha2VOYXJyb3dQaGFzZSgpLCByYXcudGFrZUJvZGllcygpLCByYXcudGFrZUNvbGxpZGVycygpLCByYXcudGFrZUltcHVsc2VKb2ludHMoKSwgcmF3LnRha2VNdWx0aWJvZHlKb2ludHMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgc25hcHNob3Qgb2YgdGhpcyB3b3JsZC5cbiAgICAgKlxuICAgICAqIFVzZSBgV29ybGQucmVzdG9yZVNuYXBzaG90YCB0byBjcmVhdGUgYSBuZXcgcGh5c2ljcyB3b3JsZCB3aXRoIGEgc3RhdGUgaWRlbnRpY2FsIHRvXG4gICAgICogdGhlIHN0YXRlIHdoZW4gYC50YWtlU25hcHNob3QoKWAgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIHRha2VTbmFwc2hvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXphdGlvblBpcGVsaW5lLnNlcmlhbGl6ZUFsbCh0aGlzLmdyYXZpdHksIHRoaXMuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLCB0aGlzLmlzbGFuZHMsIHRoaXMuYnJvYWRQaGFzZSwgdGhpcy5uYXJyb3dQaGFzZSwgdGhpcy5ib2RpZXMsIHRoaXMuY29sbGlkZXJzLCB0aGlzLmltcHVsc2VKb2ludHMsIHRoaXMubXVsdGlib2R5Sm9pbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwaHlzaWNzIHdvcmxkIGZyb20gYSBzbmFwc2hvdC5cbiAgICAgKlxuICAgICAqIFRoaXMgbmV3IHBoeXNpY3Mgd29ybGQgd2lsbCBiZSBhbiBpZGVudGljYWwgY29weSBvZiB0aGUgc25hcHNob3RlZCBwaHlzaWNzIHdvcmxkLlxuICAgICAqL1xuICAgIHN0YXRpYyByZXN0b3JlU25hcHNob3QoZGF0YSkge1xuICAgICAgICBsZXQgZGVzZXIgPSBuZXcgU2VyaWFsaXphdGlvblBpcGVsaW5lKCk7XG4gICAgICAgIHJldHVybiBkZXNlci5kZXNlcmlhbGl6ZUFsbChkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYWxsIHRoZSBsaW5lcyAoYW5kIHRoZWlyIGNvbG9ycykgbmVlZGVkIHRvIHJlbmRlciB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgZGVidWdSZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuZGVidWdSZW5kZXJQaXBlbGluZS5yZW5kZXIodGhpcy5ib2RpZXMsIHRoaXMuY29sbGlkZXJzLCB0aGlzLmltcHVsc2VKb2ludHMsIHRoaXMubXVsdGlib2R5Sm9pbnRzLCB0aGlzLm5hcnJvd1BoYXNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWJ1Z1JlbmRlckJ1ZmZlcnModGhpcy5kZWJ1Z1JlbmRlclBpcGVsaW5lLnZlcnRpY2VzLCB0aGlzLmRlYnVnUmVuZGVyUGlwZWxpbmUuY29sb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWR2YW5jZSB0aGUgc2ltdWxhdGlvbiBieSBvbmUgdGltZSBzdGVwLlxuICAgICAqXG4gICAgICogQWxsIGV2ZW50cyBnZW5lcmF0ZWQgYnkgdGhlIHBoeXNpY3MgZW5naW5lIGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIEV2ZW50UXVldWUgLSAob3B0aW9uYWwpIHN0cnVjdHVyZSByZXNwb25zaWJsZSBmb3IgY29sbGVjdGluZ1xuICAgICAqICAgZXZlbnRzIGdlbmVyYXRlZCBieSB0aGUgcGh5c2ljcyBlbmdpbmUuXG4gICAgICovXG4gICAgc3RlcChldmVudFF1ZXVlLCBob29rcykge1xuICAgICAgICB0aGlzLnBoeXNpY3NQaXBlbGluZS5zdGVwKHRoaXMuZ3Jhdml0eSwgdGhpcy5pbnRlZ3JhdGlvblBhcmFtZXRlcnMsIHRoaXMuaXNsYW5kcywgdGhpcy5icm9hZFBoYXNlLCB0aGlzLm5hcnJvd1BoYXNlLCB0aGlzLmJvZGllcywgdGhpcy5jb2xsaWRlcnMsIHRoaXMuaW1wdWxzZUpvaW50cywgdGhpcy5tdWx0aWJvZHlKb2ludHMsIHRoaXMuY2NkU29sdmVyLCBldmVudFF1ZXVlLCBob29rcyk7XG4gICAgICAgIHRoaXMucXVlcnlQaXBlbGluZS51cGRhdGUodGhpcy5jb2xsaWRlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY29sbGlkZXJzIHBvc2l0aW9ucyBhZnRlciByaWdpZC1ib2RpZXMgbW92ZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIGEgcmlnaWQtYm9keSBtb3ZlcywgdGhlIHBvc2l0aW9ucyBvZiB0aGUgY29sbGlkZXJzIGF0dGFjaGVkIHRvIGl0IG5lZWQgdG8gYmUgdXBkYXRlZC4gVGhpcyB1cGRhdGUgaXNcbiAgICAgKiBnZW5lcmFsbHkgYXV0b21hdGljYWxseSBkb25lIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHRoZSBlbmQgb2YgZWFjaCBzaW11bGF0aW9uIHN0ZXAgd2l0aCBXb3JsZC5zdGVwLlxuICAgICAqIElmIHRoZSBwb3NpdGlvbnMgbmVlZCB0byBiZSB1cGRhdGVkIHdpdGhvdXQgcnVubmluZyBhIHNpbXVsYXRpb24gc3RlcCB0aGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG1hbnVhbGx5LlxuICAgICAqL1xuICAgIHByb3BhZ2F0ZU1vZGlmaWVkQm9keVBvc2l0aW9uc1RvQ29sbGlkZXJzKCkge1xuICAgICAgICB0aGlzLmJvZGllcy5yYXcucHJvcGFnYXRlTW9kaWZpZWRCb2R5UG9zaXRpb25zVG9Db2xsaWRlcnModGhpcy5jb2xsaWRlcnMucmF3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHN1YnNlcXVlbnQgc2NlbmUgcXVlcmllcyB0YWtlIGludG8gYWNjb3VudCB0aGUgY29sbGlkZXIgcG9zaXRpb25zIHNldCBiZWZvcmUgdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogVGhpcyBkb2VzIG5vdCBzdGVwIHRoZSBwaHlzaWNzIHNpbXVsYXRpb24gZm9yd2FyZC5cbiAgICAgKi9cbiAgICB1cGRhdGVTY2VuZVF1ZXJpZXMoKSB7XG4gICAgICAgIHRoaXMucHJvcGFnYXRlTW9kaWZpZWRCb2R5UG9zaXRpb25zVG9Db2xsaWRlcnMoKTtcbiAgICAgICAgdGhpcy5xdWVyeVBpcGVsaW5lLnVwZGF0ZSh0aGlzLmNvbGxpZGVycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNpbXVsYXRpb24gdGltZXN0ZXAuXG4gICAgICovXG4gICAgZ2V0IHRpbWVzdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ3JhdGlvblBhcmFtZXRlcnMuZHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG5ldyBzaW11bGF0aW9uIHRpbWVzdGVwLlxuICAgICAqXG4gICAgICogVGhlIHNpbXVsYXRpb24gdGltZXN0ZXAgZ292ZXJucyBieSBob3cgbXVjaCB0aGUgcGh5c2ljcyBzdGF0ZSBvZiB0aGUgd29ybGQgd2lsbFxuICAgICAqIGJlIGludGVncmF0ZWQuIEEgc2ltdWxhdGlvbiB0aW1lc3RlcCBzaG91bGQ6XG4gICAgICogLSBiZSBhcyBzbWFsbCBhcyBwb3NzaWJsZS4gVHlwaWNhbCB2YWx1ZXMgZXZvbHZlIGFyb3VuZCAwLjAxNiAoYXNzdW1pbmcgdGhlIGNob3NlbiB1bml0IGlzIG1pbGxpc2Vjb25kcyxcbiAgICAgKiBjb3JyZXNwb25kcyB0byB0aGUgdGltZSBiZXR3ZWVuIHR3byBmcmFtZXMgb2YgYSBnYW1lIHJ1bm5pbmcgYXQgNjBGUFMpLlxuICAgICAqIC0gbm90IHZhcnkgdG9vIG11Y2ggZHVyaW5nIHRoZSBjb3Vyc2Ugb2YgdGhlIHNpbXVsYXRpb24uIEEgdGltZXN0ZXAgd2l0aCBsYXJnZSB2YXJpYXRpb25zIG1heVxuICAgICAqIGNhdXNlIGluc3RhYmlsaXRpZXMgaW4gdGhlIHNpbXVsYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZHQgLSBUaGUgdGltZXN0ZXAgbGVuZ3RoLCBpbiBzZWNvbmRzLlxuICAgICAqL1xuICAgIHNldCB0aW1lc3RlcChkdCkge1xuICAgICAgICB0aGlzLmludGVncmF0aW9uUGFyYW1ldGVycy5kdCA9IGR0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYXBwcm94aW1hdGUgc2l6ZSBvZiBtb3N0IGR5bmFtaWMgb2JqZWN0cyBpbiB0aGUgc2NlbmUuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhlIGBXb3JsZC5sZW5ndGhVbml0YCBzZXR0ZXIgZm9yIGZ1cnRoZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoVW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLmxlbmd0aFVuaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhcHByb3hpbWF0ZSBzaXplIG9mIG1vc3QgZHluYW1pYyBvYmplY3RzIGluIHRoZSBzY2VuZS5cbiAgICAgKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGVzdGltYXRlIHNvbWUgbGVuZ3RoLWJhc2VkIHRvbGVyYW5jZS4gSW4gcGFydGljdWxhciwgdGhlXG4gICAgICogdmFsdWVzIGBJbnRlZ3JhdGlvblBhcmFtZXRlcnMuYWxsb3dlZExpbmVhckVycm9yYCxcbiAgICAgKiBgSW50ZWdyYXRpb25QYXJhbWV0ZXJzLm1heFBlbmV0cmF0aW9uQ29ycmVjdGlvbmAsXG4gICAgICogYEludGVncmF0aW9uUGFyYW1ldGVycy5wcmVkaWN0aW9uRGlzdGFuY2VgLCBgUmlnaWRCb2R5QWN0aXZhdGlvbi5saW5lYXJUaHJlc2hvbGRgXG4gICAgICogYXJlIHNjYWxlZCBieSB0aGlzIHZhbHVlIGltcGxpY2l0bHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHZhbHVlIGNhbiBiZSB1bmRlcnN0b29kIGFzIHRoZSBudW1iZXIgb2YgdW5pdHMtcGVyLW1ldGVyIGluIHlvdXIgcGh5c2ljYWwgd29ybGQgY29tcGFyZWRcbiAgICAgKiB0byBhIGh1bWFuLXNpemVkIHdvcmxkIGluIG1ldGVyLiBGb3IgZXhhbXBsZSwgaW4gYSAyZCBnYW1lLCBpZiB5b3VyIHR5cGljYWwgb2JqZWN0IHNpemUgaXMgMTAwXG4gICAgICogcGl4ZWxzLCBzZXQgdGhlIGBbYFNlbGY6Omxlbmd0aF91bml0YF1gIHBhcmFtZXRlciB0byAxMDAuMC4gVGhlIHBoeXNpY3MgZW5naW5lIHdpbGwgaW50ZXJwcmV0XG4gICAgICogaXQgYXMgaWYgMTAwIHBpeGVscyBpcyBlcXVpdmFsZW50IHRvIDEgbWV0ZXIgaW4gaXRzIHZhcmlvdXMgaW50ZXJuYWwgdGhyZXNob2xkLlxuICAgICAqIChkZWZhdWx0IGAxLjBgKS5cbiAgICAgKi9cbiAgICBzZXQgbGVuZ3RoVW5pdCh1bml0c1Blck1ldGVyKSB7XG4gICAgICAgIHRoaXMuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLmxlbmd0aFVuaXQgPSB1bml0c1Blck1ldGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHNvbHZlciBpdGVyYXRpb25zIHJ1biBieSB0aGUgY29uc3RyYWludHMgc29sdmVyIGZvciBjYWxjdWxhdGluZyBmb3JjZXMgKGRlZmF1bHQ6IGA0YCkuXG4gICAgICovXG4gICAgZ2V0IG51bVNvbHZlckl0ZXJhdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVncmF0aW9uUGFyYW1ldGVycy5udW1Tb2x2ZXJJdGVyYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgcnVuIGJ5IHRoZSBjb25zdHJhaW50cyBzb2x2ZXIgZm9yIGNhbGN1bGF0aW5nIGZvcmNlcyAoZGVmYXVsdDogYDRgKS5cbiAgICAgKlxuICAgICAqIFRoZSBncmVhdGVyIHRoaXMgdmFsdWUgaXMsIHRoZSBtb3N0IHJpZ2lkIGFuZCByZWFsaXN0aWMgdGhlIHBoeXNpY3Mgc2ltdWxhdGlvbiB3aWxsIGJlLlxuICAgICAqIEhvd2V2ZXIgYSBncmVhdGVyIG51bWJlciBvZiBpdGVyYXRpb25zIGlzIG1vcmUgY29tcHV0YXRpb25hbGx5IGludGVuc2l2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuaXRlciAtIFRoZSBuZXcgbnVtYmVyIG9mIHNvbHZlciBpdGVyYXRpb25zLlxuICAgICAqL1xuICAgIHNldCBudW1Tb2x2ZXJJdGVyYXRpb25zKG5pdGVyKSB7XG4gICAgICAgIHRoaXMuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm51bVNvbHZlckl0ZXJhdGlvbnMgPSBuaXRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGFkZGl0aW9uIGZyaWN0aW9uIHJlc29sdXRpb24gaXRlcmF0aW9uIHJ1biBkdXJpbmcgdGhlIGxhc3Qgc29sdmVyIHN1Yi1zdGVwIChkZWZhdWx0OiBgNGApLlxuICAgICAqL1xuICAgIGdldCBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ3JhdGlvblBhcmFtZXRlcnMubnVtQWRkaXRpb25hbEZyaWN0aW9uSXRlcmF0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIGFkZGl0aW9uIGZyaWN0aW9uIHJlc29sdXRpb24gaXRlcmF0aW9uIHJ1biBkdXJpbmcgdGhlIGxhc3Qgc29sdmVyIHN1Yi1zdGVwIChkZWZhdWx0OiBgNGApLlxuICAgICAqXG4gICAgICogVGhlIGdyZWF0ZXIgdGhpcyB2YWx1ZSBpcywgdGhlIG1vc3QgcmVhbGlzdGljIGZyaWN0aW9uIHdpbGwgYmUuXG4gICAgICogSG93ZXZlciBhIGdyZWF0ZXIgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgaXMgbW9yZSBjb21wdXRhdGlvbmFsbHkgaW50ZW5zaXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5pdGVyIC0gVGhlIG5ldyBudW1iZXIgb2YgYWRkaXRpb25hbCBmcmljdGlvbiBpdGVyYXRpb25zLlxuICAgICAqL1xuICAgIHNldCBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zKG5pdGVyKSB7XG4gICAgICAgIHRoaXMuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm51bUFkZGl0aW9uYWxGcmljdGlvbkl0ZXJhdGlvbnMgPSBuaXRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGludGVybmFsIFByb2plY3QgR2F1c3MgU2VpZGVsIChQR1MpIGl0ZXJhdGlvbnMgcnVuIGF0IGVhY2ggc29sdmVyIGl0ZXJhdGlvbiAoZGVmYXVsdDogYDFgKS5cbiAgICAgKi9cbiAgICBnZXQgbnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ3JhdGlvblBhcmFtZXRlcnMubnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBOdW1iZXIgb2YgaW50ZXJuYWwgUHJvamVjdCBHYXVzcyBTZWlkZWwgKFBHUykgaXRlcmF0aW9ucyBydW4gYXQgZWFjaCBzb2x2ZXIgaXRlcmF0aW9uIChkZWZhdWx0OiBgMWApLlxuICAgICAqXG4gICAgICogSW5jcmVhc2luZyB0aGlzIHBhcmFtZXRlciB3aWxsIGltcHJvdmUgc3RhYmlsaXR5IG9mIHRoZSBzaW11bGF0aW9uLiBJdCB3aWxsIGhhdmUgYSBsZXNzZXIgZWZmZWN0IHRoYW5cbiAgICAgKiBpbmNyZWFzaW5nIGBudW1Tb2x2ZXJJdGVyYXRpb25zYCBidXQgaXMgYWxzbyBsZXNzIGNvbXB1dGF0aW9uYWxseSBleHBlbnNpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbml0ZXIgLSBUaGUgbmV3IG51bWJlciBvZiBpbnRlcm5hbCBQR1MgaXRlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBzZXQgbnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zKG5pdGVyKSB7XG4gICAgICAgIHRoaXMuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLm51bUludGVybmFsUGdzSXRlcmF0aW9ucyA9IG5pdGVyO1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlcyB0aGUgaW50ZWdyYXRpb24gcGFyYW1ldGVycyB0byBtYXRjaCB0aGUgb2xkIFBHUyBzb2x2ZXJcbiAgICAvLy8gZnJvbSBSYXBpZXIgSlMgdmVyc2lvbiA8PSAwLjExLlxuICAgIC8vL1xuICAgIC8vLyBUaGlzIHNvbHZlciB3YXMgc2xpZ2h0bHkgZmFzdGVyIHRoYW4gdGhlIG5ldyBvbmUgYnV0IHJlc3VsdGVkXG4gICAgLy8vIGluIGxlc3Mgc3RhYmxlIGpvaW50cyBhbmQgd29yc2UgY29udmVyZ2VuY2UgcmF0ZXMuXG4gICAgLy8vXG4gICAgLy8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY29tcGFyaXNvbiBwdXJwb3NlIG9yIGlmIHlvdSBhcmVcbiAgICAvLy8gZXhwZXJpZW5jaW5nIHByb2JsZW1zIHdpdGggdGhlIG5ldyBzb2x2ZXIuXG4gICAgLy8vXG4gICAgLy8vIE5PVEU6IHRoaXMgZG9lcyBub3QgYWZmZWN0IGFueSBgUmlnaWRCb2R5LmFkZGl0aW9uYWxfc29sdmVyX2l0ZXJhdGlvbnNgIHRoYXQgd2lsbFxuICAgIC8vLyAgICAgICBzdGlsbCBjcmVhdGUgc29sdmVyIGl0ZXJhdGlvbnMgYmFzZWQgb24gdGhlIG5ldyBcInNtYWxsLXN0ZXBzXCIgUEdTIHNvbHZlci5cbiAgICBzd2l0Y2hUb1N0YW5kYXJkUGdzU29sdmVyKCkge1xuICAgICAgICB0aGlzLmludGVncmF0aW9uUGFyYW1ldGVycy5zd2l0Y2hUb1N0YW5kYXJkUGdzU29sdmVyKCk7XG4gICAgfVxuICAgIC8vLyBDb25maWd1cmVzIHRoZSBpbnRlZ3JhdGlvbiBwYXJhbWV0ZXJzIHRvIG1hdGNoIHRoZSBuZXcgXCJzbWFsbC1zdGVwc1wiIFBHUyBzb2x2ZXJcbiAgICAvLy8gZnJvbSBSYXBpZXIgdmVyc2lvbiA+PSAwLjEyLlxuICAgIC8vL1xuICAgIC8vLyBUaGUgXCJzbWFsbC1zdGVwc1wiIFBHUyBzb2x2ZXIgaXMgdGhlIGRlZmF1bHQgb25lIHdoZW4gY3JlYXRpbmcgdGhlIHBoeXNpY3Mgd29ybGQuIFNvXG4gICAgLy8vIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBpcyBnZW5lcmFsbHkgbm90IG5lZWRlZCB1bmxlc3MgYFdvcmxkLnN3aXRjaF90b19zdGFuZGFyZF9wZ3Nfc29sdmVyYFxuICAgIC8vLyB3YXMgY2FsbGVkLlxuICAgIC8vL1xuICAgIC8vLyBUaGlzIHNvbHZlciByZXN1bHRzIGluIG1vcmUgc3RhYmxlIGpvaW50cyBhbmQgc2lnbmlmaWNhbnRseSBiZXR0ZXIgY29udmVyZ2VuY2VcbiAgICAvLy8gcmF0ZXMgYnV0IGlzIHNsaWdodGx5IHNsb3dlciBpbiBpdHMgZGVmYXVsdCBzZXR0aW5ncy5cbiAgICBzd2l0Y2hUb1NtYWxsU3RlcHNQZ3NTb2x2ZXIoKSB7XG4gICAgICAgIHRoaXMuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLnN3aXRjaFRvU21hbGxTdGVwc1Bnc1NvbHZlcigpO1xuICAgIH1cbiAgICAvLy8gQ29uZmlndXJlcyB0aGUgaW50ZWdyYXRpb24gcGFyYW1ldGVycyB0byBtYXRjaCB0aGUgbmV3IFwic21hbGwtc3RlcHNcIiBQR1Mgc29sdmVyXG4gICAgLy8vIGZyb20gUmFwaWVyIHZlcnNpb24gPj0gMC4xMi4gV2FybXN0YXJ0aW5nIGlzIGRpc2FibGVkLlxuICAgIC8vL1xuICAgIC8vLyBUaGUgXCJzbWFsbC1zdGVwc1wiIFBHUyBzb2x2ZXIgaXMgdGhlIGRlZmF1bHQgb25lIHdoZW4gY3JlYXRpbmcgdGhlIHBoeXNpY3Mgd29ybGQuIFNvXG4gICAgLy8vIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBpcyBnZW5lcmFsbHkgbm90IG5lZWRlZCB1bmxlc3MgYFdvcmxkLnN3aXRjaF90b19zdGFuZGFyZF9wZ3Nfc29sdmVyYFxuICAgIC8vLyB3YXMgY2FsbGVkLlxuICAgIC8vL1xuICAgIC8vLyBUaGlzIHNvbHZlciByZXN1bHRzIGluIG1vcmUgc3RhYmxlIGpvaW50cyBhbmQgc2lnbmlmaWNhbnRseSBiZXR0ZXIgY29udmVyZ2VuY2VcbiAgICAvLy8gcmF0ZXMgYnV0IGlzIHNsaWdodGx5IHNsb3dlciBpbiBpdHMgZGVmYXVsdCBzZXR0aW5ncy5cbiAgICBzd2l0Y2hUb1NtYWxsU3RlcHNQZ3NTb2x2ZXJXaXRob3V0V2FybXN0YXJ0KCkge1xuICAgICAgICB0aGlzLmludGVncmF0aW9uUGFyYW1ldGVycy5zd2l0Y2hUb1NtYWxsU3RlcHNQZ3NTb2x2ZXJXaXRob3V0V2FybXN0YXJ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmlnaWQtYm9keSBmcm9tIHRoZSBnaXZlbiByaWdpZC1ib2R5IGRlc2NyaXB0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYm9keSAtIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcmlnaWQtYm9keSB0byBjcmVhdGUuXG4gICAgICovXG4gICAgY3JlYXRlUmlnaWRCb2R5KGJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9kaWVzLmNyZWF0ZVJpZ2lkQm9keSh0aGlzLmNvbGxpZGVycywgYm9keSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhcmFjdGVyIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIGFydGlmaWNpYWwgZ2FwIGFkZGVkIGJldHdlZW4gdGhlIGNoYXJhY3RlcuKAmXMgY2hhcGUgYW5kIGl0cyBlbnZpcm9ubWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVDaGFyYWN0ZXJDb250cm9sbGVyKG9mZnNldCkge1xuICAgICAgICBsZXQgY29udHJvbGxlciA9IG5ldyBLaW5lbWF0aWNDaGFyYWN0ZXJDb250cm9sbGVyKG9mZnNldCwgdGhpcy5pbnRlZ3JhdGlvblBhcmFtZXRlcnMsIHRoaXMuYm9kaWVzLCB0aGlzLmNvbGxpZGVycywgdGhpcy5xdWVyeVBpcGVsaW5lKTtcbiAgICAgICAgdGhpcy5jaGFyYWN0ZXJDb250cm9sbGVycy5hZGQoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hhcmFjdGVyIGNvbnRyb2xsZXIgZnJvbSB0aGlzIHdvcmxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyb2xsZXIgLSBUaGUgY2hhcmFjdGVyIGNvbnRyb2xsZXIgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHJlbW92ZUNoYXJhY3RlckNvbnRyb2xsZXIoY29udHJvbGxlcikge1xuICAgICAgICB0aGlzLmNoYXJhY3RlckNvbnRyb2xsZXJzLmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5mcmVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzYyAtIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY29sbGlkZXIuXG4gICAgICogQHBhcmFtIHBhcmVudCAtIFRoZSByaWdpZC1ib2R5IHRoaXMgY29sbGlkZXIgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgY3JlYXRlQ29sbGlkZXIoZGVzYywgcGFyZW50KSB7XG4gICAgICAgIGxldCBwYXJlbnRIYW5kbGUgPSBwYXJlbnQgPyBwYXJlbnQuaGFuZGxlIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlcnMuY3JlYXRlQ29sbGlkZXIodGhpcy5ib2RpZXMsIGRlc2MsIHBhcmVudEhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW1wdWxzZSBqb2ludCBmcm9tIHRoZSBnaXZlbiBqb2ludCBkZXNjcmlwdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgam9pbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSBwYXJlbnQxIC0gVGhlIGZpcnN0IHJpZ2lkLWJvZHkgYXR0YWNoZWQgdG8gdGhpcyBqb2ludC5cbiAgICAgKiBAcGFyYW0gcGFyZW50MiAtIFRoZSBzZWNvbmQgcmlnaWQtYm9keSBhdHRhY2hlZCB0byB0aGlzIGpvaW50LlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBTaG91bGQgdGhlIGF0dGFjaGVkIHJpZ2lkLWJvZGllcyBiZSBhd2FrZW5lZD9cbiAgICAgKi9cbiAgICBjcmVhdGVJbXB1bHNlSm9pbnQocGFyYW1zLCBwYXJlbnQxLCBwYXJlbnQyLCB3YWtlVXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1wdWxzZUpvaW50cy5jcmVhdGVKb2ludCh0aGlzLmJvZGllcywgcGFyYW1zLCBwYXJlbnQxLmhhbmRsZSwgcGFyZW50Mi5oYW5kbGUsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbXVsdGlib2R5IGpvaW50IGZyb20gdGhlIGdpdmVuIGpvaW50IGRlc2NyaXB0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBqb2ludCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHBhcmVudDEgLSBUaGUgZmlyc3QgcmlnaWQtYm9keSBhdHRhY2hlZCB0byB0aGlzIGpvaW50LlxuICAgICAqIEBwYXJhbSBwYXJlbnQyIC0gVGhlIHNlY29uZCByaWdpZC1ib2R5IGF0dGFjaGVkIHRvIHRoaXMgam9pbnQuXG4gICAgICogQHBhcmFtIHdha2VVcCAtIFNob3VsZCB0aGUgYXR0YWNoZWQgcmlnaWQtYm9kaWVzIGJlIGF3YWtlbmVkP1xuICAgICAqL1xuICAgIGNyZWF0ZU11bHRpYm9keUpvaW50KHBhcmFtcywgcGFyZW50MSwgcGFyZW50Miwgd2FrZVVwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpYm9keUpvaW50cy5jcmVhdGVKb2ludChwYXJhbXMsIHBhcmVudDEuaGFuZGxlLCBwYXJlbnQyLmhhbmRsZSwgd2FrZVVwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcmlnaWQtYm9keSBmcm9tIGl0cyBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlIC0gVGhlIGludGVnZXIgaGFuZGxlIG9mIHRoZSByaWdpZC1ib2R5IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIGdldFJpZ2lkQm9keShoYW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9kaWVzLmdldChoYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBjb2xsaWRlciBmcm9tIGl0cyBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlIC0gVGhlIGludGVnZXIgaGFuZGxlIG9mIHRoZSBjb2xsaWRlciB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBnZXRDb2xsaWRlcihoYW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJzLmdldChoYW5kbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYW4gaW1wdWxzZSBqb2ludCBmcm9tIGl0cyBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlIC0gVGhlIGludGVnZXIgaGFuZGxlIG9mIHRoZSBpbXB1bHNlIGpvaW50IHRvIHJldHJpZXZlLlxuICAgICAqL1xuICAgIGdldEltcHVsc2VKb2ludChoYW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1wdWxzZUpvaW50cy5nZXQoaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIG11bHRpYm9keSBqb2ludCBmcm9tIGl0cyBoYW5kbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFuZGxlIC0gVGhlIGludGVnZXIgaGFuZGxlIG9mIHRoZSBtdWx0aWJvZHkgam9pbnQgdG8gcmV0cmlldmUuXG4gICAgICovXG4gICAgZ2V0TXVsdGlib2R5Sm9pbnQoaGFuZGxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpYm9keUpvaW50cy5nZXQoaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcmlnaWQtYm9keSBmcm9tIHRoaXMgcGh5c2ljcyB3b3JsZC5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCByZW1vdmUgdGhpcyByaWdpZC1ib2R5IGFzIHdlbGwgYXMgYWxsIGl0cyBhdHRhY2hlZCBjb2xsaWRlcnMgYW5kIGpvaW50cy5cbiAgICAgKiBFdmVyeSBvdGhlciBib2RpZXMgdG91Y2hpbmcgb3IgYXR0YWNoZWQgYnkgam9pbnRzIHRvIHRoaXMgcmlnaWQtYm9keSB3aWxsIGJlIHdva2VuLXVwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJvZHkgLSBUaGUgcmlnaWQtYm9keSB0byByZW1vdmUuXG4gICAgICovXG4gICAgcmVtb3ZlUmlnaWRCb2R5KGJvZHkpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9kaWVzKSB7XG4gICAgICAgICAgICB0aGlzLmJvZGllcy5yZW1vdmUoYm9keS5oYW5kbGUsIHRoaXMuaXNsYW5kcywgdGhpcy5jb2xsaWRlcnMsIHRoaXMuaW1wdWxzZUpvaW50cywgdGhpcy5tdWx0aWJvZHlKb2ludHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNvbGxpZGVyIGZyb20gdGhpcyBwaHlzaWNzIHdvcmxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxpZGVyIC0gVGhlIGNvbGxpZGVyIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gd2FrZVVwIC0gSWYgc2V0IHRvIGB0cnVlYCwgdGhlIHJpZ2lkLWJvZHkgdGhpcyBjb2xsaWRlciBpcyBhdHRhY2hlZCB0byB3aWxsIGJlIGF3YWtlbi5cbiAgICAgKi9cbiAgICByZW1vdmVDb2xsaWRlcihjb2xsaWRlciwgd2FrZVVwKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxpZGVycykge1xuICAgICAgICAgICAgdGhpcy5jb2xsaWRlcnMucmVtb3ZlKGNvbGxpZGVyLmhhbmRsZSwgdGhpcy5pc2xhbmRzLCB0aGlzLmJvZGllcywgd2FrZVVwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBpbXB1bHNlIGpvaW50IGZyb20gdGhpcyBwaHlzaWNzIHdvcmxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpvaW50IC0gVGhlIGltcHVsc2Ugam9pbnQgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB3YWtlVXAgLSBJZiBzZXQgdG8gYHRydWVgLCB0aGUgcmlnaWQtYm9kaWVzIGF0dGFjaGVkIGJ5IHRoaXMgam9pbnQgd2lsbCBiZSBhd2FrZW4uXG4gICAgICovXG4gICAgcmVtb3ZlSW1wdWxzZUpvaW50KGpvaW50LCB3YWtlVXApIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wdWxzZUpvaW50cykge1xuICAgICAgICAgICAgdGhpcy5pbXB1bHNlSm9pbnRzLnJlbW92ZShqb2ludC5oYW5kbGUsIHdha2VVcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbXVsdGlib2R5IGpvaW50IGZyb20gdGhpcyBwaHlzaWNzIHdvcmxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpvaW50IC0gVGhlIG11bHRpYm9keSBqb2ludCB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHdha2VVcCAtIElmIHNldCB0byBgdHJ1ZWAsIHRoZSByaWdpZC1ib2RpZXMgYXR0YWNoZWQgYnkgdGhpcyBqb2ludCB3aWxsIGJlIGF3YWtlbi5cbiAgICAgKi9cbiAgICByZW1vdmVNdWx0aWJvZHlKb2ludChqb2ludCwgd2FrZVVwKSB7XG4gICAgICAgIGlmICh0aGlzLmltcHVsc2VKb2ludHMpIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlib2R5Sm9pbnRzLnJlbW92ZShqb2ludC5oYW5kbGUsIHdha2VVcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gY2xvc3VyZSB0byBlYWNoIGNvbGxpZGVyIG1hbmFnZWQgYnkgdGhpcyBwaHlzaWNzIHdvcmxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGYoY29sbGlkZXIpIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggY29sbGlkZXIgbWFuYWdlZCBieSB0aGlzIHBoeXNpY3Mgd29ybGQuIENhbGxlZCBhcyBgZihjb2xsaWRlcilgLlxuICAgICAqL1xuICAgIGZvckVhY2hDb2xsaWRlcihmKSB7XG4gICAgICAgIHRoaXMuY29sbGlkZXJzLmZvckVhY2goZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIGNsb3N1cmUgdG8gZWFjaCByaWdpZC1ib2R5IG1hbmFnZWQgYnkgdGhpcyBwaHlzaWNzIHdvcmxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGYoYm9keSkgLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCByaWdpZC1ib2R5IG1hbmFnZWQgYnkgdGhpcyBwaHlzaWNzIHdvcmxkLiBDYWxsZWQgYXMgYGYoY29sbGlkZXIpYC5cbiAgICAgKi9cbiAgICBmb3JFYWNoUmlnaWRCb2R5KGYpIHtcbiAgICAgICAgdGhpcy5ib2RpZXMuZm9yRWFjaChmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gY2xvc3VyZSB0byBlYWNoIGFjdGl2ZSByaWdpZC1ib2R5IG1hbmFnZWQgYnkgdGhpcyBwaHlzaWNzIHdvcmxkLlxuICAgICAqXG4gICAgICogQWZ0ZXIgYSBzaG9ydCB0aW1lIG9mIGluYWN0aXZpdHksIGEgcmlnaWQtYm9keSBpcyBhdXRvbWF0aWNhbGx5IGRlYWN0aXZhdGVkIChcImFzbGVlcFwiKSBieVxuICAgICAqIHRoZSBwaHlzaWNzIGVuZ2luZSBpbiBvcmRlciB0byBzYXZlIGNvbXB1dGF0aW9uYWwgcG93ZXIuIEEgc2xlZXBpbmcgcmlnaWQtYm9keSBuZXZlciBtb3Zlc1xuICAgICAqIHVubGVzcyBpdCBpcyBtb3ZlZCBtYW51YWxseSBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggYWN0aXZlIHJpZ2lkLWJvZHkgbWFuYWdlZCBieSB0aGlzIHBoeXNpY3Mgd29ybGQuIENhbGxlZCBhcyBgZihjb2xsaWRlcilgLlxuICAgICAqL1xuICAgIGZvckVhY2hBY3RpdmVSaWdpZEJvZHkoZikge1xuICAgICAgICB0aGlzLmJvZGllcy5mb3JFYWNoQWN0aXZlUmlnaWRCb2R5KHRoaXMuaXNsYW5kcywgZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uIGJldHdlZW4gYSByYXkgYW5kIHRoZSBwaHlzaWNzIHdvcmxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJheSAtIFRoZSByYXkgdG8gY2FzdC5cbiAgICAgKiBAcGFyYW0gbWF4VG9pIC0gVGhlIG1heGltdW0gdGltZS1vZi1pbXBhY3QgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgdGhpcyBjYXN0LiBUaGlzIGVmZmVjdGl2ZWx5XG4gICAgICogICBsaW1pdHMgdGhlIGxlbmd0aCBvZiB0aGUgcmF5IHRvIGByYXkuZGlyLm5vcm0oKSAqIG1heFRvaWAuXG4gICAgICogQHBhcmFtIHNvbGlkIC0gSWYgYGZhbHNlYCB0aGVuIHRoZSByYXkgd2lsbCBhdHRlbXB0IHRvIGhpdCB0aGUgYm91bmRhcnkgb2YgYSBzaGFwZSwgZXZlbiBpZiBpdHNcbiAgICAgKiAgIG9yaWdpbiBhbHJlYWR5IGxpZXMgaW5zaWRlIG9mIGEgc2hhcGUuIEluIG90aGVyIHRlcm1zLCBgdHJ1ZWAgaW1wbGllcyB0aGF0IGFsbCBzaGFwZXMgYXJlIHBsYWluLFxuICAgICAqICAgd2hlcmVhcyBgZmFsc2VgIGltcGxpZXMgdGhhdCBhbGwgc2hhcGVzIGFyZSBob2xsb3cgZm9yIHRoaXMgcmF5LWNhc3QuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFVzZWQgdG8gZmlsdGVyIHRoZSBjb2xsaWRlcnMgdGhhdCBjYW4gb3IgY2Fubm90IGJlIGhpdCBieSB0aGUgcmF5LlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBUaGUgY2FsbGJhY2sgdG8gZmlsdGVyIG91dCB3aGljaCBjb2xsaWRlciB3aWxsIGJlIGhpdC5cbiAgICAgKi9cbiAgICBjYXN0UmF5KHJheSwgbWF4VG9pLCBzb2xpZCwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlQaXBlbGluZS5jYXN0UmF5KHRoaXMuYm9kaWVzLCB0aGlzLmNvbGxpZGVycywgcmF5LCBtYXhUb2ksIHNvbGlkLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIgPyBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIuaGFuZGxlIDogbnVsbCwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSA/IGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHkuaGFuZGxlIDogbnVsbCwgdGhpcy5jb2xsaWRlcnMuY2FzdENsb3N1cmUoZmlsdGVyUHJlZGljYXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uIGJldHdlZW4gYSByYXkgYW5kIHRoZSBwaHlzaWNzIHdvcmxkLlxuICAgICAqXG4gICAgICogVGhpcyBhbHNvIGNvbXB1dGVzIHRoZSBub3JtYWwgYXQgdGhlIGhpdCBwb2ludC5cbiAgICAgKiBAcGFyYW0gcmF5IC0gVGhlIHJheSB0byBjYXN0LlxuICAgICAqIEBwYXJhbSBtYXhUb2kgLSBUaGUgbWF4aW11bSB0aW1lLW9mLWltcGFjdCB0aGF0IGNhbiBiZSByZXBvcnRlZCBieSB0aGlzIGNhc3QuIFRoaXMgZWZmZWN0aXZlbHlcbiAgICAgKiAgIGxpbWl0cyB0aGUgbGVuZ3RoIG9mIHRoZSByYXkgdG8gYHJheS5kaXIubm9ybSgpICogbWF4VG9pYC5cbiAgICAgKiBAcGFyYW0gc29saWQgLSBJZiBgZmFsc2VgIHRoZW4gdGhlIHJheSB3aWxsIGF0dGVtcHQgdG8gaGl0IHRoZSBib3VuZGFyeSBvZiBhIHNoYXBlLCBldmVuIGlmIGl0c1xuICAgICAqICAgb3JpZ2luIGFscmVhZHkgbGllcyBpbnNpZGUgb2YgYSBzaGFwZS4gSW4gb3RoZXIgdGVybXMsIGB0cnVlYCBpbXBsaWVzIHRoYXQgYWxsIHNoYXBlcyBhcmUgcGxhaW4sXG4gICAgICogICB3aGVyZWFzIGBmYWxzZWAgaW1wbGllcyB0aGF0IGFsbCBzaGFwZXMgYXJlIGhvbGxvdyBmb3IgdGhpcyByYXktY2FzdC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBzIC0gVXNlZCB0byBmaWx0ZXIgdGhlIGNvbGxpZGVycyB0aGF0IGNhbiBvciBjYW5ub3QgYmUgaGl0IGJ5IHRoZSByYXkuXG4gICAgICovXG4gICAgY2FzdFJheUFuZEdldE5vcm1hbChyYXksIG1heFRvaSwgc29saWQsIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSwgZmlsdGVyUHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5UGlwZWxpbmUuY2FzdFJheUFuZEdldE5vcm1hbCh0aGlzLmJvZGllcywgdGhpcy5jb2xsaWRlcnMsIHJheSwgbWF4VG9pLCBzb2xpZCwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyID8gZmlsdGVyRXhjbHVkZUNvbGxpZGVyLmhhbmRsZSA6IG51bGwsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHkgPyBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LmhhbmRsZSA6IG51bGwsIHRoaXMuY29sbGlkZXJzLmNhc3RDbG9zdXJlKGZpbHRlclByZWRpY2F0ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXN0IGEgcmF5IGFuZCBjb2xsZWN0cyBhbGwgdGhlIGludGVyc2VjdGlvbnMgYmV0d2VlbiBhIHJheSBhbmQgdGhlIHNjZW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJheSAtIFRoZSByYXkgdG8gY2FzdC5cbiAgICAgKiBAcGFyYW0gbWF4VG9pIC0gVGhlIG1heGltdW0gdGltZS1vZi1pbXBhY3QgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgdGhpcyBjYXN0LiBUaGlzIGVmZmVjdGl2ZWx5XG4gICAgICogICBsaW1pdHMgdGhlIGxlbmd0aCBvZiB0aGUgcmF5IHRvIGByYXkuZGlyLm5vcm0oKSAqIG1heFRvaWAuXG4gICAgICogQHBhcmFtIHNvbGlkIC0gSWYgYGZhbHNlYCB0aGVuIHRoZSByYXkgd2lsbCBhdHRlbXB0IHRvIGhpdCB0aGUgYm91bmRhcnkgb2YgYSBzaGFwZSwgZXZlbiBpZiBpdHNcbiAgICAgKiAgIG9yaWdpbiBhbHJlYWR5IGxpZXMgaW5zaWRlIG9mIGEgc2hhcGUuIEluIG90aGVyIHRlcm1zLCBgdHJ1ZWAgaW1wbGllcyB0aGF0IGFsbCBzaGFwZXMgYXJlIHBsYWluLFxuICAgICAqICAgd2hlcmVhcyBgZmFsc2VgIGltcGxpZXMgdGhhdCBhbGwgc2hhcGVzIGFyZSBob2xsb3cgZm9yIHRoaXMgcmF5LWNhc3QuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFVzZWQgdG8gZmlsdGVyIHRoZSBjb2xsaWRlcnMgdGhhdCBjYW4gb3IgY2Fubm90IGJlIGhpdCBieSB0aGUgcmF5LlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBjYWxsZWQgb25jZSBwZXIgaGl0IChpbiBubyBwYXJ0aWN1bGFyIG9yZGVyKSBiZXR3ZWVuIGEgcmF5IGFuZCBhIGNvbGxpZGVyLlxuICAgICAqICAgSWYgdGhpcyBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRoZW4gdGhlIGNhc3Qgd2lsbCBzdG9wIGFuZCBubyBmdXJ0aGVyIGhpdHMgd2lsbCBiZSBkZXRlY3RlZC9yZXBvcnRlZC5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3Rpb25zV2l0aFJheShyYXksIG1heFRvaSwgc29saWQsIGNhbGxiYWNrLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHksIGZpbHRlclByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLnF1ZXJ5UGlwZWxpbmUuaW50ZXJzZWN0aW9uc1dpdGhSYXkodGhpcy5ib2RpZXMsIHRoaXMuY29sbGlkZXJzLCByYXksIG1heFRvaSwgc29saWQsIGNhbGxiYWNrLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIgPyBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIuaGFuZGxlIDogbnVsbCwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSA/IGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHkuaGFuZGxlIDogbnVsbCwgdGhpcy5jb2xsaWRlcnMuY2FzdENsb3N1cmUoZmlsdGVyUHJlZGljYXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhhbmRsZSBvZiB1cCB0byBvbmUgY29sbGlkZXIgaW50ZXJzZWN0aW5nIHRoZSBnaXZlbiBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaGFwZVBvcyAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2hhcGUgdXNlZCBmb3IgdGhlIGludGVyc2VjdGlvbiB0ZXN0LlxuICAgICAqIEBwYXJhbSBzaGFwZVJvdCAtIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc2hhcGUgdXNlZCBmb3IgdGhlIGludGVyc2VjdGlvbiB0ZXN0LlxuICAgICAqIEBwYXJhbSBzaGFwZSAtIFRoZSBzaGFwZSB1c2VkIGZvciB0aGUgaW50ZXJzZWN0aW9uIHRlc3QuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFRoZSBiaXQgZ3JvdXBzIGFuZCBmaWx0ZXIgYXNzb2NpYXRlZCB0byB0aGUgcmF5LCBpbiBvcmRlciB0byBvbmx5XG4gICAgICogICBoaXQgdGhlIGNvbGxpZGVycyB3aXRoIGNvbGxpc2lvbiBncm91cHMgY29tcGF0aWJsZSB3aXRoIHRoZSByYXkncyBncm91cC5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3Rpb25XaXRoU2hhcGUoc2hhcGVQb3MsIHNoYXBlUm90LCBzaGFwZSwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IGhhbmRsZSA9IHRoaXMucXVlcnlQaXBlbGluZS5pbnRlcnNlY3Rpb25XaXRoU2hhcGUodGhpcy5ib2RpZXMsIHRoaXMuY29sbGlkZXJzLCBzaGFwZVBvcywgc2hhcGVSb3QsIHNoYXBlLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIgPyBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIuaGFuZGxlIDogbnVsbCwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSA/IGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHkuaGFuZGxlIDogbnVsbCwgdGhpcy5jb2xsaWRlcnMuY2FzdENsb3N1cmUoZmlsdGVyUHJlZGljYXRlKSk7XG4gICAgICAgIHJldHVybiBoYW5kbGUgIT0gbnVsbCA/IHRoaXMuY29sbGlkZXJzLmdldChoYW5kbGUpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgcHJvamVjdGlvbiBvZiBhIHBvaW50IG9uIHRoZSBjbG9zZXN0IGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHByb2plY3QuXG4gICAgICogQHBhcmFtIHNvbGlkIC0gSWYgdGhpcyBpcyBzZXQgdG8gYHRydWVgIHRoZW4gdGhlIGNvbGxpZGVyIHNoYXBlcyBhcmUgY29uc2lkZXJlZCB0b1xuICAgICAqICAgYmUgcGxhaW4gKGlmIHRoZSBwb2ludCBpcyBsb2NhdGVkIGluc2lkZSBvZiBhIHBsYWluIHNoYXBlLCBpdHMgcHJvamVjdGlvbiBpcyB0aGUgcG9pbnRcbiAgICAgKiAgIGl0c2VsZikuIElmIGl0IGlzIHNldCB0byBgZmFsc2VgIHRoZSBjb2xsaWRlciBzaGFwZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgaG9sbG93XG4gICAgICogICAoaWYgdGhlIHBvaW50IGlzIGxvY2F0ZWQgaW5zaWRlIG9mIGFuIGhvbGxvdyBzaGFwZSwgaXQgaXMgcHJvamVjdGVkIG9uIHRoZSBzaGFwZSdzXG4gICAgICogICBib3VuZGFyeSkuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFRoZSBiaXQgZ3JvdXBzIGFuZCBmaWx0ZXIgYXNzb2NpYXRlZCB0byB0aGUgcG9pbnQgdG8gcHJvamVjdCwgaW4gb3JkZXIgdG8gb25seVxuICAgICAqICAgcHJvamVjdCBvbiBjb2xsaWRlcnMgd2l0aCBjb2xsaXNpb24gZ3JvdXBzIGNvbXBhdGlibGUgd2l0aCB0aGUgcmF5J3MgZ3JvdXAuXG4gICAgICovXG4gICAgcHJvamVjdFBvaW50KHBvaW50LCBzb2xpZCwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlQaXBlbGluZS5wcm9qZWN0UG9pbnQodGhpcy5ib2RpZXMsIHRoaXMuY29sbGlkZXJzLCBwb2ludCwgc29saWQsIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciA/IGZpbHRlckV4Y2x1ZGVDb2xsaWRlci5oYW5kbGUgOiBudWxsLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5ID8gZmlsdGVyRXhjbHVkZVJpZ2lkQm9keS5oYW5kbGUgOiBudWxsLCB0aGlzLmNvbGxpZGVycy5jYXN0Q2xvc3VyZShmaWx0ZXJQcmVkaWNhdGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgcHJvamVjdGlvbiBvZiBhIHBvaW50IG9uIHRoZSBjbG9zZXN0IGNvbGxpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHByb2plY3QuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFRoZSBiaXQgZ3JvdXBzIGFuZCBmaWx0ZXIgYXNzb2NpYXRlZCB0byB0aGUgcG9pbnQgdG8gcHJvamVjdCwgaW4gb3JkZXIgdG8gb25seVxuICAgICAqICAgcHJvamVjdCBvbiBjb2xsaWRlcnMgd2l0aCBjb2xsaXNpb24gZ3JvdXBzIGNvbXBhdGlibGUgd2l0aCB0aGUgcmF5J3MgZ3JvdXAuXG4gICAgICovXG4gICAgcHJvamVjdFBvaW50QW5kR2V0RmVhdHVyZShwb2ludCwgZmlsdGVyRmxhZ3MsIGZpbHRlckdyb3VwcywgZmlsdGVyRXhjbHVkZUNvbGxpZGVyLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5LCBmaWx0ZXJQcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlQaXBlbGluZS5wcm9qZWN0UG9pbnRBbmRHZXRGZWF0dXJlKHRoaXMuYm9kaWVzLCB0aGlzLmNvbGxpZGVycywgcG9pbnQsIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciA/IGZpbHRlckV4Y2x1ZGVDb2xsaWRlci5oYW5kbGUgOiBudWxsLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5ID8gZmlsdGVyRXhjbHVkZVJpZ2lkQm9keS5oYW5kbGUgOiBudWxsLCB0aGlzLmNvbGxpZGVycy5jYXN0Q2xvc3VyZShmaWx0ZXJQcmVkaWNhdGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhbGwgdGhlIGNvbGxpZGVycyBjb250YWluaW5nIHRoZSBnaXZlbiBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB1c2VkIGZvciB0aGUgY29udGFpbm1lbnQgdGVzdC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBzIC0gVGhlIGJpdCBncm91cHMgYW5kIGZpbHRlciBhc3NvY2lhdGVkIHRvIHRoZSBwb2ludCB0byB0ZXN0LCBpbiBvcmRlciB0byBvbmx5XG4gICAgICogICB0ZXN0IG9uIGNvbGxpZGVycyB3aXRoIGNvbGxpc2lvbiBncm91cHMgY29tcGF0aWJsZSB3aXRoIHRoZSByYXkncyBncm91cC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBoYW5kbGVzIG9mIGVhY2ggY29sbGlkZXIgd2l0aCBhIHNoYXBlXG4gICAgICogICBjb250YWluaW5nIHRoZSBgcG9pbnRgLlxuICAgICAqL1xuICAgIGludGVyc2VjdGlvbnNXaXRoUG9pbnQocG9pbnQsIGNhbGxiYWNrLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIsIGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHksIGZpbHRlclByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLnF1ZXJ5UGlwZWxpbmUuaW50ZXJzZWN0aW9uc1dpdGhQb2ludCh0aGlzLmJvZGllcywgdGhpcy5jb2xsaWRlcnMsIHBvaW50LCB0aGlzLmNvbGxpZGVycy5jYXN0Q2xvc3VyZShjYWxsYmFjayksIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciA/IGZpbHRlckV4Y2x1ZGVDb2xsaWRlci5oYW5kbGUgOiBudWxsLCBmaWx0ZXJFeGNsdWRlUmlnaWRCb2R5ID8gZmlsdGVyRXhjbHVkZVJpZ2lkQm9keS5oYW5kbGUgOiBudWxsLCB0aGlzLmNvbGxpZGVycy5jYXN0Q2xvc3VyZShmaWx0ZXJQcmVkaWNhdGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FzdHMgYSBzaGFwZSBhdCBhIGNvbnN0YW50IGxpbmVhciB2ZWxvY2l0eSBhbmQgcmV0cmlldmUgdGhlIGZpcnN0IGNvbGxpZGVyIGl0IGhpdHMuXG4gICAgICogVGhpcyBpcyBzaW1pbGFyIHRvIHJheS1jYXN0aW5nIGV4Y2VwdCB0aGF0IHdlIGFyZSBjYXN0aW5nIGEgd2hvbGUgc2hhcGUgaW5zdGVhZCBvZlxuICAgICAqIGp1c3QgYSBwb2ludCAodGhlIHJheSBvcmlnaW4pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNoYXBlUG9zIC0gVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHNoYXBlIHRvIGNhc3QuXG4gICAgICogQHBhcmFtIHNoYXBlUm90IC0gVGhlIGluaXRpYWwgcm90YXRpb24gb2YgdGhlIHNoYXBlIHRvIGNhc3QuXG4gICAgICogQHBhcmFtIHNoYXBlVmVsIC0gVGhlIGNvbnN0YW50IHZlbG9jaXR5IG9mIHRoZSBzaGFwZSB0byBjYXN0IChpLmUuIHRoZSBjYXN0IGRpcmVjdGlvbikuXG4gICAgICogQHBhcmFtIHNoYXBlIC0gVGhlIHNoYXBlIHRvIGNhc3QuXG4gICAgICogQHBhcmFtIHRhcmdldERpc3RhbmNlIOKIkiBJZiB0aGUgc2hhcGUgbW92ZXMgY2xvc2VyIHRvIHRoaXMgZGlzdGFuY2UgZnJvbSBhIGNvbGxpZGVyLCBhIGhpdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIG1heFRvaSAtIFRoZSBtYXhpbXVtIHRpbWUtb2YtaW1wYWN0IHRoYXQgY2FuIGJlIHJlcG9ydGVkIGJ5IHRoaXMgY2FzdC4gVGhpcyBlZmZlY3RpdmVseVxuICAgICAqICAgbGltaXRzIHRoZSBkaXN0YW5jZSB0cmF2ZWxlZCBieSB0aGUgc2hhcGUgdG8gYHNoYXBlVmVsLm5vcm0oKSAqIG1heFRvaWAuXG4gICAgICogQHBhcmFtIHN0b3BBdFBlbmV0cmF0aW9uIC0gSWYgc2V0IHRvIGBmYWxzZWAsIHRoZSBsaW5lYXIgc2hhcGUtY2FzdCB3b27igJl0IGltbWVkaWF0ZWx5IHN0b3AgaWZcbiAgICAgKiAgIHRoZSBzaGFwZSBpcyBwZW5ldHJhdGluZyBhbm90aGVyIHNoYXBlIGF0IGl0cyBzdGFydGluZyBwb2ludCAqKmFuZCoqIGl0cyB0cmFqZWN0b3J5IGlzIHN1Y2hcbiAgICAgKiAgIHRoYXQgaXTigJlzIG9uIGEgcGF0aCB0byBleGl0IHRoYXQgcGVuZXRyYXRpb24gc3RhdGUuXG4gICAgICogQHBhcmFtIGdyb3VwcyAtIFRoZSBiaXQgZ3JvdXBzIGFuZCBmaWx0ZXIgYXNzb2NpYXRlZCB0byB0aGUgc2hhcGUgdG8gY2FzdCwgaW4gb3JkZXIgdG8gb25seVxuICAgICAqICAgdGVzdCBvbiBjb2xsaWRlcnMgd2l0aCBjb2xsaXNpb24gZ3JvdXBzIGNvbXBhdGlibGUgd2l0aCB0aGlzIGdyb3VwLlxuICAgICAqL1xuICAgIGNhc3RTaGFwZShzaGFwZVBvcywgc2hhcGVSb3QsIHNoYXBlVmVsLCBzaGFwZSwgdGFyZ2V0RGlzdGFuY2UsIG1heFRvaSwgc3RvcEF0UGVuZXRyYXRpb24sIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSwgZmlsdGVyUHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5UGlwZWxpbmUuY2FzdFNoYXBlKHRoaXMuYm9kaWVzLCB0aGlzLmNvbGxpZGVycywgc2hhcGVQb3MsIHNoYXBlUm90LCBzaGFwZVZlbCwgc2hhcGUsIHRhcmdldERpc3RhbmNlLCBtYXhUb2ksIHN0b3BBdFBlbmV0cmF0aW9uLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIgPyBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIuaGFuZGxlIDogbnVsbCwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSA/IGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHkuaGFuZGxlIDogbnVsbCwgdGhpcy5jb2xsaWRlcnMuY2FzdENsb3N1cmUoZmlsdGVyUHJlZGljYXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGFsbCB0aGUgY29sbGlkZXJzIGludGVyc2VjdGluZyB0aGUgZ2l2ZW4gc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hhcGVQb3MgLSBUaGUgcG9zaXRpb24gb2YgdGhlIHNoYXBlIHRvIHRlc3QuXG4gICAgICogQHBhcmFtIHNoYXBlUm90IC0gVGhlIG9yaWVudGF0aW9uIG9mIHRoZSBzaGFwZSB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSBzaGFwZSAtIFRoZSBzaGFwZSB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSBncm91cHMgLSBUaGUgYml0IGdyb3VwcyBhbmQgZmlsdGVyIGFzc29jaWF0ZWQgdG8gdGhlIHNoYXBlIHRvIHRlc3QsIGluIG9yZGVyIHRvIG9ubHlcbiAgICAgKiAgIHRlc3Qgb24gY29sbGlkZXJzIHdpdGggY29sbGlzaW9uIGdyb3VwcyBjb21wYXRpYmxlIHdpdGggdGhpcyBncm91cC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBoYW5kbGVzIG9mIGVhY2ggY29sbGlkZXIgaW50ZXJzZWN0aW5nIHRoZSBgc2hhcGVgLlxuICAgICAqL1xuICAgIGludGVyc2VjdGlvbnNXaXRoU2hhcGUoc2hhcGVQb3MsIHNoYXBlUm90LCBzaGFwZSwgY2FsbGJhY2ssIGZpbHRlckZsYWdzLCBmaWx0ZXJHcm91cHMsIGZpbHRlckV4Y2x1ZGVDb2xsaWRlciwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSwgZmlsdGVyUHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMucXVlcnlQaXBlbGluZS5pbnRlcnNlY3Rpb25zV2l0aFNoYXBlKHRoaXMuYm9kaWVzLCB0aGlzLmNvbGxpZGVycywgc2hhcGVQb3MsIHNoYXBlUm90LCBzaGFwZSwgdGhpcy5jb2xsaWRlcnMuY2FzdENsb3N1cmUoY2FsbGJhY2spLCBmaWx0ZXJGbGFncywgZmlsdGVyR3JvdXBzLCBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIgPyBmaWx0ZXJFeGNsdWRlQ29sbGlkZXIuaGFuZGxlIDogbnVsbCwgZmlsdGVyRXhjbHVkZVJpZ2lkQm9keSA/IGZpbHRlckV4Y2x1ZGVSaWdpZEJvZHkuaGFuZGxlIDogbnVsbCwgdGhpcy5jb2xsaWRlcnMuY2FzdENsb3N1cmUoZmlsdGVyUHJlZGljYXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBoYW5kbGVzIG9mIGFsbCB0aGUgY29sbGlkZXJzIHdpdGggYW4gQUFCQiBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIEFBQkIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWFiYkNlbnRlciAtIFRoZSBjZW50ZXIgb2YgdGhlIEFBQkIgdG8gdGVzdC5cbiAgICAgKiBAcGFyYW0gYWFiYkhhbGZFeHRlbnRzIC0gVGhlIGhhbGYtZXh0ZW50cyBvZiB0aGUgQUFCQiB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGhhbmRsZXMgb2YgYWxsIHRoZSBjb2xsaWRlcnNcbiAgICAgKiAgICAgICAgICAgICAgICAgICBjdXJyZW50bHkgaW50ZXJzZWN0aW5nIHRoZSBnaXZlbiBBQUJCLlxuICAgICAqL1xuICAgIGNvbGxpZGVyc1dpdGhBYWJiSW50ZXJzZWN0aW5nQWFiYihhYWJiQ2VudGVyLCBhYWJiSGFsZkV4dGVudHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucXVlcnlQaXBlbGluZS5jb2xsaWRlcnNXaXRoQWFiYkludGVyc2VjdGluZ0FhYmIoYWFiYkNlbnRlciwgYWFiYkhhbGZFeHRlbnRzLCB0aGlzLmNvbGxpZGVycy5jYXN0Q2xvc3VyZShjYWxsYmFjaykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCB0aGUgY29sbGlkZXJzIHBvdGVudGlhbGx5IGluIGNvbnRhY3Qgd2l0aCB0aGUgZ2l2ZW4gY29sbGlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sbGlkZXIxIC0gVGhlIHNlY29uZCBjb2xsaWRlciBpbnZvbHZlZCBpbiB0aGUgY29udGFjdC5cbiAgICAgKiBAcGFyYW0gZiAtIENsb3N1cmUgdGhhdCB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIGNvbGxpZGVyIHRoYXQgaXMgaW4gY29udGFjdCB3aXRoIGBjb2xsaWRlcjFgLlxuICAgICAqL1xuICAgIGNvbnRhY3RQYWlyc1dpdGgoY29sbGlkZXIxLCBmKSB7XG4gICAgICAgIHRoaXMubmFycm93UGhhc2UuY29udGFjdFBhaXJzV2l0aChjb2xsaWRlcjEuaGFuZGxlLCB0aGlzLmNvbGxpZGVycy5jYXN0Q2xvc3VyZShmKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudW1lcmF0ZXMgYWxsIHRoZSBjb2xsaWRlcnMgaW50ZXJzZWN0aW5nIHRoZSBnaXZlbiBjb2xsaWRlcnMsIGFzc3VtaW5nIG9uZSBvZiB0aGVtXG4gICAgICogaXMgYSBzZW5zb3IuXG4gICAgICovXG4gICAgaW50ZXJzZWN0aW9uUGFpcnNXaXRoKGNvbGxpZGVyMSwgZikge1xuICAgICAgICB0aGlzLm5hcnJvd1BoYXNlLmludGVyc2VjdGlvblBhaXJzV2l0aChjb2xsaWRlcjEuaGFuZGxlLCB0aGlzLmNvbGxpZGVycy5jYXN0Q2xvc3VyZShmKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIHRoZSBjb250YWN0IG1hbmlmb2xkcyBiZXR3ZWVuIHRoZSBnaXZlbiBwYWlyIG9mIGNvbGxpZGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xsaWRlcjEgLSBUaGUgZmlyc3QgY29sbGlkZXIgaW52b2x2ZWQgaW4gdGhlIGNvbnRhY3QuXG4gICAgICogQHBhcmFtIGNvbGxpZGVyMiAtIFRoZSBzZWNvbmQgY29sbGlkZXIgaW52b2x2ZWQgaW4gdGhlIGNvbnRhY3QuXG4gICAgICogQHBhcmFtIGYgLSBDbG9zdXJlIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBjb250YWN0IG1hbmlmb2xkIGJldHdlZW4gdGhlIHR3byBjb2xsaWRlcnMuIElmIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAgICAgKiAgICAgICAgICAgIHBhc3NlZCB0byB0aGlzIGNsb3N1cmUgaXMgYHRydWVgLCB0aGVuIHRoZSBjb250YWN0IG1hbmlmb2xkIGRhdGEgaXMgZmxpcHBlZCwgaS5lLiwgbWV0aG9kcyBsaWtlIGBsb2NhbE5vcm1hbDFgXG4gICAgICogICAgICAgICAgICBhY3R1YWxseSBhcHBseSB0byB0aGUgYGNvbGxpZGVyMmAgYW5kIGZpZWxkcyBsaWtlIGBsb2NhbE5vcm1hbDJgIGFwcGx5IHRvIHRoZSBgY29sbGlkZXIxYC5cbiAgICAgKi9cbiAgICBjb250YWN0UGFpcihjb2xsaWRlcjEsIGNvbGxpZGVyMiwgZikge1xuICAgICAgICB0aGlzLm5hcnJvd1BoYXNlLmNvbnRhY3RQYWlyKGNvbGxpZGVyMS5oYW5kbGUsIGNvbGxpZGVyMi5oYW5kbGUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBgY29sbGlkZXIxYCBhbmQgYGNvbGxpZGVyMmAgaW50ZXJzZWN0IGFuZCBhdCBsZWFzdCBvbmUgb2YgdGhlbSBpcyBhIHNlbnNvci5cbiAgICAgKiBAcGFyYW0gY29sbGlkZXIxIOKIkiBUaGUgZmlyc3QgY29sbGlkZXIgaW52b2x2ZWQgaW4gdGhlIGludGVyc2VjdGlvbi5cbiAgICAgKiBAcGFyYW0gY29sbGlkZXIyIOKIkiBUaGUgc2Vjb25kIGNvbGxpZGVyIGludm9sdmVkIGluIHRoZSBpbnRlcnNlY3Rpb24uXG4gICAgICovXG4gICAgaW50ZXJzZWN0aW9uUGFpcihjb2xsaWRlcjEsIGNvbGxpZGVyMikge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXJyb3dQaGFzZS5pbnRlcnNlY3Rpb25QYWlyKGNvbGxpZGVyMS5oYW5kbGUsIGNvbGxpZGVyMi5oYW5kbGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmxkLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/pipeline/world.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier.js":
/*!*******************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/rapier.js ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveCollisionTypes),\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveHooks),\n/* harmony export */   Ball: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.BroadPhase),\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CCDSolver),\n/* harmony export */   Capsule: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Capsule),\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CharacterCollision),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),\n/* harmony export */   Collider: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderSet),\n/* harmony export */   ColliderShapeCastHit: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderShapeCastHit),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Cuboid),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.EventQueue),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FeatureType),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FixedMultibodyJoint),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Heightfield),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointType),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.KinematicCharacterController),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MassPropsMode),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MultibodyJointSet),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.NarrowPhase),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PhysicsPipeline),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Polyline),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PrismaticMultibodyJoint),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.QueryPipeline),\n/* harmony export */   Ray: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Ray),\n/* harmony export */   RayColliderHit: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayColliderHit),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayColliderIntersection),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayIntersection),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RopeImpulseJoint),\n/* harmony export */   RotationOps: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RotationOps),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Segment),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SerializationPipeline),\n/* harmony export */   Shape: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Shape),\n/* harmony export */   ShapeCastHit: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeCastHit),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeContact),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeType),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SolverFlags),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SpringImpulseJoint),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TempContactForceEvent),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TriMesh),\n/* harmony export */   TriMeshFlags: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TriMeshFlags),\n/* harmony export */   Triangle: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Triangle),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.UnitMultibodyJoint),\n/* harmony export */   Vector2: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Vector2),\n/* harmony export */   VectorOps: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.VectorOps),\n/* harmony export */   World: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.World),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   version: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exports */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/exports.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_exports__WEBPACK_IMPORTED_MODULE_0__]);\n_exports__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_exports__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceMappingURL=rapier.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3JhcGllci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNWO0FBQzFCLGlFQUFlLHFDQUFNLEVBQUM7QUFDdEIsa0MiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxccmFwaWVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJBUElFUiBmcm9tIFwiLi9leHBvcnRzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9leHBvcnRzXCI7XG5leHBvcnQgZGVmYXVsdCBSQVBJRVI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXBpZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawBroadPhase: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawBroadPhase),\n/* harmony export */   RawCCDSolver: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawCCDSolver),\n/* harmony export */   RawCharacterCollision: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawCharacterCollision),\n/* harmony export */   RawColliderSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawColliderSet),\n/* harmony export */   RawColliderShapeCastHit: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawColliderShapeCastHit),\n/* harmony export */   RawContactForceEvent: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactForceEvent),\n/* harmony export */   RawContactManifold: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactManifold),\n/* harmony export */   RawContactPair: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactPair),\n/* harmony export */   RawDebugRenderPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawDebugRenderPipeline),\n/* harmony export */   RawDeserializedWorld: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawDeserializedWorld),\n/* harmony export */   RawEventQueue: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawEventQueue),\n/* harmony export */   RawFeatureType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawFeatureType),\n/* harmony export */   RawGenericJoint: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint),\n/* harmony export */   RawImpulseJointSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawImpulseJointSet),\n/* harmony export */   RawIntegrationParameters: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawIntegrationParameters),\n/* harmony export */   RawIslandManager: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawIslandManager),\n/* harmony export */   RawJointAxis: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis),\n/* harmony export */   RawJointType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawJointType),\n/* harmony export */   RawKinematicCharacterController: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawKinematicCharacterController),\n/* harmony export */   RawMotorModel: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawMotorModel),\n/* harmony export */   RawMultibodyJointSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawMultibodyJointSet),\n/* harmony export */   RawNarrowPhase: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawNarrowPhase),\n/* harmony export */   RawPhysicsPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPhysicsPipeline),\n/* harmony export */   RawPointColliderProjection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPointColliderProjection),\n/* harmony export */   RawPointProjection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPointProjection),\n/* harmony export */   RawQueryPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawQueryPipeline),\n/* harmony export */   RawRayColliderHit: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayColliderHit),\n/* harmony export */   RawRayColliderIntersection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayColliderIntersection),\n/* harmony export */   RawRayIntersection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayIntersection),\n/* harmony export */   RawRigidBodySet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodySet),\n/* harmony export */   RawRigidBodyType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodyType),\n/* harmony export */   RawRotation: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRotation),\n/* harmony export */   RawSerializationPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawSerializationPipeline),\n/* harmony export */   RawShape: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShape),\n/* harmony export */   RawShapeCastHit: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeCastHit),\n/* harmony export */   RawShapeContact: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeContact),\n/* harmony export */   RawShapeType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeType),\n/* harmony export */   RawVector: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawVector),\n/* harmony export */   __wbg_bind_4d857b598695205e: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_bind_4d857b598695205e),\n/* harmony export */   __wbg_buffer_12d079cc21e14bdb: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_buffer_12d079cc21e14bdb),\n/* harmony export */   __wbg_call_8e7cb608789c2528: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_8e7cb608789c2528),\n/* harmony export */   __wbg_call_938992c832f74314: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_938992c832f74314),\n/* harmony export */   __wbg_call_b3ca7c6051f9bec1: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_b3ca7c6051f9bec1),\n/* harmony export */   __wbg_length_c20a40f15020d68a: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_c20a40f15020d68a),\n/* harmony export */   __wbg_length_d25bbcbc3367f684: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_d25bbcbc3367f684),\n/* harmony export */   __wbg_new_63b92bc8671ed464: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_63b92bc8671ed464),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_4a659d079a1650e0: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_4a659d079a1650e0),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb),\n/* harmony export */   __wbg_newwithlength_1e8b839a06de01c5: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithlength_1e8b839a06de01c5),\n/* harmony export */   __wbg_rawcontactforceevent_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_rawcontactforceevent_new),\n/* harmony export */   __wbg_rawraycolliderintersection_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_rawraycolliderintersection_new),\n/* harmony export */   __wbg_set_a47bac70306a19a7: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_a47bac70306a19a7),\n/* harmony export */   __wbg_set_bd975934d1b1fddb: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_bd975934d1b1fddb),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   __wbindgen_boolean_get: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_boolean_get),\n/* harmony export */   __wbindgen_is_function: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_function),\n/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_new),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),\n/* harmony export */   version: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rapier_wasm2d_bg.wasm */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm\");\n/* harmony import */ var _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rapier_wasm2d_bg.js */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);\n_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n(0,_rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm)(_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__);\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3JhcGllcl93YXNtMmQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNPO0FBQ3ZELG9FQUFjLENBQUMsbURBQUk7QUFDbUIiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcQGRpbWZvcmdlXFxyYXBpZXIyZFxccmFwaWVyX3dhc20yZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB3YXNtIGZyb20gXCIuL3JhcGllcl93YXNtMmRfYmcud2FzbVwiO1xuaW1wb3J0IHsgX193Ymdfc2V0X3dhc20gfSBmcm9tIFwiLi9yYXBpZXJfd2FzbTJkX2JnLmpzXCI7XG5fX3diZ19zZXRfd2FzbSh3YXNtKTtcbmV4cG9ydCAqIGZyb20gXCIuL3JhcGllcl93YXNtMmRfYmcuanNcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawBroadPhase: () => (/* binding */ RawBroadPhase),\n/* harmony export */   RawCCDSolver: () => (/* binding */ RawCCDSolver),\n/* harmony export */   RawCharacterCollision: () => (/* binding */ RawCharacterCollision),\n/* harmony export */   RawColliderSet: () => (/* binding */ RawColliderSet),\n/* harmony export */   RawColliderShapeCastHit: () => (/* binding */ RawColliderShapeCastHit),\n/* harmony export */   RawContactForceEvent: () => (/* binding */ RawContactForceEvent),\n/* harmony export */   RawContactManifold: () => (/* binding */ RawContactManifold),\n/* harmony export */   RawContactPair: () => (/* binding */ RawContactPair),\n/* harmony export */   RawDebugRenderPipeline: () => (/* binding */ RawDebugRenderPipeline),\n/* harmony export */   RawDeserializedWorld: () => (/* binding */ RawDeserializedWorld),\n/* harmony export */   RawEventQueue: () => (/* binding */ RawEventQueue),\n/* harmony export */   RawFeatureType: () => (/* binding */ RawFeatureType),\n/* harmony export */   RawGenericJoint: () => (/* binding */ RawGenericJoint),\n/* harmony export */   RawImpulseJointSet: () => (/* binding */ RawImpulseJointSet),\n/* harmony export */   RawIntegrationParameters: () => (/* binding */ RawIntegrationParameters),\n/* harmony export */   RawIslandManager: () => (/* binding */ RawIslandManager),\n/* harmony export */   RawJointAxis: () => (/* binding */ RawJointAxis),\n/* harmony export */   RawJointType: () => (/* binding */ RawJointType),\n/* harmony export */   RawKinematicCharacterController: () => (/* binding */ RawKinematicCharacterController),\n/* harmony export */   RawMotorModel: () => (/* binding */ RawMotorModel),\n/* harmony export */   RawMultibodyJointSet: () => (/* binding */ RawMultibodyJointSet),\n/* harmony export */   RawNarrowPhase: () => (/* binding */ RawNarrowPhase),\n/* harmony export */   RawPhysicsPipeline: () => (/* binding */ RawPhysicsPipeline),\n/* harmony export */   RawPointColliderProjection: () => (/* binding */ RawPointColliderProjection),\n/* harmony export */   RawPointProjection: () => (/* binding */ RawPointProjection),\n/* harmony export */   RawQueryPipeline: () => (/* binding */ RawQueryPipeline),\n/* harmony export */   RawRayColliderHit: () => (/* binding */ RawRayColliderHit),\n/* harmony export */   RawRayColliderIntersection: () => (/* binding */ RawRayColliderIntersection),\n/* harmony export */   RawRayIntersection: () => (/* binding */ RawRayIntersection),\n/* harmony export */   RawRigidBodySet: () => (/* binding */ RawRigidBodySet),\n/* harmony export */   RawRigidBodyType: () => (/* binding */ RawRigidBodyType),\n/* harmony export */   RawRotation: () => (/* binding */ RawRotation),\n/* harmony export */   RawSerializationPipeline: () => (/* binding */ RawSerializationPipeline),\n/* harmony export */   RawShape: () => (/* binding */ RawShape),\n/* harmony export */   RawShapeCastHit: () => (/* binding */ RawShapeCastHit),\n/* harmony export */   RawShapeContact: () => (/* binding */ RawShapeContact),\n/* harmony export */   RawShapeType: () => (/* binding */ RawShapeType),\n/* harmony export */   RawVector: () => (/* binding */ RawVector),\n/* harmony export */   __wbg_bind_4d857b598695205e: () => (/* binding */ __wbg_bind_4d857b598695205e),\n/* harmony export */   __wbg_buffer_12d079cc21e14bdb: () => (/* binding */ __wbg_buffer_12d079cc21e14bdb),\n/* harmony export */   __wbg_call_8e7cb608789c2528: () => (/* binding */ __wbg_call_8e7cb608789c2528),\n/* harmony export */   __wbg_call_938992c832f74314: () => (/* binding */ __wbg_call_938992c832f74314),\n/* harmony export */   __wbg_call_b3ca7c6051f9bec1: () => (/* binding */ __wbg_call_b3ca7c6051f9bec1),\n/* harmony export */   __wbg_length_c20a40f15020d68a: () => (/* binding */ __wbg_length_c20a40f15020d68a),\n/* harmony export */   __wbg_length_d25bbcbc3367f684: () => (/* binding */ __wbg_length_d25bbcbc3367f684),\n/* harmony export */   __wbg_new_63b92bc8671ed464: () => (/* binding */ __wbg_new_63b92bc8671ed464),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_4a659d079a1650e0: () => (/* binding */ __wbg_newwithbyteoffsetandlength_4a659d079a1650e0),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb: () => (/* binding */ __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb),\n/* harmony export */   __wbg_newwithlength_1e8b839a06de01c5: () => (/* binding */ __wbg_newwithlength_1e8b839a06de01c5),\n/* harmony export */   __wbg_rawcontactforceevent_new: () => (/* binding */ __wbg_rawcontactforceevent_new),\n/* harmony export */   __wbg_rawraycolliderintersection_new: () => (/* binding */ __wbg_rawraycolliderintersection_new),\n/* harmony export */   __wbg_set_a47bac70306a19a7: () => (/* binding */ __wbg_set_a47bac70306a19a7),\n/* harmony export */   __wbg_set_bd975934d1b1fddb: () => (/* binding */ __wbg_set_bd975934d1b1fddb),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbindgen_boolean_get: () => (/* binding */ __wbindgen_boolean_get),\n/* harmony export */   __wbindgen_is_function: () => (/* binding */ __wbindgen_is_function),\n/* harmony export */   __wbindgen_memory: () => (/* binding */ __wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* binding */ __wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* binding */ __wbindgen_number_new),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* binding */ __wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nfunction version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nconst RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nconst RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolygon:9,\"9\":\"ConvexPolygon\",RoundCuboid:10,\"10\":\"RoundCuboid\",RoundTriangle:11,\"11\":\"RoundTriangle\",RoundConvexPolygon:12,\"12\":\"RoundConvexPolygon\",HalfSpace:13,\"13\":\"HalfSpace\", });\n/**\n*/\nconst RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Rope:3,\"3\":\"Rope\",Spring:4,\"4\":\"Spring\",Generic:5,\"5\":\"Generic\", });\n/**\n*/\nconst RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nconst RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Face:1,\"1\":\"Face\",Unknown:2,\"2\":\"Unknown\", });\n/**\n*/\nconst RawJointAxis = Object.freeze({ LinX:0,\"0\":\"LinX\",LinY:1,\"1\":\"LinY\",AngX:2,\"2\":\"AngX\", });\n\nconst RawBroadPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawbroadphase_free(ptr >>> 0));\n/**\n*/\nclass RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawBroadPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawBroadPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n\nconst RawCCDSolverFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawccdsolver_free(ptr >>> 0));\n/**\n*/\nclass RawCCDSolver {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCCDSolverFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n\nconst RawCharacterCollisionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcharactercollision_free(ptr >>> 0));\n/**\n*/\nclass RawCharacterCollision {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCharacterCollisionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawColliderSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcolliderset_free(ptr >>> 0));\n/**\n*/\nclass RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    coSetTranslation(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    coSetTranslationWrtParent(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * Sets the rotation angle of this collider.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} angle\n    */\n    coSetRotation(handle, angle) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} angle\n    */\n    coSetRotationWrtParent(handle, angle) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {RawShapeType}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coTriMeshFlags(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coTriMeshFlags(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} contact_skin\n    */\n    coSetContactSkin(handle, contact_skin) {\n        wasm.rawcolliderset_coSetContactSkin(this.__wbg_ptr, handle, contact_skin);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactSkin(handle) {\n        const ret = wasm.rawcolliderset_coContactSkin(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeCastHit | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} target_distance\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawColliderShapeCastHit | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, target_distance, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, target_distance, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {number} contactSkin\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawColliderShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcollidershapecasthit_free(ptr >>> 0));\n/**\n*/\nclass RawColliderShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcollidershapecasthit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcollidershapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactForceEventFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactforceevent_free(ptr >>> 0));\n/**\n*/\nclass RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactForceEventFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactForceEventFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawContactManifoldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactmanifold_free(ptr >>> 0));\n/**\n*/\nclass RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactManifoldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactManifoldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactpair_free(ptr >>> 0));\n/**\n*/\nclass RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n\nconst RawDebugRenderPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdebugrenderpipeline_free(ptr >>> 0));\n/**\n*/\nclass RawDebugRenderPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDebugRenderPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n}\n\nconst RawDeserializedWorldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdeserializedworld_free(ptr >>> 0));\n/**\n*/\nclass RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n        RawDeserializedWorldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDeserializedWorldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n\nconst RawEventQueueFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_raweventqueue_free(ptr >>> 0));\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nclass RawEventQueue {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawEventQueueFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n\nconst RawGenericJointFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawgenericjoint_free(ptr >>> 0));\n/**\n*/\nclass RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n        RawGenericJointFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawGenericJointFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * @param {number} rest_length\n    * @param {number} stiffness\n    * @param {number} damping\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * @param {number} length\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static rope(length, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n\nconst RawImpulseJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawimpulsejointset_free(ptr >>> 0));\n/**\n*/\nclass RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawImpulseJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawImpulseJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {RawMotorModel} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawIntegrationParametersFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawintegrationparameters_free(ptr >>> 0));\n/**\n*/\nclass RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIntegrationParametersFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIntegrationParametersFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get contact_erp() {\n        const ret = wasm.rawintegrationparameters_contact_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get normalizedAllowedLinearError() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get normalizedPredictionDistance() {\n        const ret = wasm.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get numSolverIterations() {\n        const ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numAdditionalFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numInternalPgsIterations() {\n        const ret = wasm.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get lengthUnit() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set contact_natural_frequency(value) {\n        wasm.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set normalizedAllowedLinearError(value) {\n        wasm.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set normalizedPredictionDistance(value) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numSolverIterations(value) {\n        wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numAdditionalFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numInternalPgsIterations(value) {\n        wasm.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set lengthUnit(value) {\n        wasm.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, value);\n    }\n    /**\n    */\n    switchToStandardPgsSolver() {\n        wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n    switchToSmallStepsPgsSolver() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);\n    }\n}\n\nconst RawIslandManagerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawislandmanager_free(ptr >>> 0));\n/**\n*/\nclass RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIslandManagerFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIslandManagerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawKinematicCharacterControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawkinematiccharactercontroller_free(ptr >>> 0));\n/**\n*/\nclass RawKinematicCharacterController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawKinematicCharacterControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawcollidershapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    normalNudgeFactor() {\n        const ret = wasm.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setNormalNudgeFactor(value) {\n        wasm.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation_delta\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawMultibodyJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawmultibodyjointset_free(ptr >>> 0));\n/**\n*/\nclass RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawMultibodyJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawMultibodyJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawNarrowPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawnarrowphase_free(ptr >>> 0));\n/**\n*/\nclass RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawNarrowPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawNarrowPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contact_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersection_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n\nconst RawPhysicsPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawphysicspipeline_free(ptr >>> 0));\n/**\n*/\nclass RawPhysicsPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPhysicsPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n\nconst RawPointColliderProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointcolliderprojection_free(ptr >>> 0));\n/**\n*/\nclass RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointColliderProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointColliderProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RawPointProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointprojection_free(ptr >>> 0));\n/**\n*/\nclass RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawQueryPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawquerypipeline_free(ptr >>> 0));\n/**\n*/\nclass RawQueryPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawQueryPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    update(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderHit | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawColliderShapeCastHit | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, target_distance, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, target_distance, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawRayColliderHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderhit_free(ptr >>> 0));\n/**\n*/\nclass RawRayColliderHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderhit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    timeOfImpact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawRayColliderIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderintersection_free(ptr >>> 0));\n/**\n*/\nclass RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RawRayIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrayintersection_free(ptr >>> 0));\n/**\n*/\nclass RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RawRigidBodySetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrigidbodyset_free(ptr >>> 0));\n/**\n*/\nclass RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRigidBodySetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRigidBodySetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, wakeUp);\n    }\n    /**\n    * Sets the rotation angle of this rigid-body.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} angle\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, angle, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, angle, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {number} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    */\n    rbSetNextKinematicTranslation(handle, x, y) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `angle`: the rotation angle, in radians.\n    * @param {number} handle\n    * @param {number} angle\n    */\n    rbSetNextKinematicRotation(handle, angle) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {number} principalAngularInertia\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} prediction\n    */\n    rbSetSoftCcdPrediction(handle, prediction) {\n        wasm.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, handle, prediction);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This method forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbSoftCcdPrediction(handle) {\n        const ret = wasm.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {RawRigidBodyType}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {RawRigidBodyType} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {number} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {number} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAdditionalSolverIterations(handle) {\n        const ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} iters\n    */\n    rbSetAdditionalSolverIterations(handle, iters) {\n        wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n    * Retrieves the constant force(s) the user added to this rigid-body.\n    * Returns zero if the rigid-body is not dynamic.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbUserForce(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserForce(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Retrieves the constant torque(s) the user added to this rigid-body.\n    * Returns zero if the rigid-body is not dynamic.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserTorque(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {number} angvel\n    * @param {number} principalAngularInertia\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} rotationsEnabled\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {RawRigidBodyType} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {number} softCcdPrediciton\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @param {number} additional_solver_iterations\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediciton, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediciton, ccdEnabled, dominanceGroup, additional_solver_iterations);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n\nconst RawRotationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrotation_free(ptr >>> 0));\n/**\n* A rotation quaternion.\n*/\nclass RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRotationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRotationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * The identity rotation.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The rotation with thegiven angle.\n    * @param {number} angle\n    * @returns {RawRotation}\n    */\n    static fromAngle(angle) {\n        const ret = wasm.rawrotation_fromAngle(angle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The imaginary part of this complex number.\n    * @returns {number}\n    */\n    get im() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The real part of this complex number.\n    * @returns {number}\n    */\n    get re() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The rotation angle in radians.\n    * @returns {number}\n    */\n    get angle() {\n        const ret = wasm.rawrotation_angle(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawSerializationPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawserializationpipeline_free(ptr >>> 0));\n/**\n*/\nclass RawSerializationPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawSerializationPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n\nconst RawShapeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshape_free(ptr >>> 0));\n/**\n*/\nclass RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy) {\n        const ret = wasm.rawshape_cuboid(hx, hy);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} flags\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices, flags) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1, flags);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(ptr0, len0, scale.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @returns {RawShape | undefined}\n    */\n    static convexPolyline(vertices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexPolyline(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexPolyline(vertices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexPolyline(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeCastHit | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n\nconst RawShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecasthit_free(ptr >>> 0));\n/**\n*/\nclass RawShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecasthit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcollidershapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawShapeContactFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecontact_free(ptr >>> 0));\n/**\n*/\nclass RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeContactFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeContactFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawVectorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawvector_free(ptr >>> 0));\n/**\n* A vector.\n*/\nclass RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n        RawVectorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawVectorFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 2D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 2D vector.\n    * - `y`: the `y` component of this 2D vector.\n    * @param {number} x\n    * @param {number} y\n    */\n    constructor(x, y) {\n        const ret = wasm.rawvector_new(x, y);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n    * Create a new 2D vector from this vector with its components rearranged as `{x, y}`.\n    * @returns {RawVector}\n    */\n    xy() {\n        const ret = wasm.rawvector_xy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 2D vector from this vector with its components rearranged as `{y, x}`.\n    * @returns {RawVector}\n    */\n    yx() {\n        const ret = wasm.rawvector_yx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nfunction __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nfunction __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nfunction __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nfunction __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nfunction __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_call_b3ca7c6051f9bec1() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_call_8e7cb608789c2528() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_call_938992c832f74314() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_bind_4d857b598695205e(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_buffer_12d079cc21e14bdb(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_new_63b92bc8671ed464(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_set_a47bac70306a19a7(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nfunction __wbg_length_c20a40f15020d68a(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nfunction __wbg_newwithbyteoffsetandlength_4a659d079a1650e0(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_set_bd975934d1b1fddb(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nfunction __wbg_length_d25bbcbc3367f684(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nfunction __wbg_newwithlength_1e8b839a06de01c5(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nfunction __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQGRpbWZvcmdlL3JhcGllcjJkL3JhcGllcl93YXNtMmRfYmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0QsOEJBQThCOztBQUVsRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QywwSkFBMEo7QUFDMU07QUFDQTtBQUNPLHFDQUFxQywwWkFBMFo7QUFDdGM7QUFDQTtBQUNPLHFDQUFxQyw0SUFBNEk7QUFDeEw7QUFDQTtBQUNPLHNDQUFzQyw0RUFBNEU7QUFDekg7QUFDQTtBQUNPLHVDQUF1QyxrRUFBa0U7QUFDaEg7QUFDQTtBQUNPLHFDQUFxQyx3REFBd0Q7O0FBRXBHO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFdBQVc7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsV0FBVztBQUN6QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsV0FBVztBQUN6QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxpQkFBaUI7QUFDL0IsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsc0JBQXNCO0FBQ3BDLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFdBQVc7QUFDekIsY0FBYyxXQUFXO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsY0FBYztBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsY0FBYztBQUM1QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsY0FBYztBQUM1QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsV0FBVztBQUN6QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsdUJBQXVCO0FBQ3JDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsY0FBYztBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxjQUFjO0FBQzVCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLDBCQUEwQjtBQUN4QyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGVBQWU7QUFDN0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLDBCQUEwQjtBQUN4QyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGVBQWU7QUFDN0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyxjQUFjO0FBQzVCLGNBQWMsZUFBZTtBQUM3QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFdBQVc7QUFDekIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsVUFBVTtBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLFVBQVU7QUFDeEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFdBQVc7QUFDekIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxVQUFVO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxVQUFVO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsUUFBUTtBQUN0QixjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLFVBQVU7QUFDeEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixjQUFjLGdCQUFnQjtBQUM5QixjQUFjLFdBQVc7QUFDekIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsUUFBUTtBQUN0QixjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxVQUFVO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsUUFBUTtBQUN0QixjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsV0FBVztBQUN6QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsV0FBVztBQUN6QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFdBQVc7QUFDekIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMsb0JBQW9CO0FBQ2xDLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLDBCQUEwQjtBQUN4QyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGVBQWU7QUFDN0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxnQkFBZ0I7QUFDOUIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxzQkFBc0I7QUFDcEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLGNBQWMsYUFBYTtBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUIsY0FBYyxXQUFXO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsY0FBYyxXQUFXO0FBQ3pCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsV0FBVztBQUN6QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFVBQVU7QUFDeEIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFdBQVc7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLGFBQWE7QUFDM0IsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFdBQVc7QUFDekIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsY0FBYyxhQUFhO0FBQzNCLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLEtBQUs7QUFDdkYsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixLQUFLO0FBQ3ZGLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSx5Q0FBeUM7QUFDaEQ7QUFDQTtBQUNBLENBQUM7O0FBRU0seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEBkaW1mb3JnZVxccmFwaWVyMmRcXHJhcGllcl93YXNtMmRfYmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHdhc207XG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2V0X3dhc20odmFsKSB7XG4gICAgd2FzbSA9IHZhbDtcbn1cblxuXG5jb25zdCBoZWFwID0gbmV3IEFycmF5KDEyOCkuZmlsbCh1bmRlZmluZWQpO1xuXG5oZWFwLnB1c2godW5kZWZpbmVkLCBudWxsLCB0cnVlLCBmYWxzZSk7XG5cbmxldCBoZWFwX25leHQgPSBoZWFwLmxlbmd0aDtcblxuZnVuY3Rpb24gYWRkSGVhcE9iamVjdChvYmopIHtcbiAgICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aCkgaGVhcC5wdXNoKGhlYXAubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGhlYXBbaWR4XTtcblxuICAgIGhlYXBbaWR4XSA9IG9iajtcbiAgICByZXR1cm4gaWR4O1xufVxuXG5mdW5jdGlvbiBnZXRPYmplY3QoaWR4KSB7IHJldHVybiBoZWFwW2lkeF07IH1cblxuZnVuY3Rpb24gZHJvcE9iamVjdChpZHgpIHtcbiAgICBpZiAoaWR4IDwgMTMyKSByZXR1cm47XG4gICAgaGVhcFtpZHhdID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGlkeDtcbn1cblxuZnVuY3Rpb24gdGFrZU9iamVjdChpZHgpIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoaWR4KTtcbiAgICBkcm9wT2JqZWN0KGlkeCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaXNMaWtlTm9uZSh4KSB7XG4gICAgcmV0dXJuIHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsO1xufVxuXG5sZXQgY2FjaGVkRmxvYXQ2NE1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRGbG9hdDY0TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkRmxvYXQ2NE1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkRmxvYXQ2NE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRGbG9hdDY0TWVtb3J5MCA9IG5ldyBGbG9hdDY0QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEZsb2F0NjRNZW1vcnkwO1xufVxuXG5sZXQgY2FjaGVkSW50MzJNZW1vcnkwID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0SW50MzJNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRJbnQzMk1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkSW50MzJNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkSW50MzJNZW1vcnkwID0gbmV3IEludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZEludDMyTWVtb3J5MDtcbn1cblxuY29uc3QgbFRleHREZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyID09PSAndW5kZWZpbmVkJyA/ICgwLCBtb2R1bGUucmVxdWlyZSkoJ3V0aWwnKS5UZXh0RGVjb2RlciA6IFRleHREZWNvZGVyO1xuXG5sZXQgY2FjaGVkVGV4dERlY29kZXIgPSBuZXcgbFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlLCBmYXRhbDogdHJ1ZSB9KTtcblxuY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKCk7XG5cbmxldCBjYWNoZWRVaW50OE1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50OE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZFVpbnQ4TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWRVaW50OE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDhNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGNhY2hlZFRleHREZWNvZGVyLmRlY29kZShnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGxlbikpO1xufVxuLyoqXG4qIEByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gICAgbGV0IGRlZmVycmVkMV8wO1xuICAgIGxldCBkZWZlcnJlZDFfMTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgd2FzbS52ZXJzaW9uKHJldHB0cik7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICBkZWZlcnJlZDFfMCA9IHIwO1xuICAgICAgICBkZWZlcnJlZDFfMSA9IHIxO1xuICAgICAgICByZXR1cm4gZ2V0U3RyaW5nRnJvbVdhc20wKHIwLCByMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2ZyZWUoZGVmZXJyZWQxXzAsIGRlZmVycmVkMV8xLCAxKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDbGFzcyhpbnN0YW5jZSwga2xhc3MpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIGtsYXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGluc3RhbmNlIG9mICR7a2xhc3MubmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlLnB0cjtcbn1cblxubGV0IGNhY2hlZEZsb2F0MzJNZW1vcnkwID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0RmxvYXQzMk1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZEZsb2F0MzJNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZEZsb2F0MzJNZW1vcnkwLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgY2FjaGVkRmxvYXQzMk1lbW9yeTAgPSBuZXcgRmxvYXQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRGbG9hdDMyTWVtb3J5MDtcbn1cblxubGV0IHN0YWNrX3BvaW50ZXIgPSAxMjg7XG5cbmZ1bmN0aW9uIGFkZEJvcnJvd2VkT2JqZWN0KG9iaikge1xuICAgIGlmIChzdGFja19wb2ludGVyID09IDEpIHRocm93IG5ldyBFcnJvcignb3V0IG9mIGpzIHN0YWNrJyk7XG4gICAgaGVhcFstLXN0YWNrX3BvaW50ZXJdID0gb2JqO1xuICAgIHJldHVybiBzdGFja19wb2ludGVyO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheUYzMkZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gZ2V0RmxvYXQzMk1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyA0LCBwdHIgLyA0ICsgbGVuKTtcbn1cblxubGV0IGNhY2hlZFVpbnQzMk1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50MzJNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWRVaW50MzJNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZFVpbnQzMk1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50MzJNZW1vcnkwID0gbmV3IFVpbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50MzJNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheVUzMkZyb21XYXNtMChwdHIsIGxlbikge1xuICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICByZXR1cm4gZ2V0VWludDMyTWVtb3J5MCgpLnN1YmFycmF5KHB0ciAvIDQsIHB0ciAvIDQgKyBsZW4pO1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuZnVuY3Rpb24gcGFzc0FycmF5RjMyVG9XYXNtMChhcmcsIG1hbGxvYykge1xuICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhhcmcubGVuZ3RoICogNCwgNCkgPj4+IDA7XG4gICAgZ2V0RmxvYXQzMk1lbW9yeTAoKS5zZXQoYXJnLCBwdHIgLyA0KTtcbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBhcmcubGVuZ3RoO1xuICAgIHJldHVybiBwdHI7XG59XG5cbmZ1bmN0aW9uIHBhc3NBcnJheTMyVG9XYXNtMChhcmcsIG1hbGxvYykge1xuICAgIGNvbnN0IHB0ciA9IG1hbGxvYyhhcmcubGVuZ3RoICogNCwgNCkgPj4+IDA7XG4gICAgZ2V0VWludDMyTWVtb3J5MCgpLnNldChhcmcsIHB0ciAvIDQpO1xuICAgIFdBU01fVkVDVE9SX0xFTiA9IGFyZy5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZiwgYXJncykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4bl9zdG9yZShhZGRIZWFwT2JqZWN0KGUpKTtcbiAgICB9XG59XG4vKipcbiovXG5leHBvcnQgY29uc3QgUmF3UmlnaWRCb2R5VHlwZSA9IE9iamVjdC5mcmVlemUoeyBEeW5hbWljOjAsXCIwXCI6XCJEeW5hbWljXCIsRml4ZWQ6MSxcIjFcIjpcIkZpeGVkXCIsS2luZW1hdGljUG9zaXRpb25CYXNlZDoyLFwiMlwiOlwiS2luZW1hdGljUG9zaXRpb25CYXNlZFwiLEtpbmVtYXRpY1ZlbG9jaXR5QmFzZWQ6MyxcIjNcIjpcIktpbmVtYXRpY1ZlbG9jaXR5QmFzZWRcIiwgfSk7XG4vKipcbiovXG5leHBvcnQgY29uc3QgUmF3U2hhcGVUeXBlID0gT2JqZWN0LmZyZWV6ZSh7IEJhbGw6MCxcIjBcIjpcIkJhbGxcIixDdWJvaWQ6MSxcIjFcIjpcIkN1Ym9pZFwiLENhcHN1bGU6MixcIjJcIjpcIkNhcHN1bGVcIixTZWdtZW50OjMsXCIzXCI6XCJTZWdtZW50XCIsUG9seWxpbmU6NCxcIjRcIjpcIlBvbHlsaW5lXCIsVHJpYW5nbGU6NSxcIjVcIjpcIlRyaWFuZ2xlXCIsVHJpTWVzaDo2LFwiNlwiOlwiVHJpTWVzaFwiLEhlaWdodEZpZWxkOjcsXCI3XCI6XCJIZWlnaHRGaWVsZFwiLENvbXBvdW5kOjgsXCI4XCI6XCJDb21wb3VuZFwiLENvbnZleFBvbHlnb246OSxcIjlcIjpcIkNvbnZleFBvbHlnb25cIixSb3VuZEN1Ym9pZDoxMCxcIjEwXCI6XCJSb3VuZEN1Ym9pZFwiLFJvdW5kVHJpYW5nbGU6MTEsXCIxMVwiOlwiUm91bmRUcmlhbmdsZVwiLFJvdW5kQ29udmV4UG9seWdvbjoxMixcIjEyXCI6XCJSb3VuZENvbnZleFBvbHlnb25cIixIYWxmU3BhY2U6MTMsXCIxM1wiOlwiSGFsZlNwYWNlXCIsIH0pO1xuLyoqXG4qL1xuZXhwb3J0IGNvbnN0IFJhd0pvaW50VHlwZSA9IE9iamVjdC5mcmVlemUoeyBSZXZvbHV0ZTowLFwiMFwiOlwiUmV2b2x1dGVcIixGaXhlZDoxLFwiMVwiOlwiRml4ZWRcIixQcmlzbWF0aWM6MixcIjJcIjpcIlByaXNtYXRpY1wiLFJvcGU6MyxcIjNcIjpcIlJvcGVcIixTcHJpbmc6NCxcIjRcIjpcIlNwcmluZ1wiLEdlbmVyaWM6NSxcIjVcIjpcIkdlbmVyaWNcIiwgfSk7XG4vKipcbiovXG5leHBvcnQgY29uc3QgUmF3TW90b3JNb2RlbCA9IE9iamVjdC5mcmVlemUoeyBBY2NlbGVyYXRpb25CYXNlZDowLFwiMFwiOlwiQWNjZWxlcmF0aW9uQmFzZWRcIixGb3JjZUJhc2VkOjEsXCIxXCI6XCJGb3JjZUJhc2VkXCIsIH0pO1xuLyoqXG4qL1xuZXhwb3J0IGNvbnN0IFJhd0ZlYXR1cmVUeXBlID0gT2JqZWN0LmZyZWV6ZSh7IFZlcnRleDowLFwiMFwiOlwiVmVydGV4XCIsRmFjZToxLFwiMVwiOlwiRmFjZVwiLFVua25vd246MixcIjJcIjpcIlVua25vd25cIiwgfSk7XG4vKipcbiovXG5leHBvcnQgY29uc3QgUmF3Sm9pbnRBeGlzID0gT2JqZWN0LmZyZWV6ZSh7IExpblg6MCxcIjBcIjpcIkxpblhcIixMaW5ZOjEsXCIxXCI6XCJMaW5ZXCIsQW5nWDoyLFwiMlwiOlwiQW5nWFwiLCB9KTtcblxuY29uc3QgUmF3QnJvYWRQaGFzZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdicm9hZHBoYXNlX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3QnJvYWRQaGFzZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3QnJvYWRQaGFzZS5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSYXdCcm9hZFBoYXNlRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd0Jyb2FkUGhhc2VGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd2Jyb2FkcGhhc2VfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2Jyb2FkcGhhc2VfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNvbnN0IFJhd0NDRFNvbHZlckZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdjY2Rzb2x2ZXJfZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdDQ0RTb2x2ZXIge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdDQ0RTb2x2ZXJGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd2NjZHNvbHZlcl9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y2Nkc29sdmVyX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jb25zdCBSYXdDaGFyYWN0ZXJDb2xsaXNpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3Y2hhcmFjdGVyY29sbGlzaW9uX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3Q2hhcmFjdGVyQ29sbGlzaW9uIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3Q2hhcmFjdGVyQ29sbGlzaW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdjaGFyYWN0ZXJjb2xsaXNpb25fZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NoYXJhY3RlcmNvbGxpc2lvbl9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBoYW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y2hhcmFjdGVyY29sbGlzaW9uX2hhbmRsZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHRyYW5zbGF0aW9uRGVsdGFBcHBsaWVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NoYXJhY3RlcmNvbGxpc2lvbl90cmFuc2xhdGlvbkRlbHRhQXBwbGllZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHRyYW5zbGF0aW9uRGVsdGFSZW1haW5pbmcoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y2hhcmFjdGVyY29sbGlzaW9uX3RyYW5zbGF0aW9uRGVsdGFSZW1haW5pbmcodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICB0b2koKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y2hhcmFjdGVyY29sbGlzaW9uX3RvaSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHdvcmxkV2l0bmVzczEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y2hhcmFjdGVyY29sbGlzaW9uX3dvcmxkV2l0bmVzczEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICB3b3JsZFdpdG5lc3MyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NoYXJhY3RlcmNvbGxpc2lvbl93b3JsZFdpdG5lc3MyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgd29ybGROb3JtYWwxKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NoYXJhY3RlcmNvbGxpc2lvbl93b3JsZE5vcm1hbDEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICB3b3JsZE5vcm1hbDIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y2hhcmFjdGVyY29sbGlzaW9uX3dvcmxkTm9ybWFsMih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxufVxuXG5jb25zdCBSYXdDb2xsaWRlclNldEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdjb2xsaWRlcnNldF9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd0NvbGxpZGVyU2V0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdDb2xsaWRlclNldC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSYXdDb2xsaWRlclNldEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdDb2xsaWRlclNldEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3Y29sbGlkZXJzZXRfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSB3b3JsZC1zcGFjZSB0cmFuc2xhdGlvbiBvZiB0aGlzIGNvbGxpZGVyLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIGNvVHJhbnNsYXRpb24oaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29UcmFuc2xhdGlvbih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgd29ybGQtc3BhY2Ugb3JpZW50YXRpb24gb2YgdGhpcyBjb2xsaWRlci5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtSYXdSb3RhdGlvbn1cbiAgICAqL1xuICAgIGNvUm90YXRpb24oaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29Sb3RhdGlvbih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIFJhd1JvdGF0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHMgdGhlIHRyYW5zbGF0aW9uIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGB4YDogdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIHRoZSBjb2xsaWRlciBhbG9uZyB0aGUgYHhgIGF4aXMuXG4gICAgKiAtIGB5YDogdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIHRoZSBjb2xsaWRlciBhbG9uZyB0aGUgYHlgIGF4aXMuXG4gICAgKiAtIGB3YWtlVXBgOiBmb3JjZXMgdGhlIGNvbGxpZGVyIHRvIHdha2UtdXAgc28gaXQgaXMgcHJvcGVybHkgYWZmZWN0ZWQgYnkgZm9yY2VzIGlmIGl0XG4gICAgKiB3YXNuJ3QgbW92aW5nIGJlZm9yZSBtb2RpZnlpbmcgaXRzIHBvc2l0aW9uLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgKi9cbiAgICBjb1NldFRyYW5zbGF0aW9uKGhhbmRsZSwgeCwgeSkge1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0VHJhbnNsYXRpb24odGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgeCwgeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgKi9cbiAgICBjb1NldFRyYW5zbGF0aW9uV3J0UGFyZW50KGhhbmRsZSwgeCwgeSkge1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0VHJhbnNsYXRpb25XcnRQYXJlbnQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgeCwgeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgcm90YXRpb24gYW5nbGUgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYGFuZ2xlYDogdGhlIHJvdGF0aW9uIGFuZ2xlLCBpbiByYWRpYW5zLlxuICAgICogLSBgd2FrZVVwYDogZm9yY2VzIHRoZSBjb2xsaWRlciB0byB3YWtlLXVwIHNvIGl0IGlzIHByb3Blcmx5IGFmZmVjdGVkIGJ5IGZvcmNlcyBpZiBpdFxuICAgICogd2Fzbid0IG1vdmluZyBiZWZvcmUgbW9kaWZ5aW5nIGl0cyBwb3NpdGlvbi5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICovXG4gICAgY29TZXRSb3RhdGlvbihoYW5kbGUsIGFuZ2xlKSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRSb3RhdGlvbih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBhbmdsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgKi9cbiAgICBjb1NldFJvdGF0aW9uV3J0UGFyZW50KGhhbmRsZSwgYW5nbGUpIHtcbiAgICAgICAgd2FzbS5yYXdjb2xsaWRlcnNldF9jb1NldFJvdGF0aW9uV3J0UGFyZW50KHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGFuZ2xlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBJcyB0aGlzIGNvbGxpZGVyIGEgc2Vuc29yP1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBjb0lzU2Vuc29yKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvSXNTZW5zb3IodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHR5cGUgb2YgdGhlIHNoYXBlIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGVUeXBlfVxuICAgICovXG4gICAgY29TaGFwZVR5cGUoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29TaGFwZVR5cGUodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge1Jhd1ZlY3RvciB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIGNvSGFsZnNwYWNlTm9ybWFsKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvSGFsZnNwYWNlTm9ybWFsKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBoYWxmLWV4dGVudHMgb2YgdGhpcyBjb2xsaWRlciBpZiBpdCBpcyBoYXMgYSBjdWJvaWQgc2hhcGUuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29IYWxmRXh0ZW50cyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0hhbGZFeHRlbnRzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldCB0aGUgaGFsZi1leHRlbnRzIG9mIHRoaXMgY29sbGlkZXIgaWYgaXQgaGFzIGEgY3Vib2lkIHNoYXBlLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IG5ld0hhbGZFeHRlbnRzXG4gICAgKi9cbiAgICBjb1NldEhhbGZFeHRlbnRzKGhhbmRsZSwgbmV3SGFsZkV4dGVudHMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5ld0hhbGZFeHRlbnRzLCBSYXdWZWN0b3IpO1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0SGFsZkV4dGVudHModGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgbmV3SGFsZkV4dGVudHMuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgcmFkaXVzIG9mIHRoaXMgY29sbGlkZXIgaWYgaXQgaXMgYSBiYWxsLCBjYXBzdWxlLCBjeWxpbmRlciwgb3IgY29uZSBzaGFwZS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjb1JhZGl1cyhoYW5kbGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5yYXdjb2xsaWRlcnNldF9jb1JhZGl1cyhyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RmxvYXQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gcjAgPT09IDAgPyB1bmRlZmluZWQgOiByMTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXQgdGhlIHJhZGl1cyBvZiB0aGlzIGNvbGxpZGVyIGlmIGl0IGlzIGEgYmFsbCwgY2Fwc3VsZSwgY3lsaW5kZXIsIG9yIGNvbmUgc2hhcGUuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbmV3UmFkaXVzXG4gICAgKi9cbiAgICBjb1NldFJhZGl1cyhoYW5kbGUsIG5ld1JhZGl1cykge1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0UmFkaXVzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIG5ld1JhZGl1cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGhhbGYgaGVpZ2h0IG9mIHRoaXMgY29sbGlkZXIgaWYgaXQgaXMgYSBjYXBzdWxlLCBjeWxpbmRlciwgb3IgY29uZSBzaGFwZS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjb0hhbGZIZWlnaHQoaGFuZGxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29IYWxmSGVpZ2h0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRGbG9hdDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiByMCA9PT0gMCA/IHVuZGVmaW5lZCA6IHIxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFNldCB0aGUgaGFsZiBoZWlnaHQgb2YgdGhpcyBjb2xsaWRlciBpZiBpdCBpcyBhIGNhcHN1bGUsIGN5bGluZGVyLCBvciBjb25lIHNoYXBlLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0hhbGZoZWlnaHRcbiAgICAqL1xuICAgIGNvU2V0SGFsZkhlaWdodChoYW5kbGUsIG5ld0hhbGZoZWlnaHQpIHtcbiAgICAgICAgd2FzbS5yYXdjb2xsaWRlcnNldF9jb1NldEhhbGZIZWlnaHQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgbmV3SGFsZmhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHJhZGl1cyBvZiB0aGUgcm91bmQgZWRnZXMgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjb1JvdW5kUmFkaXVzKGhhbmRsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvUm91bmRSYWRpdXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEZsb2F0MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHIwID09PSAwID8gdW5kZWZpbmVkIDogcjE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogU2V0IHRoZSByYWRpdXMgb2YgdGhlIHJvdW5kIGVkZ2VzIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbmV3Qm9yZGVyUmFkaXVzXG4gICAgKi9cbiAgICBjb1NldFJvdW5kUmFkaXVzKGhhbmRsZSwgbmV3Qm9yZGVyUmFkaXVzKSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRSb3VuZFJhZGl1cyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBuZXdCb3JkZXJSYWRpdXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSB2ZXJ0aWNlcyBvZiB0aGlzIHRyaWFuZ2xlIG1lc2gsIHBvbHlsaW5lLCBjb252ZXggcG9seWhlZHJvbiwgc2VnbWVudCwgdHJpYW5nbGUgb3IgY29udmV4IHBvbHloZWRyb24sIGlmIGl0IGlzIG9uZS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXkgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjb1ZlcnRpY2VzKGhhbmRsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvVmVydGljZXMocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlGMzJGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBpbmRpY2VzIG9mIHRoaXMgdHJpYW5nbGUgbWVzaCwgcG9seWxpbmUsIG9yIGNvbnZleCBwb2x5aGVkcm9uLCBpZiBpdCBpcyBvbmUuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7VWludDMyQXJyYXkgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjb0luZGljZXMoaGFuZGxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29JbmRpY2VzKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICBsZXQgdjE7XG4gICAgICAgICAgICBpZiAocjAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2MSA9IGdldEFycmF5VTMyRnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZnJlZShyMCwgcjEgKiA0LCA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2MTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29UcmlNZXNoRmxhZ3MoaGFuZGxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29UcmlNZXNoRmxhZ3MocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiByMCA9PT0gMCA/IHVuZGVmaW5lZCA6IHIxID4+PiAwO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBoZWlnaHQgb2YgdGhpcyBoZWlnaHRmaWVsZCBpZiBpdCBpcyBvbmUuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5IHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29IZWlnaHRmaWVsZEhlaWdodHMoaGFuZGxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29IZWlnaHRmaWVsZEhlaWdodHMocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIGxldCB2MTtcbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYxID0gZ2V0QXJyYXlGMzJGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKHIwLCByMSAqIDQsIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBzY2FsaW5nIGZhY3RvciBhcHBsaWVkIG9mIHRoaXMgaGVpZ2h0ZmllbGQgaWYgaXQgaXMgb25lLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge1Jhd1ZlY3RvciB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIGNvSGVpZ2h0ZmllbGRTY2FsZShoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0hlaWdodGZpZWxkU2NhbGUodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHVuaXF1ZSBpbnRlZ2VyIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxpZGVyIHRoaXMgY29sbGlkZXIgaXMgYXR0YWNoZWQgdG8uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29QYXJlbnQoaGFuZGxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29QYXJlbnQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEZsb2F0NjRNZW1vcnkwKClbcmV0cHRyIC8gOCArIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHIwID09PSAwID8gdW5kZWZpbmVkIDogcjI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXG4gICAgKi9cbiAgICBjb1NldEVuYWJsZWQoaGFuZGxlLCBlbmFibGVkKSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRFbmFibGVkKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGVuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgY29Jc0VuYWJsZWQoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29Jc0VuYWJsZWQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhY3Rfc2tpblxuICAgICovXG4gICAgY29TZXRDb250YWN0U2tpbihoYW5kbGUsIGNvbnRhY3Rfc2tpbikge1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0Q29udGFjdFNraW4odGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgY29udGFjdF9za2luKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29Db250YWN0U2tpbihoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0NvbnRhY3RTa2luKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBmcmljdGlvbiBjb2VmZmljaWVudCBvZiB0aGlzIGNvbGxpZGVyLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNvRnJpY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29GcmljdGlvbih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgcmVzdGl0dXRpb24gY29lZmZpY2llbnQgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb1Jlc3RpdHV0aW9uKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvUmVzdGl0dXRpb24odGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGRlbnNpdHkgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb0RlbnNpdHkoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29EZW5zaXR5KHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBtYXNzIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29NYXNzKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvTWFzcyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgdm9sdW1lIG9mIHRoaXMgY29sbGlkZXIuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29Wb2x1bWUoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29Wb2x1bWUodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGNvbGxpc2lvbiBncm91cHMgb2YgdGhpcyBjb2xsaWRlci5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb0NvbGxpc2lvbkdyb3VwcyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0NvbGxpc2lvbkdyb3Vwcyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgc29sdmVyIGdyb3VwcyBvZiB0aGlzIGNvbGxpZGVyLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNvU29sdmVyR3JvdXBzKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU29sdmVyR3JvdXBzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBwaHlzaWNzIGhvb2tzIGVuYWJsZWQgZm9yIHRoaXMgY29sbGlkZXIuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29BY3RpdmVIb29rcyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0FjdGl2ZUhvb2tzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBjb2xsaXNpb24gdHlwZXMgZW5hYmxlZCBmb3IgdGhpcyBjb2xsaWRlci5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb0FjdGl2ZUNvbGxpc2lvblR5cGVzKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvQWN0aXZlQ29sbGlzaW9uVHlwZXModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGV2ZW50cyBlbmFibGVkIGZvciB0aGlzIGNvbGxpZGVyLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNvQWN0aXZlRXZlbnRzKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvQWN0aXZlRXZlbnRzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSB0b3RhbCBmb3JjZSBtYWduaXR1ZGUgYmV5b25kIHdoaWNoIGEgY29udGFjdCBmb3JjZSBldmVudCBjYW4gYmUgZW1pdHRlZC5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb0NvbnRhY3RGb3JjZUV2ZW50VGhyZXNob2xkKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvQ29udGFjdEZvcmNlRXZlbnRUaHJlc2hvbGQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHBvaW50XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIGNvQ29udGFpbnNQb2ludChoYW5kbGUsIHBvaW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwb2ludCwgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0NvbnRhaW5zUG9pbnQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgcG9pbnQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gY29sbGlkZXJWZWxcbiAgICAqIEBwYXJhbSB7UmF3U2hhcGV9IHNoYXBlMlxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHNoYXBlMlBvc1xuICAgICogQHBhcmFtIHtSYXdSb3RhdGlvbn0gc2hhcGUyUm90XG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGUyVmVsXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0X2Rpc3RhbmNlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VG9pXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0b3BfYXRfcGVuZXRyYXRpb25cbiAgICAqIEByZXR1cm5zIHtSYXdTaGFwZUNhc3RIaXQgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjb0Nhc3RTaGFwZShoYW5kbGUsIGNvbGxpZGVyVmVsLCBzaGFwZTIsIHNoYXBlMlBvcywgc2hhcGUyUm90LCBzaGFwZTJWZWwsIHRhcmdldF9kaXN0YW5jZSwgbWF4VG9pLCBzdG9wX2F0X3BlbmV0cmF0aW9uKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlclZlbCwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlMiwgUmF3U2hhcGUpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGUyUG9zLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGUyUm90LCBSYXdSb3RhdGlvbik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZTJWZWwsIFJhd1ZlY3Rvcik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29DYXN0U2hhcGUodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgY29sbGlkZXJWZWwuX193YmdfcHRyLCBzaGFwZTIuX193YmdfcHRyLCBzaGFwZTJQb3MuX193YmdfcHRyLCBzaGFwZTJSb3QuX193YmdfcHRyLCBzaGFwZTJWZWwuX193YmdfcHRyLCB0YXJnZXRfZGlzdGFuY2UsIG1heFRvaSwgc3RvcF9hdF9wZW5ldHJhdGlvbik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdTaGFwZUNhc3RIaXQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGNvbGxpZGVyMVZlbFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbGxpZGVyMmhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGNvbGxpZGVyMlZlbFxuICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldF9kaXN0YW5jZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heF90b2lcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RvcF9hdF9wZW5ldHJhdGlvblxuICAgICogQHJldHVybnMge1Jhd0NvbGxpZGVyU2hhcGVDYXN0SGl0IHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29DYXN0Q29sbGlkZXIoaGFuZGxlLCBjb2xsaWRlcjFWZWwsIGNvbGxpZGVyMmhhbmRsZSwgY29sbGlkZXIyVmVsLCB0YXJnZXRfZGlzdGFuY2UsIG1heF90b2ksIHN0b3BfYXRfcGVuZXRyYXRpb24pIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNvbGxpZGVyMVZlbCwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNvbGxpZGVyMlZlbCwgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0Nhc3RDb2xsaWRlcih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBjb2xsaWRlcjFWZWwuX193YmdfcHRyLCBjb2xsaWRlcjJoYW5kbGUsIGNvbGxpZGVyMlZlbC5fX3diZ19wdHIsIHRhcmdldF9kaXN0YW5jZSwgbWF4X3RvaSwgc3RvcF9hdF9wZW5ldHJhdGlvbik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdDb2xsaWRlclNoYXBlQ2FzdEhpdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd1NoYXBlfSBzaGFwZTJcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBzaGFwZVBvczJcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHNoYXBlUm90MlxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBjb0ludGVyc2VjdHNTaGFwZShoYW5kbGUsIHNoYXBlMiwgc2hhcGVQb3MyLCBzaGFwZVJvdDIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlMiwgUmF3U2hhcGUpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVQb3MyLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVSb3QyLCBSYXdSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29JbnRlcnNlY3RzU2hhcGUodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgc2hhcGUyLl9fd2JnX3B0ciwgc2hhcGVQb3MyLl9fd2JnX3B0ciwgc2hhcGVSb3QyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdTaGFwZX0gc2hhcGUyXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGVQb3MyXG4gICAgKiBAcGFyYW0ge1Jhd1JvdGF0aW9ufSBzaGFwZVJvdDJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVkaWN0aW9uXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGVDb250YWN0IHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29Db250YWN0U2hhcGUoaGFuZGxlLCBzaGFwZTIsIHNoYXBlUG9zMiwgc2hhcGVSb3QyLCBwcmVkaWN0aW9uKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZTIsIFJhd1NoYXBlKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlUG9zMiwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlUm90MiwgUmF3Um90YXRpb24pO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvQ29udGFjdFNoYXBlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIHNoYXBlMi5fX3diZ19wdHIsIHNoYXBlUG9zMi5fX3diZ19wdHIsIHNoYXBlUm90Mi5fX3diZ19wdHIsIHByZWRpY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3U2hhcGVDb250YWN0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xsaWRlcjJoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVkaWN0aW9uXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGVDb250YWN0IHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29Db250YWN0Q29sbGlkZXIoaGFuZGxlLCBjb2xsaWRlcjJoYW5kbGUsIHByZWRpY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0NvbnRhY3RDb2xsaWRlcih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBjb2xsaWRlcjJoYW5kbGUsIHByZWRpY3Rpb24pO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3U2hhcGVDb250YWN0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBwb2ludFxuICAgICogQHBhcmFtIHtib29sZWFufSBzb2xpZFxuICAgICogQHJldHVybnMge1Jhd1BvaW50UHJvamVjdGlvbn1cbiAgICAqL1xuICAgIGNvUHJvamVjdFBvaW50KGhhbmRsZSwgcG9pbnQsIHNvbGlkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwb2ludCwgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb1Byb2plY3RQb2ludCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBwb2ludC5fX3diZ19wdHIsIHNvbGlkKTtcbiAgICAgICAgcmV0dXJuIFJhd1BvaW50UHJvamVjdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcmF5T3JpZ1xuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHJheURpclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFRvaVxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBjb0ludGVyc2VjdHNSYXkoaGFuZGxlLCByYXlPcmlnLCByYXlEaXIsIG1heFRvaSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmF5T3JpZywgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJheURpciwgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0ludGVyc2VjdHNSYXkodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgcmF5T3JpZy5fX3diZ19wdHIsIHJheURpci5fX3diZ19wdHIsIG1heFRvaSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHJheU9yaWdcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSByYXlEaXJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhUb2lcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc29saWRcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb0Nhc3RSYXkoaGFuZGxlLCByYXlPcmlnLCByYXlEaXIsIG1heFRvaSwgc29saWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJheU9yaWcsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyYXlEaXIsIFJhd1ZlY3Rvcik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29DYXN0UmF5KHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIHJheU9yaWcuX193YmdfcHRyLCByYXlEaXIuX193YmdfcHRyLCBtYXhUb2ksIHNvbGlkKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcmF5T3JpZ1xuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHJheURpclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFRvaVxuICAgICogQHBhcmFtIHtib29sZWFufSBzb2xpZFxuICAgICogQHJldHVybnMge1Jhd1JheUludGVyc2VjdGlvbiB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIGNvQ2FzdFJheUFuZEdldE5vcm1hbChoYW5kbGUsIHJheU9yaWcsIHJheURpciwgbWF4VG9pLCBzb2xpZCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmF5T3JpZywgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJheURpciwgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb0Nhc3RSYXlBbmRHZXROb3JtYWwodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgcmF5T3JpZy5fX3diZ19wdHIsIHJheURpci5fX3diZ19wdHIsIG1heFRvaSwgc29saWQpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3UmF5SW50ZXJzZWN0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfc2Vuc29yXG4gICAgKi9cbiAgICBjb1NldFNlbnNvcihoYW5kbGUsIGlzX3NlbnNvcikge1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0U2Vuc29yKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGlzX3NlbnNvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc3RpdHV0aW9uXG4gICAgKi9cbiAgICBjb1NldFJlc3RpdHV0aW9uKGhhbmRsZSwgcmVzdGl0dXRpb24pIHtcbiAgICAgICAgd2FzbS5yYXdjb2xsaWRlcnNldF9jb1NldFJlc3RpdHV0aW9uKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIHJlc3RpdHV0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZnJpY3Rpb25cbiAgICAqL1xuICAgIGNvU2V0RnJpY3Rpb24oaGFuZGxlLCBmcmljdGlvbikge1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0RnJpY3Rpb24odGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgZnJpY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb0ZyaWN0aW9uQ29tYmluZVJ1bGUoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29GcmljdGlvbkNvbWJpbmVSdWxlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBydWxlXG4gICAgKi9cbiAgICBjb1NldEZyaWN0aW9uQ29tYmluZVJ1bGUoaGFuZGxlLCBydWxlKSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRGcmljdGlvbkNvbWJpbmVSdWxlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIHJ1bGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb1Jlc3RpdHV0aW9uQ29tYmluZVJ1bGUoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfY29SZXN0aXR1dGlvbkNvbWJpbmVSdWxlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBydWxlXG4gICAgKi9cbiAgICBjb1NldFJlc3RpdHV0aW9uQ29tYmluZVJ1bGUoaGFuZGxlLCBydWxlKSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRSZXN0aXR1dGlvbkNvbWJpbmVSdWxlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIHJ1bGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cHNcbiAgICAqL1xuICAgIGNvU2V0Q29sbGlzaW9uR3JvdXBzKGhhbmRsZSwgZ3JvdXBzKSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRDb2xsaXNpb25Hcm91cHModGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgZ3JvdXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBzXG4gICAgKi9cbiAgICBjb1NldFNvbHZlckdyb3VwcyhoYW5kbGUsIGdyb3Vwcykge1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0U29sdmVyR3JvdXBzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGdyb3Vwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhvb2tzXG4gICAgKi9cbiAgICBjb1NldEFjdGl2ZUhvb2tzKGhhbmRsZSwgaG9va3MpIHtcbiAgICAgICAgd2FzbS5yYXdjb2xsaWRlcnNldF9jb1NldEFjdGl2ZUhvb2tzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGhvb2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnRzXG4gICAgKi9cbiAgICBjb1NldEFjdGl2ZUV2ZW50cyhoYW5kbGUsIGV2ZW50cykge1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0QWN0aXZlRXZlbnRzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGV2ZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IHR5cGVzXG4gICAgKi9cbiAgICBjb1NldEFjdGl2ZUNvbGxpc2lvblR5cGVzKGhhbmRsZSwgdHlwZXMpIHtcbiAgICAgICAgd2FzbS5yYXdjb2xsaWRlcnNldF9jb1NldEFjdGl2ZUNvbGxpc2lvblR5cGVzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIHR5cGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd1NoYXBlfSBzaGFwZVxuICAgICovXG4gICAgY29TZXRTaGFwZShoYW5kbGUsIHNoYXBlKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZSwgUmF3U2hhcGUpO1xuICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvU2V0U2hhcGUodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgc2hhcGUuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4gICAgKi9cbiAgICBjb1NldENvbnRhY3RGb3JjZUV2ZW50VGhyZXNob2xkKGhhbmRsZSwgdGhyZXNob2xkKSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRDb250YWN0Rm9yY2VFdmVudFRocmVzaG9sZCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCB0aHJlc2hvbGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZW5zaXR5XG4gICAgKi9cbiAgICBjb1NldERlbnNpdHkoaGFuZGxlLCBkZW5zaXR5KSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXREZW5zaXR5KHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGRlbnNpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzXG4gICAgKi9cbiAgICBjb1NldE1hc3MoaGFuZGxlLCBtYXNzKSB7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRNYXNzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIG1hc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXNzXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gY2VudGVyT2ZNYXNzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcHJpbmNpcGFsQW5ndWxhckluZXJ0aWFcbiAgICAqL1xuICAgIGNvU2V0TWFzc1Byb3BlcnRpZXMoaGFuZGxlLCBtYXNzLCBjZW50ZXJPZk1hc3MsIHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjZW50ZXJPZk1hc3MsIFJhd1ZlY3Rvcik7XG4gICAgICAgIHdhc20ucmF3Y29sbGlkZXJzZXRfY29TZXRNYXNzUHJvcGVydGllcyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBtYXNzLCBjZW50ZXJPZk1hc3MuX193YmdfcHRyLCBwcmluY2lwYWxBbmd1bGFySW5lcnRpYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzZXRfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgbGVuKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2xlbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBjb250YWlucyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9jb250YWlucyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAqIEBwYXJhbSB7UmF3U2hhcGV9IHNoYXBlXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gdHJhbnNsYXRpb25cbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHJvdGF0aW9uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWFzc1Byb3BzTW9kZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc3NcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBjZW50ZXJPZk1hc3NcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmluY2lwYWxBbmd1bGFySW5lcnRpYVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbnNpdHlcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcmljdGlvblxuICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc3RpdHV0aW9uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZnJpY3Rpb25Db21iaW5lUnVsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc3RpdHV0aW9uQ29tYmluZVJ1bGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZW5zb3JcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xsaXNpb25Hcm91cHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBzb2x2ZXJHcm91cHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhY3RpdmVDb2xsaXNpb25UeXBlc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGFjdGl2ZUhvb2tzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYWN0aXZlRXZlbnRzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gY29udGFjdEZvcmNlRXZlbnRUaHJlc2hvbGRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb250YWN0U2tpblxuICAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXJlbnRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJlbnRcbiAgICAqIEBwYXJhbSB7UmF3UmlnaWRCb2R5U2V0fSBib2RpZXNcbiAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjcmVhdGVDb2xsaWRlcihlbmFibGVkLCBzaGFwZSwgdHJhbnNsYXRpb24sIHJvdGF0aW9uLCBtYXNzUHJvcHNNb2RlLCBtYXNzLCBjZW50ZXJPZk1hc3MsIHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhLCBkZW5zaXR5LCBmcmljdGlvbiwgcmVzdGl0dXRpb24sIGZyaWN0aW9uQ29tYmluZVJ1bGUsIHJlc3RpdHV0aW9uQ29tYmluZVJ1bGUsIGlzU2Vuc29yLCBjb2xsaXNpb25Hcm91cHMsIHNvbHZlckdyb3VwcywgYWN0aXZlQ29sbGlzaW9uVHlwZXMsIGFjdGl2ZUhvb2tzLCBhY3RpdmVFdmVudHMsIGNvbnRhY3RGb3JjZUV2ZW50VGhyZXNob2xkLCBjb250YWN0U2tpbiwgaGFzUGFyZW50LCBwYXJlbnQsIGJvZGllcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGUsIFJhd1NoYXBlKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyh0cmFuc2xhdGlvbiwgUmF3VmVjdG9yKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyb3RhdGlvbiwgUmF3Um90YXRpb24pO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGNlbnRlck9mTWFzcywgUmF3VmVjdG9yKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhib2RpZXMsIFJhd1JpZ2lkQm9keVNldCk7XG4gICAgICAgICAgICB3YXNtLnJhd2NvbGxpZGVyc2V0X2NyZWF0ZUNvbGxpZGVyKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGVuYWJsZWQsIHNoYXBlLl9fd2JnX3B0ciwgdHJhbnNsYXRpb24uX193YmdfcHRyLCByb3RhdGlvbi5fX3diZ19wdHIsIG1hc3NQcm9wc01vZGUsIG1hc3MsIGNlbnRlck9mTWFzcy5fX3diZ19wdHIsIHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhLCBkZW5zaXR5LCBmcmljdGlvbiwgcmVzdGl0dXRpb24sIGZyaWN0aW9uQ29tYmluZVJ1bGUsIHJlc3RpdHV0aW9uQ29tYmluZVJ1bGUsIGlzU2Vuc29yLCBjb2xsaXNpb25Hcm91cHMsIHNvbHZlckdyb3VwcywgYWN0aXZlQ29sbGlzaW9uVHlwZXMsIGFjdGl2ZUhvb2tzLCBhY3RpdmVFdmVudHMsIGNvbnRhY3RGb3JjZUV2ZW50VGhyZXNob2xkLCBjb250YWN0U2tpbiwgaGFzUGFyZW50LCBwYXJlbnQsIGJvZGllcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RmxvYXQ2NE1lbW9yeTAoKVtyZXRwdHIgLyA4ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gcjAgPT09IDAgPyB1bmRlZmluZWQgOiByMjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZW1vdmVzIGEgY29sbGlkZXIgZnJvbSB0aGlzIHNldCBhbmQgd2FrZS11cCB0aGUgcmlnaWQtYm9keSBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7UmF3SXNsYW5kTWFuYWdlcn0gaXNsYW5kc1xuICAgICogQHBhcmFtIHtSYXdSaWdpZEJvZHlTZXR9IGJvZGllc1xuICAgICogQHBhcmFtIHtib29sZWFufSB3YWtlVXBcbiAgICAqL1xuICAgIHJlbW92ZShoYW5kbGUsIGlzbGFuZHMsIGJvZGllcywgd2FrZVVwKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhpc2xhbmRzLCBSYXdJc2xhbmRNYW5hZ2VyKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGJvZGllcywgUmF3UmlnaWRCb2R5U2V0KTtcbiAgICAgICAgd2FzbS5yYXdjb2xsaWRlcnNldF9yZW1vdmUodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgaXNsYW5kcy5fX3diZ19wdHIsIGJvZGllcy5fX3diZ19wdHIsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQ2hlY2tzIGlmIGEgY29sbGlkZXIgd2l0aCB0aGUgZ2l2ZW4gaW50ZWdlciBoYW5kbGUgZXhpc3RzLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBpc0hhbmRsZVZhbGlkKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2V0X2NvbnRhaW5zKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gdGhlIGludGVnZXIgaGFuZGxlIG9mIGVhY2ggY29sbGlkZXIgbWFuYWdlZCBieSB0aGlzIGNvbGxpZGVyIHNldC5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYGYoaGFuZGxlKWA6IHRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBjb2xsaWRlciBtYW5hZ2VkIGJ5IHRoaXMgY29sbGlkZXIgc2V0LiBDYWxsZWQgYXMgYGYoaGFuZGxlKWAuXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgKi9cbiAgICBmb3JFYWNoQ29sbGlkZXJIYW5kbGUoZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2FzbS5yYXdjb2xsaWRlcnNldF9mb3JFYWNoQ29sbGlkZXJIYW5kbGUodGhpcy5fX3diZ19wdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGYpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgUmF3Q29sbGlkZXJTaGFwZUNhc3RIaXRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3Y29sbGlkZXJzaGFwZWNhc3RoaXRfZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdDb2xsaWRlclNoYXBlQ2FzdEhpdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3Q29sbGlkZXJTaGFwZUNhc3RIaXQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3Q29sbGlkZXJTaGFwZUNhc3RIaXRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3Q29sbGlkZXJTaGFwZUNhc3RIaXRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd2NvbGxpZGVyc2hhcGVjYXN0aGl0X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29sbGlkZXJIYW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzaGFwZWNhc3RoaXRfY29sbGlkZXJIYW5kbGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICB0aW1lX29mX2ltcGFjdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNoYXBlY2FzdGhpdF90aW1lX29mX2ltcGFjdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHdpdG5lc3MxKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2hhcGVjYXN0aGl0X3dpdG5lc3MxKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgd2l0bmVzczIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzaGFwZWNhc3RoaXRfd2l0bmVzczIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBub3JtYWwxKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2hhcGVjYXN0aGl0X25vcm1hbDEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBub3JtYWwyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2hhcGVjYXN0aGl0X25vcm1hbDIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgUmF3Q29udGFjdEZvcmNlRXZlbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3Y29udGFjdGZvcmNlZXZlbnRfZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdDb250YWN0Rm9yY2VFdmVudCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3Q29udGFjdEZvcmNlRXZlbnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3Q29udGFjdEZvcmNlRXZlbnRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3Q29udGFjdEZvcmNlRXZlbnRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd2NvbnRhY3Rmb3JjZWV2ZW50X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgZmlyc3QgY29sbGlkZXIgaW52b2x2ZWQgaW4gdGhlIGNvbnRhY3QuXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29sbGlkZXIxKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2hhcGVjYXN0aGl0X2NvbGxpZGVySGFuZGxlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgc2Vjb25kIGNvbGxpZGVyIGludm9sdmVkIGluIHRoZSBjb250YWN0LlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNvbGxpZGVyMigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0Zm9yY2VldmVudF9jb2xsaWRlcjIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBzdW0gb2YgYWxsIHRoZSBmb3JjZXMgYmV0d2VlbiB0aGUgdHdvIGNvbGxpZGVycy5cbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICB0b3RhbF9mb3JjZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0Zm9yY2VldmVudF90b3RhbF9mb3JjZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHN1bSBvZiB0aGUgbWFnbml0dWRlcyBvZiBlYWNoIGZvcmNlIGJldHdlZW4gdGhlIHR3byBjb2xsaWRlcnMuXG4gICAgKlxuICAgICogTm90ZSB0aGF0IHRoaXMgaXMgKipub3QqKiB0aGUgc2FtZSBhcyB0aGUgbWFnbml0dWRlIG9mIGBzZWxmLnRvdGFsX2ZvcmNlYC5cbiAgICAqIEhlcmUgd2UgYXJlIHN1bW1pbmcgdGhlIG1hZ25pdHVkZSBvZiBhbGwgdGhlIGZvcmNlcywgaW5zdGVhZCBvZiB0YWtpbmdcbiAgICAqIHRoZSBtYWduaXR1ZGUgb2YgdGhlaXIgc3VtLlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIHRvdGFsX2ZvcmNlX21hZ25pdHVkZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0Zm9yY2VldmVudF90b3RhbF9mb3JjZV9tYWduaXR1ZGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSB3b3JsZC1zcGFjZSAodW5pdCkgZGlyZWN0aW9uIG9mIHRoZSBmb3JjZSB3aXRoIHN0cm9uZ2VzdCBtYWduaXR1ZGUuXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgbWF4X2ZvcmNlX2RpcmVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjaGFyYWN0ZXJjb2xsaXNpb25fdHJhbnNsYXRpb25EZWx0YUFwcGxpZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdlc3QgZm9yY2UgYXQgYSBjb250YWN0IHBvaW50IG9mIHRoaXMgY29udGFjdCBwYWlyLlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIG1heF9mb3JjZV9tYWduaXR1ZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdGZvcmNlZXZlbnRfbWF4X2ZvcmNlX21hZ25pdHVkZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuXG5jb25zdCBSYXdDb250YWN0TWFuaWZvbGRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3Y29udGFjdG1hbmlmb2xkX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3Q29udGFjdE1hbmlmb2xkIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdDb250YWN0TWFuaWZvbGQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3Q29udGFjdE1hbmlmb2xkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd0NvbnRhY3RNYW5pZm9sZEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3Y29udGFjdG1hbmlmb2xkX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgbm9ybWFsKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbnRhY3RtYW5pZm9sZF9ub3JtYWwodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBsb2NhbF9uMSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0bWFuaWZvbGRfbG9jYWxfbjEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBsb2NhbF9uMigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0bWFuaWZvbGRfbG9jYWxfbjIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBzdWJzaGFwZTEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdG1hbmlmb2xkX3N1YnNoYXBlMSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIHN1YnNoYXBlMigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0bWFuaWZvbGRfc3Vic2hhcGUyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgbnVtX2NvbnRhY3RzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbnRhY3RtYW5pZm9sZF9udW1fY29udGFjdHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29udGFjdF9sb2NhbF9wMShpKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfbG9jYWxfcDEodGhpcy5fX3diZ19wdHIsIGkpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29udGFjdF9sb2NhbF9wMihpKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfbG9jYWxfcDIodGhpcy5fX3diZ19wdHIsIGkpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29udGFjdF9kaXN0KGkpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF9kaXN0KHRoaXMuX193YmdfcHRyLCBpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNvbnRhY3RfZmlkMShpKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfZmlkMSh0aGlzLl9fd2JnX3B0ciwgaSk7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb250YWN0X2ZpZDIoaSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2ZpZDIodGhpcy5fX3diZ19wdHIsIGkpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29udGFjdF9pbXB1bHNlKGkpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF9pbXB1bHNlKHRoaXMuX193YmdfcHRyLCBpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNvbnRhY3RfdGFuZ2VudF9pbXB1bHNlKGkpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF90YW5nZW50X2ltcHVsc2UodGhpcy5fX3diZ19wdHIsIGkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBudW1fc29sdmVyX2NvbnRhY3RzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbnRhY3RtYW5pZm9sZF9udW1fc29sdmVyX2NvbnRhY3RzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaVxuICAgICogQHJldHVybnMge1Jhd1ZlY3RvciB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHNvbHZlcl9jb250YWN0X3BvaW50KGkpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0bWFuaWZvbGRfc29sdmVyX2NvbnRhY3RfcG9pbnQodGhpcy5fX3diZ19wdHIsIGkpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgc29sdmVyX2NvbnRhY3RfZGlzdChpKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdG1hbmlmb2xkX3NvbHZlcl9jb250YWN0X2Rpc3QodGhpcy5fX3diZ19wdHIsIGkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgc29sdmVyX2NvbnRhY3RfZnJpY3Rpb24oaSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbnRhY3RtYW5pZm9sZF9zb2x2ZXJfY29udGFjdF9mcmljdGlvbih0aGlzLl9fd2JnX3B0ciwgaSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBzb2x2ZXJfY29udGFjdF9yZXN0aXR1dGlvbihpKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdG1hbmlmb2xkX3NvbHZlcl9jb250YWN0X3Jlc3RpdHV0aW9uKHRoaXMuX193YmdfcHRyLCBpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaVxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHNvbHZlcl9jb250YWN0X3RhbmdlbnRfdmVsb2NpdHkoaSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbnRhY3RtYW5pZm9sZF9zb2x2ZXJfY29udGFjdF90YW5nZW50X3ZlbG9jaXR5KHRoaXMuX193YmdfcHRyLCBpKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IFJhd0NvbnRhY3RQYWlyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Jhd2NvbnRhY3RwYWlyX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3Q29udGFjdFBhaXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJhd0NvbnRhY3RQYWlyLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFJhd0NvbnRhY3RQYWlyRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd0NvbnRhY3RQYWlyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdjb250YWN0cGFpcl9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNvbGxpZGVyMSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0cGFpcl9jb2xsaWRlcjEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb2xsaWRlcjIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdHBhaXJfY29sbGlkZXIyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgbnVtQ29udGFjdE1hbmlmb2xkcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0cGFpcl9udW1Db250YWN0TWFuaWZvbGRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaVxuICAgICogQHJldHVybnMge1Jhd0NvbnRhY3RNYW5pZm9sZCB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIGNvbnRhY3RNYW5pZm9sZChpKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29udGFjdHBhaXJfY29udGFjdE1hbmlmb2xkKHRoaXMuX193YmdfcHRyLCBpKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd0NvbnRhY3RNYW5pZm9sZC5fX3dyYXAocmV0KTtcbiAgICB9XG59XG5cbmNvbnN0IFJhd0RlYnVnUmVuZGVyUGlwZWxpbmVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3ZGVidWdyZW5kZXJwaXBlbGluZV9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd0RlYnVnUmVuZGVyUGlwZWxpbmUge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdEZWJ1Z1JlbmRlclBpcGVsaW5lRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdkZWJ1Z3JlbmRlcnBpcGVsaW5lX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdkZWJ1Z3JlbmRlcnBpcGVsaW5lX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX1cbiAgICAqL1xuICAgIHZlcnRpY2VzKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2RlYnVncmVuZGVycGlwZWxpbmVfdmVydGljZXModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9XG4gICAgKi9cbiAgICBjb2xvcnMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3ZGVidWdyZW5kZXJwaXBlbGluZV9jb2xvcnModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gdGFrZU9iamVjdChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UmF3UmlnaWRCb2R5U2V0fSBib2RpZXNcbiAgICAqIEBwYXJhbSB7UmF3Q29sbGlkZXJTZXR9IGNvbGxpZGVyc1xuICAgICogQHBhcmFtIHtSYXdJbXB1bHNlSm9pbnRTZXR9IGltcHVsc2Vfam9pbnRzXG4gICAgKiBAcGFyYW0ge1Jhd011bHRpYm9keUpvaW50U2V0fSBtdWx0aWJvZHlfam9pbnRzXG4gICAgKiBAcGFyYW0ge1Jhd05hcnJvd1BoYXNlfSBuYXJyb3dfcGhhc2VcbiAgICAqL1xuICAgIHJlbmRlcihib2RpZXMsIGNvbGxpZGVycywgaW1wdWxzZV9qb2ludHMsIG11bHRpYm9keV9qb2ludHMsIG5hcnJvd19waGFzZSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYm9kaWVzLCBSYXdSaWdpZEJvZHlTZXQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY29sbGlkZXJzLCBSYXdDb2xsaWRlclNldCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhpbXB1bHNlX2pvaW50cywgUmF3SW1wdWxzZUpvaW50U2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG11bHRpYm9keV9qb2ludHMsIFJhd011bHRpYm9keUpvaW50U2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5hcnJvd19waGFzZSwgUmF3TmFycm93UGhhc2UpO1xuICAgICAgICB3YXNtLnJhd2RlYnVncmVuZGVycGlwZWxpbmVfcmVuZGVyKHRoaXMuX193YmdfcHRyLCBib2RpZXMuX193YmdfcHRyLCBjb2xsaWRlcnMuX193YmdfcHRyLCBpbXB1bHNlX2pvaW50cy5fX3diZ19wdHIsIG11bHRpYm9keV9qb2ludHMuX193YmdfcHRyLCBuYXJyb3dfcGhhc2UuX193YmdfcHRyKTtcbiAgICB9XG59XG5cbmNvbnN0IFJhd0Rlc2VyaWFsaXplZFdvcmxkRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Jhd2Rlc2VyaWFsaXplZHdvcmxkX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3RGVzZXJpYWxpemVkV29ybGQge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJhd0Rlc2VyaWFsaXplZFdvcmxkLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFJhd0Rlc2VyaWFsaXplZFdvcmxkRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd0Rlc2VyaWFsaXplZFdvcmxkRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdkZXNlcmlhbGl6ZWR3b3JsZF9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1ZlY3RvciB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHRha2VHcmF2aXR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VHcmF2aXR5KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7UmF3SW50ZWdyYXRpb25QYXJhbWV0ZXJzIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgdGFrZUludGVncmF0aW9uUGFyYW1ldGVycygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlSW50ZWdyYXRpb25QYXJhbWV0ZXJzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd0ludGVncmF0aW9uUGFyYW1ldGVycy5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7UmF3SXNsYW5kTWFuYWdlciB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHRha2VJc2xhbmRNYW5hZ2VyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VJc2xhbmRNYW5hZ2VyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd0lzbGFuZE1hbmFnZXIuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd0Jyb2FkUGhhc2UgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICB0YWtlQnJvYWRQaGFzZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlQnJvYWRQaGFzZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdCcm9hZFBoYXNlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdOYXJyb3dQaGFzZSB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHRha2VOYXJyb3dQaGFzZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlTmFycm93UGhhc2UodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3TmFycm93UGhhc2UuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1JpZ2lkQm9keVNldCB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHRha2VCb2RpZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUJvZGllcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdSaWdpZEJvZHlTZXQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd0NvbGxpZGVyU2V0IHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgdGFrZUNvbGxpZGVycygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlQ29sbGlkZXJzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd0NvbGxpZGVyU2V0Ll9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdJbXB1bHNlSm9pbnRTZXQgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICB0YWtlSW1wdWxzZUpvaW50cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlSW1wdWxzZUpvaW50cyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdJbXB1bHNlSm9pbnRTZXQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd011bHRpYm9keUpvaW50U2V0IHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgdGFrZU11bHRpYm9keUpvaW50cygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlTXVsdGlib2R5Sm9pbnRzKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd011bHRpYm9keUpvaW50U2V0Ll9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgUmF3RXZlbnRRdWV1ZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdldmVudHF1ZXVlX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiogQSBzdHJ1Y3R1cmUgcmVzcG9uc2libGUgZm9yIGNvbGxlY3RpbmcgZXZlbnRzIGdlbmVyYXRlZFxuKiBieSB0aGUgcGh5c2ljcyBlbmdpbmUuXG4qL1xuZXhwb3J0IGNsYXNzIFJhd0V2ZW50UXVldWUge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdFdmVudFF1ZXVlRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdldmVudHF1ZXVlX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgbmV3IGV2ZW50IGNvbGxlY3Rvci5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYGF1dG9EcmFpbmA6IHNldHRpbmcgdGhpcyB0byBgdHJ1ZWAgaXMgc3Ryb25nbHkgcmVjb21tZW5kZWQuIElmIHRydWUsIHRoZSBjb2xsZWN0b3Igd2lsbFxuICAgICogYmUgYXV0b21hdGljYWxseSBkcmFpbmVkIGJlZm9yZSBlYWNoIGB3b3JsZC5zdGVwKGNvbGxlY3RvcilgLiBJZiBmYWxzZSwgdGhlIGNvbGxlY3RvciB3aWxsXG4gICAgKiBrZWVwIGFsbCBldmVudHMgaW4gbWVtb3J5IHVubGVzcyBpdCBpcyBtYW51YWxseSBkcmFpbmVkL2NsZWFyZWQ7IHRoaXMgbWF5IGxlYWQgdG8gdW5ib3VuZGVkIHVzZSBvZlxuICAgICogUkFNIGlmIG5vIGRyYWluIGlzIHBlcmZvcm1lZC5cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b0RyYWluXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRvRHJhaW4pIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdldmVudHF1ZXVlX25ldyhhdXRvRHJhaW4pO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gamF2YXNjcmlwdCBjbG9zdXJlIG9uIGVhY2ggY29sbGlzaW9uIGV2ZW50IG9mIHRoaXMgY29sbGVjdG9yLCB0aGVuIGNsZWFyXG4gICAgKiB0aGUgaW50ZXJuYWwgY29sbGlzaW9uIGV2ZW50IGJ1ZmZlci5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYGYoaGFuZGxlMSwgaGFuZGxlMiwgc3RhcnRlZClgOiAgSmF2YVNjcmlwdCBjbG9zdXJlIGFwcGxpZWQgdG8gZWFjaCBjb2xsaXNpb24gZXZlbnQuIFRoZVxuICAgICogY2xvc3VyZSBzaG91bGQgdGFrZSB0aHJlZSBhcmd1bWVudHM6IHR3byBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIGhhbmRsZXMgb2YgdGhlIGNvbGxpZGVyc1xuICAgICogaW52b2x2ZWQgaW4gdGhlIGNvbGxpc2lvbiwgYW5kIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBjb2xsaXNpb24gc3RhcnRlZCAodHJ1ZSkgb3Igc3RvcHBlZFxuICAgICogKGZhbHNlKS5cbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAqL1xuICAgIGRyYWluQ29sbGlzaW9uRXZlbnRzKGYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdhc20ucmF3ZXZlbnRxdWV1ZV9kcmFpbkNvbGxpc2lvbkV2ZW50cyh0aGlzLl9fd2JnX3B0ciwgYWRkQm9ycm93ZWRPYmplY3QoZikpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICovXG4gICAgZHJhaW5Db250YWN0Rm9yY2VFdmVudHMoZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2FzbS5yYXdldmVudHF1ZXVlX2RyYWluQ29udGFjdEZvcmNlRXZlbnRzKHRoaXMuX193YmdfcHRyLCBhZGRCb3Jyb3dlZE9iamVjdChmKSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZW1vdmVzIGFsbCBldmVudHMgY29udGFpbmVkIGJ5IHRoaXMgY29sbGVjdG9yLlxuICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHdhc20ucmF3ZXZlbnRxdWV1ZV9jbGVhcih0aGlzLl9fd2JnX3B0cik7XG4gICAgfVxufVxuXG5jb25zdCBSYXdHZW5lcmljSm9pbnRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3Z2VuZXJpY2pvaW50X2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3R2VuZXJpY0pvaW50IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdHZW5lcmljSm9pbnQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3R2VuZXJpY0pvaW50RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd0dlbmVyaWNKb2ludEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3Z2VuZXJpY2pvaW50X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcmVzdF9sZW5ndGhcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGlmZm5lc3NcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYW1waW5nXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gYW5jaG9yMVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGFuY2hvcjJcbiAgICAqIEByZXR1cm5zIHtSYXdHZW5lcmljSm9pbnR9XG4gICAgKi9cbiAgICBzdGF0aWMgc3ByaW5nKHJlc3RfbGVuZ3RoLCBzdGlmZm5lc3MsIGRhbXBpbmcsIGFuY2hvcjEsIGFuY2hvcjIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFuY2hvcjEsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhbmNob3IyLCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2dlbmVyaWNqb2ludF9zcHJpbmcocmVzdF9sZW5ndGgsIHN0aWZmbmVzcywgZGFtcGluZywgYW5jaG9yMS5fX3diZ19wdHIsIGFuY2hvcjIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd0dlbmVyaWNKb2ludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gYW5jaG9yMVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGFuY2hvcjJcbiAgICAqIEByZXR1cm5zIHtSYXdHZW5lcmljSm9pbnR9XG4gICAgKi9cbiAgICBzdGF0aWMgcm9wZShsZW5ndGgsIGFuY2hvcjEsIGFuY2hvcjIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFuY2hvcjEsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhbmNob3IyLCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2dlbmVyaWNqb2ludF9yb3BlKGxlbmd0aCwgYW5jaG9yMS5fX3diZ19wdHIsIGFuY2hvcjIuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd0dlbmVyaWNKb2ludC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDcmVhdGVzIGEgbmV3IGpvaW50IGRlc2NyaXB0b3IgdGhhdCBidWlsZHMgYSBQcmlzbWF0aWMgam9pbnQuXG4gICAgKlxuICAgICogQSBwcmlzbWF0aWMgam9pbnQgcmVtb3ZlcyBhbGwgdGhlIGRlZ3JlZXMgb2YgZnJlZWRvbSBiZXR3ZWVuIHRoZVxuICAgICogYWZmZWN0ZWQgYm9kaWVzLCBleGNlcHQgZm9yIHRoZSB0cmFuc2xhdGlvbiBhbG9uZyBvbmUgYXhpcy5cbiAgICAqXG4gICAgKiBSZXR1cm5zIGBOb25lYCBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIGF4ZXMgY2Fubm90IGJlIG5vcm1hbGl6ZWQuXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gYW5jaG9yMVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGFuY2hvcjJcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBheGlzXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpbWl0c0VuYWJsZWRcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdHNNaW5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdHNNYXhcbiAgICAqIEByZXR1cm5zIHtSYXdHZW5lcmljSm9pbnQgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBzdGF0aWMgcHJpc21hdGljKGFuY2hvcjEsIGFuY2hvcjIsIGF4aXMsIGxpbWl0c0VuYWJsZWQsIGxpbWl0c01pbiwgbGltaXRzTWF4KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhbmNob3IxLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYW5jaG9yMiwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGF4aXMsIFJhd1ZlY3Rvcik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Z2VuZXJpY2pvaW50X3ByaXNtYXRpYyhhbmNob3IxLl9fd2JnX3B0ciwgYW5jaG9yMi5fX3diZ19wdHIsIGF4aXMuX193YmdfcHRyLCBsaW1pdHNFbmFibGVkLCBsaW1pdHNNaW4sIGxpbWl0c01heCk7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdHZW5lcmljSm9pbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIG5ldyBqb2ludCBkZXNjcmlwdG9yIHRoYXQgYnVpbGRzIGEgRml4ZWQgam9pbnQuXG4gICAgKlxuICAgICogQSBmaXhlZCBqb2ludCByZW1vdmVzIGFsbCB0aGUgZGVncmVlcyBvZiBmcmVlZG9tIGJldHdlZW4gdGhlIGFmZmVjdGVkIGJvZGllcy5cbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBhbmNob3IxXG4gICAgKiBAcGFyYW0ge1Jhd1JvdGF0aW9ufSBheGVzMVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGFuY2hvcjJcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IGF4ZXMyXG4gICAgKiBAcmV0dXJucyB7UmF3R2VuZXJpY0pvaW50fVxuICAgICovXG4gICAgc3RhdGljIGZpeGVkKGFuY2hvcjEsIGF4ZXMxLCBhbmNob3IyLCBheGVzMikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYW5jaG9yMSwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGF4ZXMxLCBSYXdSb3RhdGlvbik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhbmNob3IyLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYXhlczIsIFJhd1JvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdnZW5lcmljam9pbnRfZml4ZWQoYW5jaG9yMS5fX3diZ19wdHIsIGF4ZXMxLl9fd2JnX3B0ciwgYW5jaG9yMi5fX3diZ19wdHIsIGF4ZXMyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSYXdHZW5lcmljSm9pbnQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IGpvaW50IGRlc2NyaXB0b3IgdGhhdCBidWlsZHMgUmV2b2x1dGUgam9pbnRzLlxuICAgICpcbiAgICAqIEEgcmV2b2x1dGUgam9pbnQgcmVtb3ZlcyBhbGwgZGVncmVlcyBvZiBmcmVlZG9tIGJldHdlZW4gdGhlIGFmZmVjdGVkXG4gICAgKiBib2RpZXMgZXhjZXB0IGZvciB0aGUgcm90YXRpb24uXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gYW5jaG9yMVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGFuY2hvcjJcbiAgICAqIEByZXR1cm5zIHtSYXdHZW5lcmljSm9pbnQgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBzdGF0aWMgcmV2b2x1dGUoYW5jaG9yMSwgYW5jaG9yMikge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoYW5jaG9yMSwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFuY2hvcjIsIFJhd1ZlY3Rvcik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Z2VuZXJpY2pvaW50X3Jldm9sdXRlKGFuY2hvcjEuX193YmdfcHRyLCBhbmNob3IyLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdHZW5lcmljSm9pbnQuX193cmFwKHJldCk7XG4gICAgfVxufVxuXG5jb25zdCBSYXdJbXB1bHNlSm9pbnRTZXRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3aW1wdWxzZWpvaW50c2V0X2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3SW1wdWxzZUpvaW50U2V0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdJbXB1bHNlSm9pbnRTZXQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3SW1wdWxzZUpvaW50U2V0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd0ltcHVsc2VKb2ludFNldEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3aW1wdWxzZWpvaW50c2V0X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgdHlwZSBvZiB0aGlzIGpvaW50LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge1Jhd0pvaW50VHlwZX1cbiAgICAqL1xuICAgIGpvaW50VHlwZShoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRUeXBlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSB1bmlxdWUgaW50ZWdlciBpZGVudGlmaWVyIG9mIHRoZSBmaXJzdCByaWdpZC1ib2R5IHRoaXMgam9pbnQgaXQgYXR0YWNoZWQgdG8uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgam9pbnRCb2R5SGFuZGxlMShoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRCb2R5SGFuZGxlMSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgdW5pcXVlIGludGVnZXIgaWRlbnRpZmllciBvZiB0aGUgc2Vjb25kIHJpZ2lkLWJvZHkgdGhpcyBqb2ludCBpcyBhdHRhY2hlZCB0by5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBqb2ludEJvZHlIYW5kbGUyKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2ltcHVsc2Vqb2ludHNldF9qb2ludEJvZHlIYW5kbGUyKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBhbmd1bGFyIHBhcnQgb2YgdGhlIGpvaW504oCZcyBsb2NhbCBmcmFtZSByZWxhdGl2ZSB0byB0aGUgZmlyc3QgcmlnaWQtYm9keSBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtSYXdSb3RhdGlvbn1cbiAgICAqL1xuICAgIGpvaW50RnJhbWVYMShoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRGcmFtZVgxKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gUmF3Um90YXRpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGFuZ3VsYXIgcGFydCBvZiB0aGUgam9pbnTigJlzIGxvY2FsIGZyYW1lIHJlbGF0aXZlIHRvIHRoZSBzZWNvbmQgcmlnaWQtYm9keSBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtSYXdSb3RhdGlvbn1cbiAgICAqL1xuICAgIGpvaW50RnJhbWVYMihoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRGcmFtZVgyKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gUmF3Um90YXRpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBhbmNob3Igb2YgdGhpcyBqb2ludC5cbiAgICAqXG4gICAgKiBUaGUgZmlyc3QgYW5jaG9yIGdpdmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRzIGFwcGxpY2F0aW9uIHBvaW50IG9uIHRoZVxuICAgICogbG9jYWwgZnJhbWUgb2YgdGhlIGZpcnN0IHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgam9pbnRBbmNob3IxKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2ltcHVsc2Vqb2ludHNldF9qb2ludEFuY2hvcjEodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgYW5jaG9yIG9mIHRoaXMgam9pbnQuXG4gICAgKlxuICAgICogVGhlIHNlY29uZCBhbmNob3IgZ2l2ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludHMgYXBwbGljYXRpb24gcG9pbnQgb24gdGhlXG4gICAgKiBsb2NhbCBmcmFtZSBvZiB0aGUgc2Vjb25kIHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgam9pbnRBbmNob3IyKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2ltcHVsc2Vqb2ludHNldF9qb2ludEFuY2hvcjIodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGxvY2FsIGFuY2hvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IG5ld1Bvc1xuICAgICovXG4gICAgam9pbnRTZXRBbmNob3IxKGhhbmRsZSwgbmV3UG9zKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhuZXdQb3MsIFJhd1ZlY3Rvcik7XG4gICAgICAgIHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2pvaW50U2V0QW5jaG9yMSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBuZXdQb3MuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIGxvY2FsIGFuY2hvclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IG5ld1Bvc1xuICAgICovXG4gICAgam9pbnRTZXRBbmNob3IyKGhhbmRsZSwgbmV3UG9zKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhuZXdQb3MsIFJhd1ZlY3Rvcik7XG4gICAgICAgIHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2pvaW50U2V0QW5jaG9yMih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBuZXdQb3MuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBcmUgY29udGFjdHMgYmV0d2VlbiB0aGUgcmlnaWQtYm9kaWVzIGF0dGFjaGVkIGJ5IHRoaXMgam9pbnQgZW5hYmxlZD9cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgam9pbnRDb250YWN0c0VuYWJsZWQoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2pvaW50Q29udGFjdHNFbmFibGVkKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHMgd2hldGhlciBjb250YWN0cyBhcmUgZW5hYmxlZCBiZXR3ZWVuIHRoZSByaWdpZC1ib2RpZXMgYXR0YWNoZWQgYnkgdGhpcyBqb2ludC5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICovXG4gICAgam9pbnRTZXRDb250YWN0c0VuYWJsZWQoaGFuZGxlLCBlbmFibGVkKSB7XG4gICAgICAgIHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2pvaW50U2V0Q29udGFjdHNFbmFibGVkKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGVuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFyZSB0aGUgbGltaXRzIGZvciB0aGlzIGpvaW50IGVuYWJsZWQ/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd0pvaW50QXhpc30gYXhpc1xuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBqb2ludExpbWl0c0VuYWJsZWQoaGFuZGxlLCBheGlzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2pvaW50TGltaXRzRW5hYmxlZCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXR1cm4gdGhlIGxvd2VyIGxpbWl0IGFsb25nIHRoZSBnaXZlbiBqb2ludCBheGlzLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdKb2ludEF4aXN9IGF4aXNcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBqb2ludExpbWl0c01pbihoYW5kbGUsIGF4aXMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRMaW1pdHNNaW4odGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogSWYgdGhpcyBpcyBhIHByaXNtYXRpYyBqb2ludCwgcmV0dXJucyBpdHMgdXBwZXIgbGltaXQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd0pvaW50QXhpc30gYXhpc1xuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGpvaW50TGltaXRzTWF4KGhhbmRsZSwgYXhpcykge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2ltcHVsc2Vqb2ludHNldF9qb2ludExpbWl0c01heCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBFbmFibGVzIGFuZCBzZXRzIHRoZSBqb2ludCBsaW1pdHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7UmF3Sm9pbnRBeGlzfSBheGlzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgKi9cbiAgICBqb2ludFNldExpbWl0cyhoYW5kbGUsIGF4aXMsIG1pbiwgbWF4KSB7XG4gICAgICAgIHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2pvaW50U2V0TGltaXRzKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGF4aXMsIG1pbiwgbWF4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd0pvaW50QXhpc30gYXhpc1xuICAgICogQHBhcmFtIHtSYXdNb3Rvck1vZGVsfSBtb2RlbFxuICAgICovXG4gICAgam9pbnRDb25maWd1cmVNb3Rvck1vZGVsKGhhbmRsZSwgYXhpcywgbW9kZWwpIHtcbiAgICAgICAgd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRDb25maWd1cmVNb3Rvck1vZGVsKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGF4aXMsIG1vZGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd0pvaW50QXhpc30gYXhpc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFZlbFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvclxuICAgICovXG4gICAgam9pbnRDb25maWd1cmVNb3RvclZlbG9jaXR5KGhhbmRsZSwgYXhpcywgdGFyZ2V0VmVsLCBmYWN0b3IpIHtcbiAgICAgICAgd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfam9pbnRDb25maWd1cmVNb3RvclZlbG9jaXR5KHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGF4aXMsIHRhcmdldFZlbCwgZmFjdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd0pvaW50QXhpc30gYXhpc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFBvc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IHN0aWZmbmVzc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGRhbXBpbmdcbiAgICAqL1xuICAgIGpvaW50Q29uZmlndXJlTW90b3JQb3NpdGlvbihoYW5kbGUsIGF4aXMsIHRhcmdldFBvcywgc3RpZmZuZXNzLCBkYW1waW5nKSB7XG4gICAgICAgIHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2pvaW50Q29uZmlndXJlTW90b3JQb3NpdGlvbih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBheGlzLCB0YXJnZXRQb3MsIHN0aWZmbmVzcywgZGFtcGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtSYXdKb2ludEF4aXN9IGF4aXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRQb3NcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRWZWxcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGlmZm5lc3NcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkYW1waW5nXG4gICAgKi9cbiAgICBqb2ludENvbmZpZ3VyZU1vdG9yKGhhbmRsZSwgYXhpcywgdGFyZ2V0UG9zLCB0YXJnZXRWZWwsIHN0aWZmbmVzcywgZGFtcGluZykge1xuICAgICAgICB3YXNtLnJhd2ltcHVsc2Vqb2ludHNldF9qb2ludENvbmZpZ3VyZU1vdG9yKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGF4aXMsIHRhcmdldFBvcywgdGFyZ2V0VmVsLCBzdGlmZm5lc3MsIGRhbXBpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2ltcHVsc2Vqb2ludHNldF9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UmF3R2VuZXJpY0pvaW50fSBwYXJhbXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJlbnQxXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcGFyZW50MlxuICAgICogQHBhcmFtIHtib29sZWFufSB3YWtlX3VwXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY3JlYXRlSm9pbnQocGFyYW1zLCBwYXJlbnQxLCBwYXJlbnQyLCB3YWtlX3VwKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwYXJhbXMsIFJhd0dlbmVyaWNKb2ludCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2NyZWF0ZUpvaW50KHRoaXMuX193YmdfcHRyLCBwYXJhbXMuX193YmdfcHRyLCBwYXJlbnQxLCBwYXJlbnQyLCB3YWtlX3VwKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VVcFxuICAgICovXG4gICAgcmVtb3ZlKGhhbmRsZSwgd2FrZVVwKSB7XG4gICAgICAgIHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X3JlbW92ZSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCB3YWtlVXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBsZW4oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2xlbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBjb250YWlucyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfY29udGFpbnModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBmdW5jdGlvbiB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBqb2ludCBtYW5hZ2VkIGJ5IHRoaXMgcGh5c2ljcyB3b3JsZC5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYGYoaGFuZGxlKWA6IHRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBqb2ludCBtYW5hZ2VkIGJ5IHRoaXMgc2V0LiBDYWxsZWQgYXMgYGYoY29sbGlkZXIpYC5cbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAqL1xuICAgIGZvckVhY2hKb2ludEhhbmRsZShmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3YXNtLnJhd2ltcHVsc2Vqb2ludHNldF9mb3JFYWNoSm9pbnRIYW5kbGUodGhpcy5fX3diZ19wdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGYpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gdGhlIGludGVnZXIgaGFuZGxlIG9mIGVhY2ggam9pbnQgYXR0YWNoZWQgdG8gdGhlIGdpdmVuIHJpZ2lkLWJvZHkuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGBmKGhhbmRsZSlgOiB0aGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGludGVnZXIgaGFuZGxlIG9mIGVhY2ggam9pbnQgYXR0YWNoZWQgdG8gdGhlIHJpZ2lkLWJvZHkuIENhbGxlZCBhcyBgZihjb2xsaWRlcilgLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGJvZHlcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAqL1xuICAgIGZvckVhY2hKb2ludEF0dGFjaGVkVG9SaWdpZEJvZHkoYm9keSwgZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2FzbS5yYXdpbXB1bHNlam9pbnRzZXRfZm9yRWFjaEpvaW50QXR0YWNoZWRUb1JpZ2lkQm9keSh0aGlzLl9fd2JnX3B0ciwgYm9keSwgYWRkQm9ycm93ZWRPYmplY3QoZikpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBSYXdJbnRlZ3JhdGlvblBhcmFtZXRlcnNGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3SW50ZWdyYXRpb25QYXJhbWV0ZXJzIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdJbnRlZ3JhdGlvblBhcmFtZXRlcnMucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3SW50ZWdyYXRpb25QYXJhbWV0ZXJzRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd0ludGVncmF0aW9uUGFyYW1ldGVyc0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IGR0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19kdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGdldCBjb250YWN0X2VycCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfY29udGFjdF9lcnAodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBnZXQgbm9ybWFsaXplZEFsbG93ZWRMaW5lYXJFcnJvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0Zm9yY2VldmVudF9tYXhfZm9yY2VfbWFnbml0dWRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IG5vcm1hbGl6ZWRQcmVkaWN0aW9uRGlzdGFuY2UoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX25vcm1hbGl6ZWRQcmVkaWN0aW9uRGlzdGFuY2UodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBnZXQgbnVtU29sdmVySXRlcmF0aW9ucygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbnVtU29sdmVySXRlcmF0aW9ucyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGdldCBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19udW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IG51bUludGVybmFsUGdzSXRlcmF0aW9ucygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IG1pbklzbGFuZFNpemUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3aW1wdWxzZWpvaW50c2V0X2xlbih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGdldCBtYXhDY2RTdWJzdGVwcygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWF4Q2NkU3Vic3RlcHModGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoVW5pdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb250YWN0Zm9yY2VldmVudF90b3RhbF9mb3JjZV9tYWduaXR1ZGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICovXG4gICAgc2V0IGR0KHZhbHVlKSB7XG4gICAgICAgIHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9kdCh0aGlzLl9fd2JnX3B0ciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICovXG4gICAgc2V0IGNvbnRhY3RfbmF0dXJhbF9mcmVxdWVuY3kodmFsdWUpIHtcbiAgICAgICAgd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X2NvbnRhY3RfbmF0dXJhbF9mcmVxdWVuY3kodGhpcy5fX3diZ19wdHIsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAqL1xuICAgIHNldCBub3JtYWxpemVkQWxsb3dlZExpbmVhckVycm9yKHZhbHVlKSB7XG4gICAgICAgIHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9ub3JtYWxpemVkQWxsb3dlZExpbmVhckVycm9yKHRoaXMuX193YmdfcHRyLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgKi9cbiAgICBzZXQgbm9ybWFsaXplZFByZWRpY3Rpb25EaXN0YW5jZSh2YWx1ZSkge1xuICAgICAgICB3YXNtLnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbm9ybWFsaXplZFByZWRpY3Rpb25EaXN0YW5jZSh0aGlzLl9fd2JnX3B0ciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICovXG4gICAgc2V0IG51bVNvbHZlckl0ZXJhdGlvbnModmFsdWUpIHtcbiAgICAgICAgd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X251bVNvbHZlckl0ZXJhdGlvbnModGhpcy5fX3diZ19wdHIsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAqL1xuICAgIHNldCBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zKHZhbHVlKSB7XG4gICAgICAgIHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9udW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zKHRoaXMuX193YmdfcHRyLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgKi9cbiAgICBzZXQgbnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zKHZhbHVlKSB7XG4gICAgICAgIHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9udW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnModGhpcy5fX3diZ19wdHIsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAqL1xuICAgIHNldCBtaW5Jc2xhbmRTaXplKHZhbHVlKSB7XG4gICAgICAgIHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9taW5Jc2xhbmRTaXplKHRoaXMuX193YmdfcHRyLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgKi9cbiAgICBzZXQgbWF4Q2NkU3Vic3RlcHModmFsdWUpIHtcbiAgICAgICAgd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21heENjZFN1YnN0ZXBzKHRoaXMuX193YmdfcHRyLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgKi9cbiAgICBzZXQgbGVuZ3RoVW5pdCh2YWx1ZSkge1xuICAgICAgICB3YXNtLnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbGVuZ3RoVW5pdCh0aGlzLl9fd2JnX3B0ciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIHN3aXRjaFRvU3RhbmRhcmRQZ3NTb2x2ZXIoKSB7XG4gICAgICAgIHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3N3aXRjaFRvU3RhbmRhcmRQZ3NTb2x2ZXIodGhpcy5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIHN3aXRjaFRvU21hbGxTdGVwc1Bnc1NvbHZlcigpIHtcbiAgICAgICAgd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc3dpdGNoVG9TbWFsbFN0ZXBzUGdzU29sdmVyKHRoaXMuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBzd2l0Y2hUb1NtYWxsU3RlcHNQZ3NTb2x2ZXJXaXRob3V0V2FybXN0YXJ0KCkge1xuICAgICAgICB3YXNtLnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zd2l0Y2hUb1NtYWxsU3RlcHNQZ3NTb2x2ZXJXaXRob3V0V2FybXN0YXJ0KHRoaXMuX193YmdfcHRyKTtcbiAgICB9XG59XG5cbmNvbnN0IFJhd0lzbGFuZE1hbmFnZXJGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3aXNsYW5kbWFuYWdlcl9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd0lzbGFuZE1hbmFnZXIge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJhd0lzbGFuZE1hbmFnZXIucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3SXNsYW5kTWFuYWdlckZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdJc2xhbmRNYW5hZ2VyRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdpc2xhbmRtYW5hZ2VyX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpc2xhbmRtYW5hZ2VyX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBmdW5jdGlvbiB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBhY3RpdmUgcmlnaWQtYm9keVxuICAgICogbWFuYWdlZCBieSB0aGlzIGlzbGFuZCBtYW5hZ2VyLlxuICAgICpcbiAgICAqIEFmdGVyIGEgc2hvcnQgdGltZSBvZiBpbmFjdGl2aXR5LCBhIHJpZ2lkLWJvZHkgaXMgYXV0b21hdGljYWxseSBkZWFjdGl2YXRlZCAoXCJhc2xlZXBcIikgYnlcbiAgICAqIHRoZSBwaHlzaWNzIGVuZ2luZSBpbiBvcmRlciB0byBzYXZlIGNvbXB1dGF0aW9uYWwgcG93ZXIuIEEgc2xlZXBpbmcgcmlnaWQtYm9keSBuZXZlciBtb3Zlc1xuICAgICogdW5sZXNzIGl0IGlzIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLlxuICAgICpcbiAgICAqICMgUGFyYW1ldGVyc1xuICAgICogLSBgZihoYW5kbGUpYDogdGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSBpbnRlZ2VyIGhhbmRsZSBvZiBlYWNoIGFjdGl2ZSByaWdpZC1ib2R5IG1hbmFnZWQgYnkgdGhpc1xuICAgICogICBzZXQuIENhbGxlZCBhcyBgZihjb2xsaWRlcilgLlxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICovXG4gICAgZm9yRWFjaEFjdGl2ZVJpZ2lkQm9keUhhbmRsZShmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3YXNtLnJhd2lzbGFuZG1hbmFnZXJfZm9yRWFjaEFjdGl2ZVJpZ2lkQm9keUhhbmRsZSh0aGlzLl9fd2JnX3B0ciwgYWRkQm9ycm93ZWRPYmplY3QoZikpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBSYXdLaW5lbWF0aWNDaGFyYWN0ZXJDb250cm9sbGVyRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Jhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdLaW5lbWF0aWNDaGFyYWN0ZXJDb250cm9sbGVyIHtcblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3S2luZW1hdGljQ2hhcmFjdGVyQ29udHJvbGxlckZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgICovXG4gICAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9uZXcob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICB1cCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNoYXBlY2FzdGhpdF9ub3JtYWwyKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gdmVjdG9yXG4gICAgKi9cbiAgICBzZXRVcCh2ZWN0b3IpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHZlY3RvciwgUmF3VmVjdG9yKTtcbiAgICAgICAgd2FzbS5yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX3NldFVwKHRoaXMuX193YmdfcHRyLCB2ZWN0b3IuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgbm9ybWFsTnVkZ2VGYWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9ub3JtYWxOdWRnZUZhY3Rvcih0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgKi9cbiAgICBzZXROb3JtYWxOdWRnZUZhY3Rvcih2YWx1ZSkge1xuICAgICAgICB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfc2V0Tm9ybWFsTnVkZ2VGYWN0b3IodGhpcy5fX3diZ19wdHIsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgb2Zmc2V0KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19kdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgKi9cbiAgICBzZXRPZmZzZXQodmFsdWUpIHtcbiAgICAgICAgd2FzbS5yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX3NldE9mZnNldCh0aGlzLl9fd2JnX3B0ciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgc2xpZGVFbmFibGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfc2xpZGVFbmFibGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAqL1xuICAgIHNldFNsaWRlRW5hYmxlZChlbmFibGVkKSB7XG4gICAgICAgIHdhc20ucmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9zZXRTbGlkZUVuYWJsZWQodGhpcy5fX3diZ19wdHIsIGVuYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBhdXRvc3RlcE1heEhlaWdodCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX2F1dG9zdGVwTWF4SGVpZ2h0KHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0RmxvYXQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gcjAgPT09IDAgPyB1bmRlZmluZWQgOiByMTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgYXV0b3N0ZXBNaW5XaWR0aCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX2F1dG9zdGVwTWluV2lkdGgocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRGbG9hdDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiByMCA9PT0gMCA/IHVuZGVmaW5lZCA6IHIxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtib29sZWFuIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgYXV0b3N0ZXBJbmNsdWRlc0R5bmFtaWNCb2RpZXMoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9hdXRvc3RlcEluY2x1ZGVzRHluYW1pY0JvZGllcyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDB4RkZGRkZGID8gdW5kZWZpbmVkIDogcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgYXV0b3N0ZXBFbmFibGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfYXV0b3N0ZXBFbmFibGVkKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWluV2lkdGhcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUR5bmFtaWNCb2RpZXNcbiAgICAqL1xuICAgIGVuYWJsZUF1dG9zdGVwKG1heEhlaWdodCwgbWluV2lkdGgsIGluY2x1ZGVEeW5hbWljQm9kaWVzKSB7XG4gICAgICAgIHdhc20ucmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9lbmFibGVBdXRvc3RlcCh0aGlzLl9fd2JnX3B0ciwgbWF4SGVpZ2h0LCBtaW5XaWR0aCwgaW5jbHVkZUR5bmFtaWNCb2RpZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGRpc2FibGVBdXRvc3RlcCgpIHtcbiAgICAgICAgd2FzbS5yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX2Rpc2FibGVBdXRvc3RlcCh0aGlzLl9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIG1heFNsb3BlQ2xpbWJBbmdsZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbm9ybWFsaXplZFByZWRpY3Rpb25EaXN0YW5jZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgKi9cbiAgICBzZXRNYXhTbG9wZUNsaW1iQW5nbGUoYW5nbGUpIHtcbiAgICAgICAgd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X25vcm1hbGl6ZWRQcmVkaWN0aW9uRGlzdGFuY2UodGhpcy5fX3diZ19wdHIsIGFuZ2xlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgbWluU2xvcGVTbGlkZUFuZ2xlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfbWluU2xvcGVTbGlkZUFuZ2xlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAqL1xuICAgIHNldE1pblNsb3BlU2xpZGVBbmdsZShhbmdsZSkge1xuICAgICAgICB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfc2V0TWluU2xvcGVTbGlkZUFuZ2xlKHRoaXMuX193YmdfcHRyLCBhbmdsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHNuYXBUb0dyb3VuZERpc3RhbmNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfc25hcFRvR3JvdW5kRGlzdGFuY2UocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRGbG9hdDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiByMCA9PT0gMCA/IHVuZGVmaW5lZCA6IHIxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICovXG4gICAgZW5hYmxlU25hcFRvR3JvdW5kKGRpc3RhbmNlKSB7XG4gICAgICAgIHdhc20ucmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9lbmFibGVTbmFwVG9Hcm91bmQodGhpcy5fX3diZ19wdHIsIGRpc3RhbmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBkaXNhYmxlU25hcFRvR3JvdW5kKCkge1xuICAgICAgICB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfZGlzYWJsZVNuYXBUb0dyb3VuZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBzbmFwVG9Hcm91bmRFbmFibGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfc25hcFRvR3JvdW5kRW5hYmxlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGR0XG4gICAgKiBAcGFyYW0ge1Jhd1JpZ2lkQm9keVNldH0gYm9kaWVzXG4gICAgKiBAcGFyYW0ge1Jhd0NvbGxpZGVyU2V0fSBjb2xsaWRlcnNcbiAgICAqIEBwYXJhbSB7UmF3UXVlcnlQaXBlbGluZX0gcXVlcmllc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbGxpZGVyX2hhbmRsZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGRlc2lyZWRfdHJhbnNsYXRpb25fZGVsdGFcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXBwbHlfaW1wdWxzZXNfdG9fZHluYW1pY19ib2RpZXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBjaGFyYWN0ZXJfbWFzc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IGZpbHRlcl9mbGFnc1xuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9ncm91cHNcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlcl9wcmVkaWNhdGVcbiAgICAqL1xuICAgIGNvbXB1dGVDb2xsaWRlck1vdmVtZW50KGR0LCBib2RpZXMsIGNvbGxpZGVycywgcXVlcmllcywgY29sbGlkZXJfaGFuZGxlLCBkZXNpcmVkX3RyYW5zbGF0aW9uX2RlbHRhLCBhcHBseV9pbXB1bHNlc190b19keW5hbWljX2JvZGllcywgY2hhcmFjdGVyX21hc3MsIGZpbHRlcl9mbGFncywgZmlsdGVyX2dyb3VwcywgZmlsdGVyX3ByZWRpY2F0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGJvZGllcywgUmF3UmlnaWRCb2R5U2V0KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhxdWVyaWVzLCBSYXdRdWVyeVBpcGVsaW5lKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhkZXNpcmVkX3RyYW5zbGF0aW9uX2RlbHRhLCBSYXdWZWN0b3IpO1xuICAgICAgICAgICAgd2FzbS5yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX2NvbXB1dGVDb2xsaWRlck1vdmVtZW50KHRoaXMuX193YmdfcHRyLCBkdCwgYm9kaWVzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0ciwgcXVlcmllcy5fX3diZ19wdHIsIGNvbGxpZGVyX2hhbmRsZSwgZGVzaXJlZF90cmFuc2xhdGlvbl9kZWx0YS5fX3diZ19wdHIsIGFwcGx5X2ltcHVsc2VzX3RvX2R5bmFtaWNfYm9kaWVzLCAhaXNMaWtlTm9uZShjaGFyYWN0ZXJfbWFzcyksIGlzTGlrZU5vbmUoY2hhcmFjdGVyX21hc3MpID8gMCA6IGNoYXJhY3Rlcl9tYXNzLCBmaWx0ZXJfZmxhZ3MsICFpc0xpa2VOb25lKGZpbHRlcl9ncm91cHMpLCBpc0xpa2VOb25lKGZpbHRlcl9ncm91cHMpID8gMCA6IGZpbHRlcl9ncm91cHMsIGFkZEJvcnJvd2VkT2JqZWN0KGZpbHRlcl9wcmVkaWNhdGUpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBjb21wdXRlZE1vdmVtZW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfY29tcHV0ZWRNb3ZlbWVudCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBjb21wdXRlZEdyb3VuZGVkKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2tpbmVtYXRpY2NoYXJhY3RlcmNvbnRyb2xsZXJfY29tcHV0ZWRHcm91bmRlZCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIG51bUNvbXB1dGVkQ29sbGlzaW9ucygpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdraW5lbWF0aWNjaGFyYWN0ZXJjb250cm9sbGVyX251bUNvbXB1dGVkQ29sbGlzaW9ucyh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGlcbiAgICAqIEBwYXJhbSB7UmF3Q2hhcmFjdGVyQ29sbGlzaW9ufSBjb2xsaXNpb25cbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgY29tcHV0ZWRDb2xsaXNpb24oaSwgY29sbGlzaW9uKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaXNpb24sIFJhd0NoYXJhY3RlckNvbGxpc2lvbik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3a2luZW1hdGljY2hhcmFjdGVyY29udHJvbGxlcl9jb21wdXRlZENvbGxpc2lvbih0aGlzLl9fd2JnX3B0ciwgaSwgY29sbGlzaW9uLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxufVxuXG5jb25zdCBSYXdNdWx0aWJvZHlKb2ludFNldEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdtdWx0aWJvZHlqb2ludHNldF9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd011bHRpYm9keUpvaW50U2V0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdNdWx0aWJvZHlKb2ludFNldC5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSYXdNdWx0aWJvZHlKb2ludFNldEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdNdWx0aWJvZHlKb2ludFNldEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3bXVsdGlib2R5am9pbnRzZXRfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSB0eXBlIG9mIHRoaXMgam9pbnQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3Sm9pbnRUeXBlfVxuICAgICovXG4gICAgam9pbnRUeXBlKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd211bHRpYm9keWpvaW50c2V0X2pvaW50VHlwZSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgYW5ndWxhciBwYXJ0IG9mIHRoZSBqb2ludOKAmXMgbG9jYWwgZnJhbWUgcmVsYXRpdmUgdG8gdGhlIGZpcnN0IHJpZ2lkLWJvZHkgaXQgaXMgYXR0YWNoZWQgdG8uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3Um90YXRpb259XG4gICAgKi9cbiAgICBqb2ludEZyYW1lWDEoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3bXVsdGlib2R5am9pbnRzZXRfam9pbnRGcmFtZVgxKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gUmF3Um90YXRpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGFuZ3VsYXIgcGFydCBvZiB0aGUgam9pbnTigJlzIGxvY2FsIGZyYW1lIHJlbGF0aXZlIHRvIHRoZSBzZWNvbmQgcmlnaWQtYm9keSBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtSYXdSb3RhdGlvbn1cbiAgICAqL1xuICAgIGpvaW50RnJhbWVYMihoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdtdWx0aWJvZHlqb2ludHNldF9qb2ludEZyYW1lWDIodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdSb3RhdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGFuY2hvciBvZiB0aGlzIGpvaW50LlxuICAgICpcbiAgICAqIFRoZSBmaXJzdCBhbmNob3IgZ2l2ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb2ludHMgYXBwbGljYXRpb24gcG9pbnQgb24gdGhlXG4gICAgKiBsb2NhbCBmcmFtZSBvZiB0aGUgZmlyc3QgcmlnaWQtYm9keSBpdCBpcyBhdHRhY2hlZCB0by5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBqb2ludEFuY2hvcjEoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3bXVsdGlib2R5am9pbnRzZXRfam9pbnRBbmNob3IxKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIGFuY2hvciBvZiB0aGlzIGpvaW50LlxuICAgICpcbiAgICAqIFRoZSBzZWNvbmQgYW5jaG9yIGdpdmVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRzIGFwcGxpY2F0aW9uIHBvaW50IG9uIHRoZVxuICAgICogbG9jYWwgZnJhbWUgb2YgdGhlIHNlY29uZCByaWdpZC1ib2R5IGl0IGlzIGF0dGFjaGVkIHRvLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIGpvaW50QW5jaG9yMihoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdtdWx0aWJvZHlqb2ludHNldF9qb2ludEFuY2hvcjIodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXJlIGNvbnRhY3RzIGJldHdlZW4gdGhlIHJpZ2lkLWJvZGllcyBhdHRhY2hlZCBieSB0aGlzIGpvaW50IGVuYWJsZWQ/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIGpvaW50Q29udGFjdHNFbmFibGVkKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd211bHRpYm9keWpvaW50c2V0X2pvaW50Q29udGFjdHNFbmFibGVkKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHMgd2hldGhlciBjb250YWN0cyBhcmUgZW5hYmxlZCBiZXR3ZWVuIHRoZSByaWdpZC1ib2RpZXMgYXR0YWNoZWQgYnkgdGhpcyBqb2ludC5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICovXG4gICAgam9pbnRTZXRDb250YWN0c0VuYWJsZWQoaGFuZGxlLCBlbmFibGVkKSB7XG4gICAgICAgIHdhc20ucmF3bXVsdGlib2R5am9pbnRzZXRfam9pbnRTZXRDb250YWN0c0VuYWJsZWQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgZW5hYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXJlIHRoZSBsaW1pdHMgZm9yIHRoaXMgam9pbnQgZW5hYmxlZD9cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7UmF3Sm9pbnRBeGlzfSBheGlzXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIGpvaW50TGltaXRzRW5hYmxlZChoYW5kbGUsIGF4aXMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdtdWx0aWJvZHlqb2ludHNldF9qb2ludExpbWl0c0VuYWJsZWQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJuIHRoZSBsb3dlciBsaW1pdCBhbG9uZyB0aGUgZ2l2ZW4gam9pbnQgYXhpcy5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7UmF3Sm9pbnRBeGlzfSBheGlzXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgam9pbnRMaW1pdHNNaW4oaGFuZGxlLCBheGlzKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3bXVsdGlib2R5am9pbnRzZXRfam9pbnRMaW1pdHNNaW4odGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogSWYgdGhpcyBpcyBhIHByaXNtYXRpYyBqb2ludCwgcmV0dXJucyBpdHMgdXBwZXIgbGltaXQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd0pvaW50QXhpc30gYXhpc1xuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGpvaW50TGltaXRzTWF4KGhhbmRsZSwgYXhpcykge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd211bHRpYm9keWpvaW50c2V0X2pvaW50TGltaXRzTWF4KHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd211bHRpYm9keWpvaW50c2V0X25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdHZW5lcmljSm9pbnR9IHBhcmFtc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmVudDFcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJlbnQyXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VVcFxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNyZWF0ZUpvaW50KHBhcmFtcywgcGFyZW50MSwgcGFyZW50Miwgd2FrZVVwKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwYXJhbXMsIFJhd0dlbmVyaWNKb2ludCk7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3bXVsdGlib2R5am9pbnRzZXRfY3JlYXRlSm9pbnQodGhpcy5fX3diZ19wdHIsIHBhcmFtcy5fX3diZ19wdHIsIHBhcmVudDEsIHBhcmVudDIsIHdha2VVcCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtib29sZWFufSB3YWtlVXBcbiAgICAqL1xuICAgIHJlbW92ZShoYW5kbGUsIHdha2VVcCkge1xuICAgICAgICB3YXNtLnJhd211bHRpYm9keWpvaW50c2V0X3JlbW92ZSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCB3YWtlVXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgY29udGFpbnMoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3bXVsdGlib2R5am9pbnRzZXRfY29udGFpbnModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBmdW5jdGlvbiB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBqb2ludCBtYW5hZ2VkIGJ5IHRoaXMgcGh5c2ljcyB3b3JsZC5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYGYoaGFuZGxlKWA6IHRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBqb2ludCBtYW5hZ2VkIGJ5IHRoaXMgc2V0LiBDYWxsZWQgYXMgYGYoY29sbGlkZXIpYC5cbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAqL1xuICAgIGZvckVhY2hKb2ludEhhbmRsZShmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3YXNtLnJhd211bHRpYm9keWpvaW50c2V0X2ZvckVhY2hKb2ludEhhbmRsZSh0aGlzLl9fd2JnX3B0ciwgYWRkQm9ycm93ZWRPYmplY3QoZikpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBmdW5jdGlvbiB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBqb2ludCBhdHRhY2hlZCB0byB0aGUgZ2l2ZW4gcmlnaWQtYm9keS5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYGYoaGFuZGxlKWA6IHRoZSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCBqb2ludCBhdHRhY2hlZCB0byB0aGUgcmlnaWQtYm9keS4gQ2FsbGVkIGFzIGBmKGNvbGxpZGVyKWAuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYm9keVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICovXG4gICAgZm9yRWFjaEpvaW50QXR0YWNoZWRUb1JpZ2lkQm9keShib2R5LCBmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3YXNtLnJhd211bHRpYm9keWpvaW50c2V0X2ZvckVhY2hKb2ludEF0dGFjaGVkVG9SaWdpZEJvZHkodGhpcy5fX3diZ19wdHIsIGJvZHksIGFkZEJvcnJvd2VkT2JqZWN0KGYpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgUmF3TmFycm93UGhhc2VGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3bmFycm93cGhhc2VfZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdOYXJyb3dQaGFzZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3TmFycm93UGhhc2UucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3TmFycm93UGhhc2VGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3TmFycm93UGhhc2VGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd25hcnJvd3BoYXNlX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXduYXJyb3dwaGFzZV9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUxXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAgKi9cbiAgICBjb250YWN0X3BhaXJzX3dpdGgoaGFuZGxlMSwgZikge1xuICAgICAgICB3YXNtLnJhd25hcnJvd3BoYXNlX2NvbnRhY3RfcGFpcnNfd2l0aCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlMSwgYWRkSGVhcE9iamVjdChmKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZTFcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUyXG4gICAgKiBAcmV0dXJucyB7UmF3Q29udGFjdFBhaXIgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjb250YWN0X3BhaXIoaGFuZGxlMSwgaGFuZGxlMikge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd25hcnJvd3BoYXNlX2NvbnRhY3RfcGFpcih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlMSwgaGFuZGxlMik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdDb250YWN0UGFpci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlMVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICAgICovXG4gICAgaW50ZXJzZWN0aW9uX3BhaXJzX3dpdGgoaGFuZGxlMSwgZikge1xuICAgICAgICB3YXNtLnJhd25hcnJvd3BoYXNlX2ludGVyc2VjdGlvbl9wYWlyc193aXRoKHRoaXMuX193YmdfcHRyLCBoYW5kbGUxLCBhZGRIZWFwT2JqZWN0KGYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlMVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZTJcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgaW50ZXJzZWN0aW9uX3BhaXIoaGFuZGxlMSwgaGFuZGxlMikge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd25hcnJvd3BoYXNlX2ludGVyc2VjdGlvbl9wYWlyKHRoaXMuX193YmdfcHRyLCBoYW5kbGUxLCBoYW5kbGUyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5cbmNvbnN0IFJhd1BoeXNpY3NQaXBlbGluZUZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdwaHlzaWNzcGlwZWxpbmVfZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdQaHlzaWNzUGlwZWxpbmUge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdQaHlzaWNzUGlwZWxpbmVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd3BoeXNpY3NwaXBlbGluZV9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cGh5c2ljc3BpcGVsaW5lX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGdyYXZpdHlcbiAgICAqIEBwYXJhbSB7UmF3SW50ZWdyYXRpb25QYXJhbWV0ZXJzfSBpbnRlZ3JhdGlvblBhcmFtZXRlcnNcbiAgICAqIEBwYXJhbSB7UmF3SXNsYW5kTWFuYWdlcn0gaXNsYW5kc1xuICAgICogQHBhcmFtIHtSYXdCcm9hZFBoYXNlfSBicm9hZFBoYXNlXG4gICAgKiBAcGFyYW0ge1Jhd05hcnJvd1BoYXNlfSBuYXJyb3dQaGFzZVxuICAgICogQHBhcmFtIHtSYXdSaWdpZEJvZHlTZXR9IGJvZGllc1xuICAgICogQHBhcmFtIHtSYXdDb2xsaWRlclNldH0gY29sbGlkZXJzXG4gICAgKiBAcGFyYW0ge1Jhd0ltcHVsc2VKb2ludFNldH0gam9pbnRzXG4gICAgKiBAcGFyYW0ge1Jhd011bHRpYm9keUpvaW50U2V0fSBhcnRpY3VsYXRpb25zXG4gICAgKiBAcGFyYW0ge1Jhd0NDRFNvbHZlcn0gY2NkX3NvbHZlclxuICAgICovXG4gICAgc3RlcChncmF2aXR5LCBpbnRlZ3JhdGlvblBhcmFtZXRlcnMsIGlzbGFuZHMsIGJyb2FkUGhhc2UsIG5hcnJvd1BoYXNlLCBib2RpZXMsIGNvbGxpZGVycywgam9pbnRzLCBhcnRpY3VsYXRpb25zLCBjY2Rfc29sdmVyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhncmF2aXR5LCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaW50ZWdyYXRpb25QYXJhbWV0ZXJzLCBSYXdJbnRlZ3JhdGlvblBhcmFtZXRlcnMpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaXNsYW5kcywgUmF3SXNsYW5kTWFuYWdlcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhicm9hZFBoYXNlLCBSYXdCcm9hZFBoYXNlKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5hcnJvd1BoYXNlLCBSYXdOYXJyb3dQaGFzZSk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhib2RpZXMsIFJhd1JpZ2lkQm9keVNldCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGpvaW50cywgUmF3SW1wdWxzZUpvaW50U2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFydGljdWxhdGlvbnMsIFJhd011bHRpYm9keUpvaW50U2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNjZF9zb2x2ZXIsIFJhd0NDRFNvbHZlcik7XG4gICAgICAgIHdhc20ucmF3cGh5c2ljc3BpcGVsaW5lX3N0ZXAodGhpcy5fX3diZ19wdHIsIGdyYXZpdHkuX193YmdfcHRyLCBpbnRlZ3JhdGlvblBhcmFtZXRlcnMuX193YmdfcHRyLCBpc2xhbmRzLl9fd2JnX3B0ciwgYnJvYWRQaGFzZS5fX3diZ19wdHIsIG5hcnJvd1BoYXNlLl9fd2JnX3B0ciwgYm9kaWVzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0ciwgam9pbnRzLl9fd2JnX3B0ciwgYXJ0aWN1bGF0aW9ucy5fX3diZ19wdHIsIGNjZF9zb2x2ZXIuX193YmdfcHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gZ3Jhdml0eVxuICAgICogQHBhcmFtIHtSYXdJbnRlZ3JhdGlvblBhcmFtZXRlcnN9IGludGVncmF0aW9uUGFyYW1ldGVyc1xuICAgICogQHBhcmFtIHtSYXdJc2xhbmRNYW5hZ2VyfSBpc2xhbmRzXG4gICAgKiBAcGFyYW0ge1Jhd0Jyb2FkUGhhc2V9IGJyb2FkUGhhc2VcbiAgICAqIEBwYXJhbSB7UmF3TmFycm93UGhhc2V9IG5hcnJvd1BoYXNlXG4gICAgKiBAcGFyYW0ge1Jhd1JpZ2lkQm9keVNldH0gYm9kaWVzXG4gICAgKiBAcGFyYW0ge1Jhd0NvbGxpZGVyU2V0fSBjb2xsaWRlcnNcbiAgICAqIEBwYXJhbSB7UmF3SW1wdWxzZUpvaW50U2V0fSBqb2ludHNcbiAgICAqIEBwYXJhbSB7UmF3TXVsdGlib2R5Sm9pbnRTZXR9IGFydGljdWxhdGlvbnNcbiAgICAqIEBwYXJhbSB7UmF3Q0NEU29sdmVyfSBjY2Rfc29sdmVyXG4gICAgKiBAcGFyYW0ge1Jhd0V2ZW50UXVldWV9IGV2ZW50UXVldWVcbiAgICAqIEBwYXJhbSB7b2JqZWN0fSBob29rT2JqZWN0XG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rRmlsdGVyQ29udGFjdFBhaXJcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhvb2tGaWx0ZXJJbnRlcnNlY3Rpb25QYWlyXG4gICAgKi9cbiAgICBzdGVwV2l0aEV2ZW50cyhncmF2aXR5LCBpbnRlZ3JhdGlvblBhcmFtZXRlcnMsIGlzbGFuZHMsIGJyb2FkUGhhc2UsIG5hcnJvd1BoYXNlLCBib2RpZXMsIGNvbGxpZGVycywgam9pbnRzLCBhcnRpY3VsYXRpb25zLCBjY2Rfc29sdmVyLCBldmVudFF1ZXVlLCBob29rT2JqZWN0LCBob29rRmlsdGVyQ29udGFjdFBhaXIsIGhvb2tGaWx0ZXJJbnRlcnNlY3Rpb25QYWlyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhncmF2aXR5LCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaW50ZWdyYXRpb25QYXJhbWV0ZXJzLCBSYXdJbnRlZ3JhdGlvblBhcmFtZXRlcnMpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaXNsYW5kcywgUmF3SXNsYW5kTWFuYWdlcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhicm9hZFBoYXNlLCBSYXdCcm9hZFBoYXNlKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5hcnJvd1BoYXNlLCBSYXdOYXJyb3dQaGFzZSk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhib2RpZXMsIFJhd1JpZ2lkQm9keVNldCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGpvaW50cywgUmF3SW1wdWxzZUpvaW50U2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGFydGljdWxhdGlvbnMsIFJhd011bHRpYm9keUpvaW50U2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNjZF9zb2x2ZXIsIFJhd0NDRFNvbHZlcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhldmVudFF1ZXVlLCBSYXdFdmVudFF1ZXVlKTtcbiAgICAgICAgd2FzbS5yYXdwaHlzaWNzcGlwZWxpbmVfc3RlcFdpdGhFdmVudHModGhpcy5fX3diZ19wdHIsIGdyYXZpdHkuX193YmdfcHRyLCBpbnRlZ3JhdGlvblBhcmFtZXRlcnMuX193YmdfcHRyLCBpc2xhbmRzLl9fd2JnX3B0ciwgYnJvYWRQaGFzZS5fX3diZ19wdHIsIG5hcnJvd1BoYXNlLl9fd2JnX3B0ciwgYm9kaWVzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0ciwgam9pbnRzLl9fd2JnX3B0ciwgYXJ0aWN1bGF0aW9ucy5fX3diZ19wdHIsIGNjZF9zb2x2ZXIuX193YmdfcHRyLCBldmVudFF1ZXVlLl9fd2JnX3B0ciwgYWRkSGVhcE9iamVjdChob29rT2JqZWN0KSwgYWRkSGVhcE9iamVjdChob29rRmlsdGVyQ29udGFjdFBhaXIpLCBhZGRIZWFwT2JqZWN0KGhvb2tGaWx0ZXJJbnRlcnNlY3Rpb25QYWlyKSk7XG4gICAgfVxufVxuXG5jb25zdCBSYXdQb2ludENvbGxpZGVyUHJvamVjdGlvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd1BvaW50Q29sbGlkZXJQcm9qZWN0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdQb2ludENvbGxpZGVyUHJvamVjdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSYXdQb2ludENvbGxpZGVyUHJvamVjdGlvbkZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdQb2ludENvbGxpZGVyUHJvamVjdGlvbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjb2xsaWRlckhhbmRsZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9jb2xsaWRlckhhbmRsZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHBvaW50KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX3BvaW50KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIGlzSW5zaWRlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX2lzSW5zaWRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7UmF3RmVhdHVyZVR5cGV9XG4gICAgKi9cbiAgICBmZWF0dXJlVHlwZSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9mZWF0dXJlVHlwZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIGZlYXR1cmVJZCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgd2FzbS5yYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9mZWF0dXJlSWQocmV0cHRyLCB0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gcjAgPT09IDAgPyB1bmRlZmluZWQgOiByMSA+Pj4gMDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFJhd1BvaW50UHJvamVjdGlvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdwb2ludHByb2plY3Rpb25fZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdQb2ludFByb2plY3Rpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJhd1BvaW50UHJvamVjdGlvbi5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSYXdQb2ludFByb2plY3Rpb25GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3UG9pbnRQcm9qZWN0aW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdwb2ludHByb2plY3Rpb25fZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBwb2ludCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdwb2ludHByb2plY3Rpb25fcG9pbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgaXNJbnNpZGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cG9pbnRwcm9qZWN0aW9uX2lzSW5zaWRlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG59XG5cbmNvbnN0IFJhd1F1ZXJ5UGlwZWxpbmVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3cXVlcnlwaXBlbGluZV9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd1F1ZXJ5UGlwZWxpbmUge1xuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdRdWVyeVBpcGVsaW5lRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdxdWVyeXBpcGVsaW5lX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdxdWVyeXBpcGVsaW5lX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdDb2xsaWRlclNldH0gY29sbGlkZXJzXG4gICAgKi9cbiAgICB1cGRhdGUoY29sbGlkZXJzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgd2FzbS5yYXdxdWVyeXBpcGVsaW5lX3VwZGF0ZSh0aGlzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdSaWdpZEJvZHlTZXR9IGJvZGllc1xuICAgICogQHBhcmFtIHtSYXdDb2xsaWRlclNldH0gY29sbGlkZXJzXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcmF5T3JpZ1xuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHJheURpclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFRvaVxuICAgICogQHBhcmFtIHtib29sZWFufSBzb2xpZFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGZpbHRlcl9mbGFnc1xuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9ncm91cHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlclxuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHlcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlcl9wcmVkaWNhdGVcbiAgICAqIEByZXR1cm5zIHtSYXdSYXlDb2xsaWRlckhpdCB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIGNhc3RSYXkoYm9kaWVzLCBjb2xsaWRlcnMsIHJheU9yaWcsIHJheURpciwgbWF4VG9pLCBzb2xpZCwgZmlsdGVyX2ZsYWdzLCBmaWx0ZXJfZ3JvdXBzLCBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciwgZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSwgZmlsdGVyX3ByZWRpY2F0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGJvZGllcywgUmF3UmlnaWRCb2R5U2V0KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYXlPcmlnLCBSYXdWZWN0b3IpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHJheURpciwgUmF3VmVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cXVlcnlwaXBlbGluZV9jYXN0UmF5KHRoaXMuX193YmdfcHRyLCBib2RpZXMuX193YmdfcHRyLCBjb2xsaWRlcnMuX193YmdfcHRyLCByYXlPcmlnLl9fd2JnX3B0ciwgcmF5RGlyLl9fd2JnX3B0ciwgbWF4VG9pLCBzb2xpZCwgZmlsdGVyX2ZsYWdzLCAhaXNMaWtlTm9uZShmaWx0ZXJfZ3JvdXBzKSwgaXNMaWtlTm9uZShmaWx0ZXJfZ3JvdXBzKSA/IDAgOiBmaWx0ZXJfZ3JvdXBzLCAhaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciksIGlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIpID8gMCA6IGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyLCAhaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5KSwgaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5KSA/IDAgOiBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5LCBhZGRCb3Jyb3dlZE9iamVjdChmaWx0ZXJfcHJlZGljYXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3UmF5Q29sbGlkZXJIaXQuX193cmFwKHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1JpZ2lkQm9keVNldH0gYm9kaWVzXG4gICAgKiBAcGFyYW0ge1Jhd0NvbGxpZGVyU2V0fSBjb2xsaWRlcnNcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSByYXlPcmlnXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcmF5RGlyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VG9pXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNvbGlkXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZmlsdGVyX2ZsYWdzXG4gICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZmlsdGVyX2dyb3Vwc1xuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyXG4gICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyX3ByZWRpY2F0ZVxuICAgICogQHJldHVybnMge1Jhd1JheUNvbGxpZGVySW50ZXJzZWN0aW9uIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY2FzdFJheUFuZEdldE5vcm1hbChib2RpZXMsIGNvbGxpZGVycywgcmF5T3JpZywgcmF5RGlyLCBtYXhUb2ksIHNvbGlkLCBmaWx0ZXJfZmxhZ3MsIGZpbHRlcl9ncm91cHMsIGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyLCBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5LCBmaWx0ZXJfcHJlZGljYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYm9kaWVzLCBSYXdSaWdpZEJvZHlTZXQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGNvbGxpZGVycywgUmF3Q29sbGlkZXJTZXQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHJheU9yaWcsIFJhd1ZlY3Rvcik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocmF5RGlyLCBSYXdWZWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdxdWVyeXBpcGVsaW5lX2Nhc3RSYXlBbmRHZXROb3JtYWwodGhpcy5fX3diZ19wdHIsIGJvZGllcy5fX3diZ19wdHIsIGNvbGxpZGVycy5fX3diZ19wdHIsIHJheU9yaWcuX193YmdfcHRyLCByYXlEaXIuX193YmdfcHRyLCBtYXhUb2ksIHNvbGlkLCBmaWx0ZXJfZmxhZ3MsICFpc0xpa2VOb25lKGZpbHRlcl9ncm91cHMpLCBpc0xpa2VOb25lKGZpbHRlcl9ncm91cHMpID8gMCA6IGZpbHRlcl9ncm91cHMsICFpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyKSwgaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlcikgPyAwIDogZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIsICFpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHkpLCBpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHkpID8gMCA6IGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHksIGFkZEJvcnJvd2VkT2JqZWN0KGZpbHRlcl9wcmVkaWNhdGUpKTtcbiAgICAgICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdSYXlDb2xsaWRlckludGVyc2VjdGlvbi5fX3dyYXAocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UmF3UmlnaWRCb2R5U2V0fSBib2RpZXNcbiAgICAqIEBwYXJhbSB7UmF3Q29sbGlkZXJTZXR9IGNvbGxpZGVyc1xuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHJheU9yaWdcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSByYXlEaXJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhUb2lcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc29saWRcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZmlsdGVyX2ZsYWdzXG4gICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZmlsdGVyX2dyb3Vwc1xuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyXG4gICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyX3ByZWRpY2F0ZVxuICAgICovXG4gICAgaW50ZXJzZWN0aW9uc1dpdGhSYXkoYm9kaWVzLCBjb2xsaWRlcnMsIHJheU9yaWcsIHJheURpciwgbWF4VG9pLCBzb2xpZCwgY2FsbGJhY2ssIGZpbHRlcl9mbGFncywgZmlsdGVyX2dyb3VwcywgZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIsIGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHksIGZpbHRlcl9wcmVkaWNhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhib2RpZXMsIFJhd1JpZ2lkQm9keVNldCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoY29sbGlkZXJzLCBSYXdDb2xsaWRlclNldCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocmF5T3JpZywgUmF3VmVjdG9yKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhyYXlEaXIsIFJhd1ZlY3Rvcik7XG4gICAgICAgICAgICB3YXNtLnJhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uc1dpdGhSYXkodGhpcy5fX3diZ19wdHIsIGJvZGllcy5fX3diZ19wdHIsIGNvbGxpZGVycy5fX3diZ19wdHIsIHJheU9yaWcuX193YmdfcHRyLCByYXlEaXIuX193YmdfcHRyLCBtYXhUb2ksIHNvbGlkLCBhZGRCb3Jyb3dlZE9iamVjdChjYWxsYmFjayksIGZpbHRlcl9mbGFncywgIWlzTGlrZU5vbmUoZmlsdGVyX2dyb3VwcyksIGlzTGlrZU5vbmUoZmlsdGVyX2dyb3VwcykgPyAwIDogZmlsdGVyX2dyb3VwcywgIWlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIpLCBpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyKSA/IDAgOiBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciwgIWlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSksIGlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSkgPyAwIDogZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSwgYWRkQm9ycm93ZWRPYmplY3QoZmlsdGVyX3ByZWRpY2F0ZSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdSaWdpZEJvZHlTZXR9IGJvZGllc1xuICAgICogQHBhcmFtIHtSYXdDb2xsaWRlclNldH0gY29sbGlkZXJzXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGVQb3NcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHNoYXBlUm90XG4gICAgKiBAcGFyYW0ge1Jhd1NoYXBlfSBzaGFwZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGZpbHRlcl9mbGFnc1xuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9ncm91cHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlclxuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHlcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlcl9wcmVkaWNhdGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBpbnRlcnNlY3Rpb25XaXRoU2hhcGUoYm9kaWVzLCBjb2xsaWRlcnMsIHNoYXBlUG9zLCBzaGFwZVJvdCwgc2hhcGUsIGZpbHRlcl9mbGFncywgZmlsdGVyX2dyb3VwcywgZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIsIGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHksIGZpbHRlcl9wcmVkaWNhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGJvZGllcywgUmF3UmlnaWRCb2R5U2V0KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVBvcywgUmF3VmVjdG9yKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVJvdCwgUmF3Um90YXRpb24pO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlLCBSYXdTaGFwZSk7XG4gICAgICAgICAgICB3YXNtLnJhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uV2l0aFNoYXBlKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIGJvZGllcy5fX3diZ19wdHIsIGNvbGxpZGVycy5fX3diZ19wdHIsIHNoYXBlUG9zLl9fd2JnX3B0ciwgc2hhcGVSb3QuX193YmdfcHRyLCBzaGFwZS5fX3diZ19wdHIsIGZpbHRlcl9mbGFncywgIWlzTGlrZU5vbmUoZmlsdGVyX2dyb3VwcyksIGlzTGlrZU5vbmUoZmlsdGVyX2dyb3VwcykgPyAwIDogZmlsdGVyX2dyb3VwcywgIWlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIpLCBpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyKSA/IDAgOiBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciwgIWlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSksIGlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSkgPyAwIDogZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSwgYWRkQm9ycm93ZWRPYmplY3QoZmlsdGVyX3ByZWRpY2F0ZSkpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0RmxvYXQ2NE1lbW9yeTAoKVtyZXRwdHIgLyA4ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gcjAgPT09IDAgPyB1bmRlZmluZWQgOiByMjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1JpZ2lkQm9keVNldH0gYm9kaWVzXG4gICAgKiBAcGFyYW0ge1Jhd0NvbGxpZGVyU2V0fSBjb2xsaWRlcnNcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBwb2ludFxuICAgICogQHBhcmFtIHtib29sZWFufSBzb2xpZFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGZpbHRlcl9mbGFnc1xuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9ncm91cHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlclxuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHlcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlcl9wcmVkaWNhdGVcbiAgICAqIEByZXR1cm5zIHtSYXdQb2ludENvbGxpZGVyUHJvamVjdGlvbiB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHByb2plY3RQb2ludChib2RpZXMsIGNvbGxpZGVycywgcG9pbnQsIHNvbGlkLCBmaWx0ZXJfZmxhZ3MsIGZpbHRlcl9ncm91cHMsIGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyLCBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5LCBmaWx0ZXJfcHJlZGljYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYm9kaWVzLCBSYXdSaWdpZEJvZHlTZXQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGNvbGxpZGVycywgUmF3Q29sbGlkZXJTZXQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHBvaW50LCBSYXdWZWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdxdWVyeXBpcGVsaW5lX3Byb2plY3RQb2ludCh0aGlzLl9fd2JnX3B0ciwgYm9kaWVzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0ciwgcG9pbnQuX193YmdfcHRyLCBzb2xpZCwgZmlsdGVyX2ZsYWdzLCAhaXNMaWtlTm9uZShmaWx0ZXJfZ3JvdXBzKSwgaXNMaWtlTm9uZShmaWx0ZXJfZ3JvdXBzKSA/IDAgOiBmaWx0ZXJfZ3JvdXBzLCAhaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciksIGlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIpID8gMCA6IGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyLCAhaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5KSwgaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5KSA/IDAgOiBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5LCBhZGRCb3Jyb3dlZE9iamVjdChmaWx0ZXJfcHJlZGljYXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3UG9pbnRDb2xsaWRlclByb2plY3Rpb24uX193cmFwKHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1JpZ2lkQm9keVNldH0gYm9kaWVzXG4gICAgKiBAcGFyYW0ge1Jhd0NvbGxpZGVyU2V0fSBjb2xsaWRlcnNcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBwb2ludFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGZpbHRlcl9mbGFnc1xuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9ncm91cHNcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlclxuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHlcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbHRlcl9wcmVkaWNhdGVcbiAgICAqIEByZXR1cm5zIHtSYXdQb2ludENvbGxpZGVyUHJvamVjdGlvbiB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHByb2plY3RQb2ludEFuZEdldEZlYXR1cmUoYm9kaWVzLCBjb2xsaWRlcnMsIHBvaW50LCBmaWx0ZXJfZmxhZ3MsIGZpbHRlcl9ncm91cHMsIGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyLCBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5LCBmaWx0ZXJfcHJlZGljYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYm9kaWVzLCBSYXdSaWdpZEJvZHlTZXQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGNvbGxpZGVycywgUmF3Q29sbGlkZXJTZXQpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHBvaW50LCBSYXdWZWN0b3IpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdxdWVyeXBpcGVsaW5lX3Byb2plY3RQb2ludEFuZEdldEZlYXR1cmUodGhpcy5fX3diZ19wdHIsIGJvZGllcy5fX3diZ19wdHIsIGNvbGxpZGVycy5fX3diZ19wdHIsIHBvaW50Ll9fd2JnX3B0ciwgZmlsdGVyX2ZsYWdzLCAhaXNMaWtlTm9uZShmaWx0ZXJfZ3JvdXBzKSwgaXNMaWtlTm9uZShmaWx0ZXJfZ3JvdXBzKSA/IDAgOiBmaWx0ZXJfZ3JvdXBzLCAhaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciksIGlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIpID8gMCA6IGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyLCAhaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5KSwgaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5KSA/IDAgOiBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5LCBhZGRCb3Jyb3dlZE9iamVjdChmaWx0ZXJfcHJlZGljYXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0ID09PSAwID8gdW5kZWZpbmVkIDogUmF3UG9pbnRDb2xsaWRlclByb2plY3Rpb24uX193cmFwKHJldCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1JpZ2lkQm9keVNldH0gYm9kaWVzXG4gICAgKiBAcGFyYW0ge1Jhd0NvbGxpZGVyU2V0fSBjb2xsaWRlcnNcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBwb2ludFxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWx0ZXJfZmxhZ3NcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBmaWx0ZXJfZ3JvdXBzXG4gICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXJcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5XG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJfcHJlZGljYXRlXG4gICAgKi9cbiAgICBpbnRlcnNlY3Rpb25zV2l0aFBvaW50KGJvZGllcywgY29sbGlkZXJzLCBwb2ludCwgY2FsbGJhY2ssIGZpbHRlcl9mbGFncywgZmlsdGVyX2dyb3VwcywgZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIsIGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHksIGZpbHRlcl9wcmVkaWNhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhib2RpZXMsIFJhd1JpZ2lkQm9keVNldCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoY29sbGlkZXJzLCBSYXdDb2xsaWRlclNldCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MocG9pbnQsIFJhd1ZlY3Rvcik7XG4gICAgICAgICAgICB3YXNtLnJhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uc1dpdGhQb2ludCh0aGlzLl9fd2JnX3B0ciwgYm9kaWVzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0ciwgcG9pbnQuX193YmdfcHRyLCBhZGRCb3Jyb3dlZE9iamVjdChjYWxsYmFjayksIGZpbHRlcl9mbGFncywgIWlzTGlrZU5vbmUoZmlsdGVyX2dyb3VwcyksIGlzTGlrZU5vbmUoZmlsdGVyX2dyb3VwcykgPyAwIDogZmlsdGVyX2dyb3VwcywgIWlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIpLCBpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyKSA/IDAgOiBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciwgIWlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSksIGlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSkgPyAwIDogZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSwgYWRkQm9ycm93ZWRPYmplY3QoZmlsdGVyX3ByZWRpY2F0ZSkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdSaWdpZEJvZHlTZXR9IGJvZGllc1xuICAgICogQHBhcmFtIHtSYXdDb2xsaWRlclNldH0gY29sbGlkZXJzXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGVQb3NcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHNoYXBlUm90XG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGVWZWxcbiAgICAqIEBwYXJhbSB7UmF3U2hhcGV9IHNoYXBlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0X2Rpc3RhbmNlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VG9pXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0b3BfYXRfcGVuZXRyYXRpb25cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWx0ZXJfZmxhZ3NcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBmaWx0ZXJfZ3JvdXBzXG4gICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXJcbiAgICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5XG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJfcHJlZGljYXRlXG4gICAgKiBAcmV0dXJucyB7UmF3Q29sbGlkZXJTaGFwZUNhc3RIaXQgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjYXN0U2hhcGUoYm9kaWVzLCBjb2xsaWRlcnMsIHNoYXBlUG9zLCBzaGFwZVJvdCwgc2hhcGVWZWwsIHNoYXBlLCB0YXJnZXRfZGlzdGFuY2UsIG1heFRvaSwgc3RvcF9hdF9wZW5ldHJhdGlvbiwgZmlsdGVyX2ZsYWdzLCBmaWx0ZXJfZ3JvdXBzLCBmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciwgZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keSwgZmlsdGVyX3ByZWRpY2F0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKGJvZGllcywgUmF3UmlnaWRCb2R5U2V0KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVBvcywgUmF3VmVjdG9yKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVJvdCwgUmF3Um90YXRpb24pO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlVmVsLCBSYXdWZWN0b3IpO1xuICAgICAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlLCBSYXdTaGFwZSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3F1ZXJ5cGlwZWxpbmVfY2FzdFNoYXBlKHRoaXMuX193YmdfcHRyLCBib2RpZXMuX193YmdfcHRyLCBjb2xsaWRlcnMuX193YmdfcHRyLCBzaGFwZVBvcy5fX3diZ19wdHIsIHNoYXBlUm90Ll9fd2JnX3B0ciwgc2hhcGVWZWwuX193YmdfcHRyLCBzaGFwZS5fX3diZ19wdHIsIHRhcmdldF9kaXN0YW5jZSwgbWF4VG9pLCBzdG9wX2F0X3BlbmV0cmF0aW9uLCBmaWx0ZXJfZmxhZ3MsICFpc0xpa2VOb25lKGZpbHRlcl9ncm91cHMpLCBpc0xpa2VOb25lKGZpbHRlcl9ncm91cHMpID8gMCA6IGZpbHRlcl9ncm91cHMsICFpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyKSwgaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlcikgPyAwIDogZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIsICFpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHkpLCBpc0xpa2VOb25lKGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHkpID8gMCA6IGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHksIGFkZEJvcnJvd2VkT2JqZWN0KGZpbHRlcl9wcmVkaWNhdGUpKTtcbiAgICAgICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdDb2xsaWRlclNoYXBlQ2FzdEhpdC5fX3dyYXAocmV0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UmF3UmlnaWRCb2R5U2V0fSBib2RpZXNcbiAgICAqIEBwYXJhbSB7UmF3Q29sbGlkZXJTZXR9IGNvbGxpZGVyc1xuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHNoYXBlUG9zXG4gICAgKiBAcGFyYW0ge1Jhd1JvdGF0aW9ufSBzaGFwZVJvdFxuICAgICogQHBhcmFtIHtSYXdTaGFwZX0gc2hhcGVcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZmlsdGVyX2ZsYWdzXG4gICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZmlsdGVyX2dyb3Vwc1xuICAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyXG4gICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZmlsdGVyX2V4Y2x1ZGVfcmlnaWRfYm9keVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyX3ByZWRpY2F0ZVxuICAgICovXG4gICAgaW50ZXJzZWN0aW9uc1dpdGhTaGFwZShib2RpZXMsIGNvbGxpZGVycywgc2hhcGVQb3MsIHNoYXBlUm90LCBzaGFwZSwgY2FsbGJhY2ssIGZpbHRlcl9mbGFncywgZmlsdGVyX2dyb3VwcywgZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIsIGZpbHRlcl9leGNsdWRlX3JpZ2lkX2JvZHksIGZpbHRlcl9wcmVkaWNhdGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhib2RpZXMsIFJhd1JpZ2lkQm9keVNldCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoY29sbGlkZXJzLCBSYXdDb2xsaWRlclNldCk7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVQb3MsIFJhd1ZlY3Rvcik7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVSb3QsIFJhd1JvdGF0aW9uKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZSwgUmF3U2hhcGUpO1xuICAgICAgICAgICAgd2FzbS5yYXdxdWVyeXBpcGVsaW5lX2ludGVyc2VjdGlvbnNXaXRoU2hhcGUodGhpcy5fX3diZ19wdHIsIGJvZGllcy5fX3diZ19wdHIsIGNvbGxpZGVycy5fX3diZ19wdHIsIHNoYXBlUG9zLl9fd2JnX3B0ciwgc2hhcGVSb3QuX193YmdfcHRyLCBzaGFwZS5fX3diZ19wdHIsIGFkZEJvcnJvd2VkT2JqZWN0KGNhbGxiYWNrKSwgZmlsdGVyX2ZsYWdzLCAhaXNMaWtlTm9uZShmaWx0ZXJfZ3JvdXBzKSwgaXNMaWtlTm9uZShmaWx0ZXJfZ3JvdXBzKSA/IDAgOiBmaWx0ZXJfZ3JvdXBzLCAhaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9jb2xsaWRlciksIGlzTGlrZU5vbmUoZmlsdGVyX2V4Y2x1ZGVfY29sbGlkZXIpID8gMCA6IGZpbHRlcl9leGNsdWRlX2NvbGxpZGVyLCAhaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5KSwgaXNMaWtlTm9uZShmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5KSA/IDAgOiBmaWx0ZXJfZXhjbHVkZV9yaWdpZF9ib2R5LCBhZGRCb3Jyb3dlZE9iamVjdChmaWx0ZXJfcHJlZGljYXRlKSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBoZWFwW3N0YWNrX3BvaW50ZXIrK10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gYWFiYkNlbnRlclxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGFhYmJIYWxmRXh0ZW50c1xuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAqL1xuICAgIGNvbGxpZGVyc1dpdGhBYWJiSW50ZXJzZWN0aW5nQWFiYihhYWJiQ2VudGVyLCBhYWJiSGFsZkV4dGVudHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfYXNzZXJ0Q2xhc3MoYWFiYkNlbnRlciwgUmF3VmVjdG9yKTtcbiAgICAgICAgICAgIF9hc3NlcnRDbGFzcyhhYWJiSGFsZkV4dGVudHMsIFJhd1ZlY3Rvcik7XG4gICAgICAgICAgICB3YXNtLnJhd3F1ZXJ5cGlwZWxpbmVfY29sbGlkZXJzV2l0aEFhYmJJbnRlcnNlY3RpbmdBYWJiKHRoaXMuX193YmdfcHRyLCBhYWJiQ2VudGVyLl9fd2JnX3B0ciwgYWFiYkhhbGZFeHRlbnRzLl9fd2JnX3B0ciwgYWRkQm9ycm93ZWRPYmplY3QoY2FsbGJhY2spKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGhlYXBbc3RhY2tfcG9pbnRlcisrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgUmF3UmF5Q29sbGlkZXJIaXRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3cmF5Y29sbGlkZXJoaXRfZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdSYXlDb2xsaWRlckhpdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3UmF5Q29sbGlkZXJIaXQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3UmF5Q29sbGlkZXJIaXRGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3UmF5Q29sbGlkZXJIaXRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd3JheWNvbGxpZGVyaGl0X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29sbGlkZXJIYW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzaGFwZWNhc3RoaXRfY29sbGlkZXJIYW5kbGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICB0aW1lT2ZJbXBhY3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzaGFwZWNhc3RoaXRfdGltZV9vZl9pbXBhY3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuY29uc3QgUmF3UmF5Q29sbGlkZXJJbnRlcnNlY3Rpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3cmF5Y29sbGlkZXJpbnRlcnNlY3Rpb25fZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdSYXlDb2xsaWRlckludGVyc2VjdGlvbiB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3UmF5Q29sbGlkZXJJbnRlcnNlY3Rpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3UmF5Q29sbGlkZXJJbnRlcnNlY3Rpb25GaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3UmF5Q29sbGlkZXJJbnRlcnNlY3Rpb25GaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd3JheWNvbGxpZGVyaW50ZXJzZWN0aW9uX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgY29sbGlkZXJIYW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fY29sbGlkZXJIYW5kbGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBub3JtYWwoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzaGFwZWNhc3RoaXRfd2l0bmVzczEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICB0aW1lX29mX2ltcGFjdCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNoYXBlY2FzdGhpdF90aW1lX29mX2ltcGFjdCh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd0ZlYXR1cmVUeXBlfVxuICAgICovXG4gICAgZmVhdHVyZVR5cGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fZmVhdHVyZVR5cGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBmZWF0dXJlSWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20ucmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fZmVhdHVyZUlkKHJldHB0ciwgdGhpcy5fX3diZ19wdHIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHIwID09PSAwID8gdW5kZWZpbmVkIDogcjEgPj4+IDA7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBSYXdSYXlJbnRlcnNlY3Rpb25GaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3cmF5aW50ZXJzZWN0aW9uX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3UmF5SW50ZXJzZWN0aW9uIHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdSYXlJbnRlcnNlY3Rpb24ucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3UmF5SW50ZXJzZWN0aW9uRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd1JheUludGVyc2VjdGlvbkZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3cmF5aW50ZXJzZWN0aW9uX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgbm9ybWFsKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2hhcGVjYXN0aGl0X3dpdG5lc3MxKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgdGltZV9vZl9pbXBhY3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzaGFwZWNhc3RoaXRfdGltZV9vZl9pbXBhY3QodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdGZWF0dXJlVHlwZX1cbiAgICAqL1xuICAgIGZlYXR1cmVUeXBlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX2ZlYXR1cmVUeXBlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgZmVhdHVyZUlkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICB3YXNtLnJhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX2ZlYXR1cmVJZChyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHJldHVybiByMCA9PT0gMCA/IHVuZGVmaW5lZCA6IHIxID4+PiAwO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgUmF3UmlnaWRCb2R5U2V0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Jhd3JpZ2lkYm9keXNldF9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd1JpZ2lkQm9keVNldCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3UmlnaWRCb2R5U2V0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFJhd1JpZ2lkQm9keVNldEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdSaWdpZEJvZHlTZXRGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd3JpZ2lkYm9keXNldF9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHdvcmxkLXNwYWNlIHRyYW5zbGF0aW9uIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICByYlRyYW5zbGF0aW9uKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlRyYW5zbGF0aW9uKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSB3b3JsZC1zcGFjZSBvcmllbnRhdGlvbiBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3Um90YXRpb259XG4gICAgKi9cbiAgICByYlJvdGF0aW9uKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlJvdGF0aW9uKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gUmF3Um90YXRpb24uX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogUHV0IHRoZSBnaXZlbiByaWdpZC1ib2R5IHRvIHNsZWVwLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICovXG4gICAgcmJTbGVlcChoYW5kbGUpIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJTbGVlcCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBJcyB0aGlzIHJpZ2lkLWJvZHkgc2xlZXBpbmc/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHJiSXNTbGVlcGluZyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJJc1NsZWVwaW5nKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIElzIHRoZSB2ZWxvY2l0eSBvZiB0aGlzIHJpZ2lkLWJvZHkgbm90IHplcm8/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHJiSXNNb3ZpbmcoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cmlnaWRib2R5c2V0X3JiSXNNb3ZpbmcodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHdvcmxkLXNwYWNlIHByZWRpY3RlZCB0cmFuc2xhdGlvbiBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKlxuICAgICogSWYgdGhpcyByaWdpZC1ib2R5IGlzIGtpbmVtYXRpYyB0aGlzIHZhbHVlIGlzIHNldCBieSB0aGUgYHNldE5leHRLaW5lbWF0aWNUcmFuc2xhdGlvbmBcbiAgICAqIG1ldGhvZCBhbmQgaXMgdXNlZCBmb3IgZXN0aW1hdGluZyB0aGUga2luZW1hdGljIGJvZHkgdmVsb2NpdHkgYXQgdGhlIG5leHQgdGltZXN0ZXAuXG4gICAgKiBGb3Igbm9uLWtpbmVtYXRpYyBib2RpZXMsIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IHVuc3BlY2lmaWVkLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHJiTmV4dFRyYW5zbGF0aW9uKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYk5leHRUcmFuc2xhdGlvbih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgd29ybGQtc3BhY2UgcHJlZGljdGVkIG9yaWVudGF0aW9uIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqXG4gICAgKiBJZiB0aGlzIHJpZ2lkLWJvZHkgaXMga2luZW1hdGljIHRoaXMgdmFsdWUgaXMgc2V0IGJ5IHRoZSBgc2V0TmV4dEtpbmVtYXRpY1JvdGF0aW9uYFxuICAgICogbWV0aG9kIGFuZCBpcyB1c2VkIGZvciBlc3RpbWF0aW5nIHRoZSBraW5lbWF0aWMgYm9keSB2ZWxvY2l0eSBhdCB0aGUgbmV4dCB0aW1lc3RlcC5cbiAgICAqIEZvciBub24ta2luZW1hdGljIGJvZGllcywgdGhpcyB2YWx1ZSBpcyBjdXJyZW50bHkgdW5zcGVjaWZpZWQuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3Um90YXRpb259XG4gICAgKi9cbiAgICByYk5leHRSb3RhdGlvbihoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJOZXh0Um90YXRpb24odGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdSb3RhdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIHRoZSB0cmFuc2xhdGlvbiBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGB4YDogdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIHRoZSByaWdpZC1ib2R5IGFsb25nIHRoZSBgeGAgYXhpcy5cbiAgICAqIC0gYHlgOiB0aGUgd29ybGQtc3BhY2UgcG9zaXRpb24gb2YgdGhlIHJpZ2lkLWJvZHkgYWxvbmcgdGhlIGB5YCBheGlzLlxuICAgICogLSBgd2FrZVVwYDogZm9yY2VzIHRoZSByaWdpZC1ib2R5IHRvIHdha2UtdXAgc28gaXQgaXMgcHJvcGVybHkgYWZmZWN0ZWQgYnkgZm9yY2VzIGlmIGl0XG4gICAgKiB3YXNuJ3QgbW92aW5nIGJlZm9yZSBtb2RpZnlpbmcgaXRzIHBvc2l0aW9uLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VVcFxuICAgICovXG4gICAgcmJTZXRUcmFuc2xhdGlvbihoYW5kbGUsIHgsIHksIHdha2VVcCkge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNldFRyYW5zbGF0aW9uKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIHgsIHksIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogU2V0cyB0aGUgcm90YXRpb24gYW5nbGUgb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICpcbiAgICAqICMgUGFyYW1ldGVyc1xuICAgICogLSBgYW5nbGVgOiB0aGUgcm90YXRpb24gYW5nbGUsIGluIHJhZGlhbnMuXG4gICAgKiAtIGB3YWtlVXBgOiBmb3JjZXMgdGhlIHJpZ2lkLWJvZHkgdG8gd2FrZS11cCBzbyBpdCBpcyBwcm9wZXJseSBhZmZlY3RlZCBieSBmb3JjZXMgaWYgaXRcbiAgICAqIHdhc24ndCBtb3ZpbmcgYmVmb3JlIG1vZGlmeWluZyBpdHMgcG9zaXRpb24uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FrZVVwXG4gICAgKi9cbiAgICByYlNldFJvdGF0aW9uKGhhbmRsZSwgYW5nbGUsIHdha2VVcCkge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNldFJvdGF0aW9uKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGFuZ2xlLCB3YWtlVXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHMgdGhlIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gbGludmVsXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VVcFxuICAgICovXG4gICAgcmJTZXRMaW52ZWwoaGFuZGxlLCBsaW52ZWwsIHdha2VVcCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MobGludmVsLCBSYXdWZWN0b3IpO1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNldExpbnZlbCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBsaW52ZWwuX193YmdfcHRyLCB3YWtlVXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHMgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ3ZlbFxuICAgICogQHBhcmFtIHtib29sZWFufSB3YWtlVXBcbiAgICAqL1xuICAgIHJiU2V0QW5ndmVsKGhhbmRsZSwgYW5ndmVsLCB3YWtlVXApIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJTZXRBbmd2ZWwodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgYW5ndmVsLCB3YWtlVXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIElmIHRoaXMgcmlnaWQgYm9keSBpcyBraW5lbWF0aWMsIHNldHMgaXRzIGZ1dHVyZSB0cmFuc2xhdGlvbiBhZnRlciB0aGUgbmV4dCB0aW1lc3RlcCBpbnRlZ3JhdGlvbi5cbiAgICAqXG4gICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgYHJpZ2lkQm9keS5zZXRUcmFuc2xhdGlvbmAgdG8gbWFrZSB0aGUgZHluYW1pYyBvYmplY3RcbiAgICAqIGludGVyYWN0aW5nIHdpdGggdGhpcyBraW5lbWF0aWMgYm9keSBiZWhhdmUgYXMgZXhwZWN0ZWQuIEludGVybmFsbHksIFJhcGllciB3aWxsIGNvbXB1dGVcbiAgICAqIGFuIGFydGlmaWNpYWwgdmVsb2NpdHkgZm9yIHRoaXMgcmlnaWQtYm9keSBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uIGFuZCBpdHMgbmV4dCBraW5lbWF0aWNcbiAgICAqIHBvc2l0aW9uLiBUaGlzIHZlbG9jaXR5IHdpbGwgYmUgdXNlZCB0byBjb21wdXRlIGZvcmNlcyBvbiBkeW5hbWljIGJvZGllcyBpbnRlcmFjdGluZyB3aXRoXG4gICAgKiB0aGlzIGJvZHkuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGB4YDogdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIHRoZSByaWdpZC1ib2R5IGFsb25nIHRoZSBgeGAgYXhpcy5cbiAgICAqIC0gYHlgOiB0aGUgd29ybGQtc3BhY2UgcG9zaXRpb24gb2YgdGhlIHJpZ2lkLWJvZHkgYWxvbmcgdGhlIGB5YCBheGlzLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgKi9cbiAgICByYlNldE5leHRLaW5lbWF0aWNUcmFuc2xhdGlvbihoYW5kbGUsIHgsIHkpIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJTZXROZXh0S2luZW1hdGljVHJhbnNsYXRpb24odGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgeCwgeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogSWYgdGhpcyByaWdpZCBib2R5IGlzIGtpbmVtYXRpYywgc2V0cyBpdHMgZnV0dXJlIHJvdGF0aW9uIGFmdGVyIHRoZSBuZXh0IHRpbWVzdGVwIGludGVncmF0aW9uLlxuICAgICpcbiAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCBvZiBgcmlnaWRCb2R5LnNldFJvdGF0aW9uYCB0byBtYWtlIHRoZSBkeW5hbWljIG9iamVjdFxuICAgICogaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIGtpbmVtYXRpYyBib2R5IGJlaGF2ZSBhcyBleHBlY3RlZC4gSW50ZXJuYWxseSwgUmFwaWVyIHdpbGwgY29tcHV0ZVxuICAgICogYW4gYXJ0aWZpY2lhbCB2ZWxvY2l0eSBmb3IgdGhpcyByaWdpZC1ib2R5IGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24gYW5kIGl0cyBuZXh0IGtpbmVtYXRpY1xuICAgICogcG9zaXRpb24uIFRoaXMgdmVsb2NpdHkgd2lsbCBiZSB1c2VkIHRvIGNvbXB1dGUgZm9yY2VzIG9uIGR5bmFtaWMgYm9kaWVzIGludGVyYWN0aW5nIHdpdGhcbiAgICAqIHRoaXMgYm9keS5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYGFuZ2xlYDogdGhlIHJvdGF0aW9uIGFuZ2xlLCBpbiByYWRpYW5zLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgKi9cbiAgICByYlNldE5leHRLaW5lbWF0aWNSb3RhdGlvbihoYW5kbGUsIGFuZ2xlKSB7XG4gICAgICAgIHdhc20ucmF3cmlnaWRib2R5c2V0X3JiU2V0TmV4dEtpbmVtYXRpY1JvdGF0aW9uKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGFuZ2xlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd0NvbGxpZGVyU2V0fSBjb2xsaWRlcnNcbiAgICAqL1xuICAgIHJiUmVjb21wdXRlTWFzc1Byb3BlcnRpZXNGcm9tQ29sbGlkZXJzKGhhbmRsZSwgY29sbGlkZXJzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJSZWNvbXB1dGVNYXNzUHJvcGVydGllc0Zyb21Db2xsaWRlcnModGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgY29sbGlkZXJzLl9fd2JnX3B0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc3NcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FrZV91cFxuICAgICovXG4gICAgcmJTZXRBZGRpdGlvbmFsTWFzcyhoYW5kbGUsIG1hc3MsIHdha2VfdXApIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJTZXRBZGRpdGlvbmFsTWFzcyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBtYXNzLCB3YWtlX3VwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWFzc1xuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IGNlbnRlck9mTWFzc1xuICAgICogQHBhcmFtIHtudW1iZXJ9IHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VfdXBcbiAgICAqL1xuICAgIHJiU2V0QWRkaXRpb25hbE1hc3NQcm9wZXJ0aWVzKGhhbmRsZSwgbWFzcywgY2VudGVyT2ZNYXNzLCBwcmluY2lwYWxBbmd1bGFySW5lcnRpYSwgd2FrZV91cCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY2VudGVyT2ZNYXNzLCBSYXdWZWN0b3IpO1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNldEFkZGl0aW9uYWxNYXNzUHJvcGVydGllcyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBtYXNzLCBjZW50ZXJPZk1hc3MuX193YmdfcHRyLCBwcmluY2lwYWxBbmd1bGFySW5lcnRpYSwgd2FrZV91cCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgcmJMaW52ZWwoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cmlnaWRib2R5c2V0X3JiTGludmVsKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICByYkFuZ3ZlbChoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJBbmd2ZWwodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtib29sZWFufSBsb2NrZWRcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FrZV91cFxuICAgICovXG4gICAgcmJMb2NrVHJhbnNsYXRpb25zKGhhbmRsZSwgbG9ja2VkLCB3YWtlX3VwKSB7XG4gICAgICAgIHdhc20ucmF3cmlnaWRib2R5c2V0X3JiTG9ja1RyYW5zbGF0aW9ucyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBsb2NrZWQsIHdha2VfdXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dfeFxuICAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd195XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VfdXBcbiAgICAqL1xuICAgIHJiU2V0RW5hYmxlZFRyYW5zbGF0aW9ucyhoYW5kbGUsIGFsbG93X3gsIGFsbG93X3ksIHdha2VfdXApIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJTZXRFbmFibGVkVHJhbnNsYXRpb25zKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGFsbG93X3gsIGFsbG93X3ksIHdha2VfdXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9ja2VkXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VfdXBcbiAgICAqL1xuICAgIHJiTG9ja1JvdGF0aW9ucyhoYW5kbGUsIGxvY2tlZCwgd2FrZV91cCkge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkxvY2tSb3RhdGlvbnModGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgbG9ja2VkLCB3YWtlX3VwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgcmJEb21pbmFuY2VHcm91cChoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJEb21pbmFuY2VHcm91cCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBcbiAgICAqL1xuICAgIHJiU2V0RG9taW5hbmNlR3JvdXAoaGFuZGxlLCBncm91cCkge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNldERvbWluYW5jZUdyb3VwKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGdyb3VwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAqL1xuICAgIHJiRW5hYmxlQ2NkKGhhbmRsZSwgZW5hYmxlZCkge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkVuYWJsZUNjZCh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBlbmFibGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcHJlZGljdGlvblxuICAgICovXG4gICAgcmJTZXRTb2Z0Q2NkUHJlZGljdGlvbihoYW5kbGUsIHByZWRpY3Rpb24pIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJTZXRTb2Z0Q2NkUHJlZGljdGlvbih0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBwcmVkaWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgbWFzcyBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgcmJNYXNzKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYk1hc3ModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGludmVyc2Ugb2YgdGhlIG1hc3Mgb2YgYSByaWdpZC1ib2R5LlxuICAgICpcbiAgICAqIElmIHRoaXMgaXMgemVybywgdGhlIHJpZ2lkLWJvZHkgaXMgYXNzdW1lZCB0byBoYXZlIGluZmluaXRlIG1hc3MuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgcmJJbnZNYXNzKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkludk1hc3ModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGludmVyc2UgbWFzcyB0YWtpbmcgaW50byBhY2NvdW50IHRyYW5zbGF0aW9uIGxvY2tpbmcuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgcmJFZmZlY3RpdmVJbnZNYXNzKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkVmZmVjdGl2ZUludk1hc3ModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGNlbnRlciBvZiBtYXNzIG9mIGEgcmlnaWQtYm9keSBleHByZXNzZWQgaW4gaXRzIGxvY2FsLXNwYWNlLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHJiTG9jYWxDb20oaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cmlnaWRib2R5c2V0X3JiTG9jYWxDb20odGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHdvcmxkLXNwYWNlIGNlbnRlciBvZiBtYXNzIG9mIHRoZSByaWdpZC1ib2R5LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHJiV29ybGRDb20oaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cmlnaWRib2R5c2V0X3JiV29ybGRDb20odGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGludmVyc2Ugb2YgdGhlIHByaW5jaXBhbCBhbmd1bGFyIGluZXJ0aWEgb2YgdGhlIHJpZ2lkLWJvZHkuXG4gICAgKlxuICAgICogQ29tcG9uZW50cyBzZXQgdG8gemVybyBhcmUgYXNzdW1lZCB0byBiZSBpbmZpbml0ZSBhbG9uZyB0aGUgY29ycmVzcG9uZGluZyBwcmluY2lwYWwgYXhpcy5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICByYkludlByaW5jaXBhbEluZXJ0aWFTcXJ0KGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkludlByaW5jaXBhbEluZXJ0aWFTcXJ0KHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBhbmd1bGFyIGluZXJ0aWEgYWxvbmcgdGhlIHByaW5jaXBhbCBpbmVydGlhIGF4ZXMgb2YgdGhlIHJpZ2lkLWJvZHkuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgcmJQcmluY2lwYWxJbmVydGlhKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlByaW5jaXBhbEluZXJ0aWEodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIHNxdWFyZS1yb290IG9mIHRoZSB3b3JsZC1zcGFjZSBpbnZlcnNlIGFuZ3VsYXIgaW5lcnRpYSB0ZW5zb3Igb2YgdGhlIHJpZ2lkLWJvZHksXG4gICAgKiB0YWtpbmcgaW50byBhY2NvdW50IHJvdGF0aW9uIGxvY2tpbmcuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgcmJFZmZlY3RpdmVXb3JsZEludkluZXJ0aWFTcXJ0KGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkVmZmVjdGl2ZVdvcmxkSW52SW5lcnRpYVNxcnQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGVmZmVjdGl2ZSB3b3JsZC1zcGFjZSBhbmd1bGFyIGluZXJ0aWEgKHRoYXQgdGFrZXMgdGhlIHBvdGVudGlhbCByb3RhdGlvbiBsb2NraW5nIGludG8gYWNjb3VudCkgb2ZcbiAgICAqIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICByYkVmZmVjdGl2ZUFuZ3VsYXJJbmVydGlhKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkVmZmVjdGl2ZUFuZ3VsYXJJbmVydGlhKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFdha2VzIHRoaXMgcmlnaWQtYm9keSB1cC5cbiAgICAqXG4gICAgKiBBIGR5bmFtaWMgcmlnaWQtYm9keSB0aGF0IGRvZXMgbm90IG1vdmUgZHVyaW5nIHNldmVyYWwgY29uc2VjdXRpdmUgZnJhbWVzIHdpbGxcbiAgICAqIGJlIHB1dCB0byBzbGVlcCBieSB0aGUgcGh5c2ljcyBlbmdpbmUsIGkuZS4sIGl0IHdpbGwgc3RvcCBiZWluZyBzaW11bGF0ZWQgaW4gb3JkZXJcbiAgICAqIHRvIGF2b2lkIHVzZWxlc3MgY29tcHV0YXRpb25zLlxuICAgICogVGhpcyBtZXRob2QgZm9yY2VzIGEgc2xlZXBpbmcgcmlnaWQtYm9keSB0byB3YWtlLXVwLiBUaGlzIGlzIHVzZWZ1bCwgZS5nLiwgYmVmb3JlIG1vZGlmeWluZ1xuICAgICogdGhlIHBvc2l0aW9uIG9mIGEgZHluYW1pYyBib2R5IHNvIHRoYXQgaXQgaXMgcHJvcGVybHkgc2ltdWxhdGVkIGFmdGVyd2FyZHMuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKi9cbiAgICByYldha2VVcChoYW5kbGUpIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJXYWtlVXAodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogSXMgQ29udGludW91cyBDb2xsaXNpb24gRGV0ZWN0aW9uIGVuYWJsZWQgZm9yIHRoaXMgcmlnaWQtYm9keT9cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgcmJJc0NjZEVuYWJsZWQoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cmlnaWRib2R5c2V0X3JiSXNDY2RFbmFibGVkKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICByYlNvZnRDY2RQcmVkaWN0aW9uKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNvZnRDY2RQcmVkaWN0aW9uKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBudW1iZXIgb2YgY29sbGlkZXJzIGF0dGFjaGVkIHRvIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICByYk51bUNvbGxpZGVycyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJOdW1Db2xsaWRlcnModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgPj4+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0cmlldmVzIHRoZSBgaS10aGAgY29sbGlkZXIgYXR0YWNoZWQgdG8gdGhpcyByaWdpZC1ib2R5LlxuICAgICpcbiAgICAqICMgUGFyYW1ldGVyc1xuICAgICogLSBgYXRgOiBUaGUgaW5kZXggb2YgdGhlIGNvbGxpZGVyIHRvIHJldHJpZXZlLiBNdXN0IGJlIGEgbnVtYmVyIGluIGBbMCwgdGhpcy5udW1Db2xsaWRlcnMoKVtgLlxuICAgICogICAgICAgICBUaGlzIGluZGV4IGlzICoqbm90KiogdGhlIHNhbWUgYXMgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2xsaWRlci5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdFxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIHJiQ29sbGlkZXIoaGFuZGxlLCBhdCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkNvbGxpZGVyKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGF0KTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgc3RhdHVzIG9mIHRoaXMgcmlnaWQtYm9keTogZml4ZWQsIGR5bmFtaWMsIG9yIGtpbmVtYXRpYy5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtSYXdSaWdpZEJvZHlUeXBlfVxuICAgICovXG4gICAgcmJCb2R5VHlwZShoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJCb2R5VHlwZSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXQgYSBuZXcgc3RhdHVzIGZvciB0aGlzIHJpZ2lkLWJvZHk6IGZpeGVkLCBkeW5hbWljLCBvciBraW5lbWF0aWMuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd1JpZ2lkQm9keVR5cGV9IHN0YXR1c1xuICAgICogQHBhcmFtIHtib29sZWFufSB3YWtlX3VwXG4gICAgKi9cbiAgICByYlNldEJvZHlUeXBlKGhhbmRsZSwgc3RhdHVzLCB3YWtlX3VwKSB7XG4gICAgICAgIHdhc20ucmF3cmlnaWRib2R5c2V0X3JiU2V0Qm9keVR5cGUodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgc3RhdHVzLCB3YWtlX3VwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBJcyB0aGlzIHJpZ2lkLWJvZHkgZml4ZWQ/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHJiSXNGaXhlZChoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJJc0ZpeGVkKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIElzIHRoaXMgcmlnaWQtYm9keSBraW5lbWF0aWM/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHJiSXNLaW5lbWF0aWMoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cmlnaWRib2R5c2V0X3JiSXNLaW5lbWF0aWModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogSXMgdGhpcyByaWdpZC1ib2R5IGR5bmFtaWM/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHJiSXNEeW5hbWljKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYklzRHluYW1pYyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgbGluZWFyIGRhbXBpbmcgY29lZmZpY2llbnQgb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIHJiTGluZWFyRGFtcGluZyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJMaW5lYXJEYW1waW5nKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBhbmd1bGFyIGRhbXBpbmcgY29lZmZpY2llbnQgb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIHJiQW5ndWxhckRhbXBpbmcoaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cmlnaWRib2R5c2V0X3JiQW5ndWxhckRhbXBpbmcodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvclxuICAgICovXG4gICAgcmJTZXRMaW5lYXJEYW1waW5nKGhhbmRsZSwgZmFjdG9yKSB7XG4gICAgICAgIHdhc20ucmF3cmlnaWRib2R5c2V0X3JiU2V0TGluZWFyRGFtcGluZyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBmYWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3JcbiAgICAqL1xuICAgIHJiU2V0QW5ndWxhckRhbXBpbmcoaGFuZGxlLCBmYWN0b3IpIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJTZXRBbmd1bGFyRGFtcGluZyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBmYWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICovXG4gICAgcmJTZXRFbmFibGVkKGhhbmRsZSwgZW5hYmxlZCkge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNldEVuYWJsZWQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgZW5hYmxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICByYklzRW5hYmxlZChoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJJc0VuYWJsZWQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIHJiR3Jhdml0eVNjYWxlKGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkdyYXZpdHlTY2FsZSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VVcFxuICAgICovXG4gICAgcmJTZXRHcmF2aXR5U2NhbGUoaGFuZGxlLCBmYWN0b3IsIHdha2VVcCkge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNldEdyYXZpdHlTY2FsZSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBmYWN0b3IsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmVzZXRzIHRvIHplcm8gYWxsIHVzZXItYWRkZWQgZm9yY2VzIGFkZGVkIHRvIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FrZVVwXG4gICAgKi9cbiAgICByYlJlc2V0Rm9yY2VzKGhhbmRsZSwgd2FrZVVwKSB7XG4gICAgICAgIHdhc20ucmF3cmlnaWRib2R5c2V0X3JiUmVzZXRGb3JjZXModGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgd2FrZVVwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXNldHMgdG8gemVybyBhbGwgdXNlci1hZGRlZCB0b3JxdWVzIGFkZGVkIHRvIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FrZVVwXG4gICAgKi9cbiAgICByYlJlc2V0VG9ycXVlcyhoYW5kbGUsIHdha2VVcCkge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlJlc2V0VG9ycXVlcyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCB3YWtlVXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFkZHMgYSBmb3JjZSBhdCB0aGUgY2VudGVyLW9mLW1hc3Mgb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICpcbiAgICAqICMgUGFyYW1ldGVyc1xuICAgICogLSBgZm9yY2VgOiB0aGUgd29ybGQtc3BhY2UgZm9yY2UgdG8gYXBwbHkgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgKiAtIGB3YWtlVXBgOiBzaG91bGQgdGhlIHJpZ2lkLWJvZHkgYmUgYXV0b21hdGljYWxseSB3b2tlbi11cD9cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBmb3JjZVxuICAgICogQHBhcmFtIHtib29sZWFufSB3YWtlVXBcbiAgICAqL1xuICAgIHJiQWRkRm9yY2UoaGFuZGxlLCBmb3JjZSwgd2FrZVVwKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhmb3JjZSwgUmF3VmVjdG9yKTtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJBZGRGb3JjZSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBmb3JjZS5fX3diZ19wdHIsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyBhbiBpbXB1bHNlIGF0IHRoZSBjZW50ZXItb2YtbWFzcyBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGBpbXB1bHNlYDogdGhlIHdvcmxkLXNwYWNlIGltcHVsc2UgdG8gYXBwbHkgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgKiAtIGB3YWtlVXBgOiBzaG91bGQgdGhlIHJpZ2lkLWJvZHkgYmUgYXV0b21hdGljYWxseSB3b2tlbi11cD9cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBpbXB1bHNlXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VVcFxuICAgICovXG4gICAgcmJBcHBseUltcHVsc2UoaGFuZGxlLCBpbXB1bHNlLCB3YWtlVXApIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGltcHVsc2UsIFJhd1ZlY3Rvcik7XG4gICAgICAgIHdhc20ucmF3cmlnaWRib2R5c2V0X3JiQXBwbHlJbXB1bHNlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGltcHVsc2UuX193YmdfcHRyLCB3YWtlVXApO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFkZHMgYSB0b3JxdWUgYXQgdGhlIGNlbnRlci1vZi1tYXNzIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYHRvcnF1ZWA6IHRoZSB0b3JxdWUgdG8gYXBwbHkgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgKiAtIGB3YWtlVXBgOiBzaG91bGQgdGhlIHJpZ2lkLWJvZHkgYmUgYXV0b21hdGljYWxseSB3b2tlbi11cD9cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3JxdWVcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FrZVVwXG4gICAgKi9cbiAgICByYkFkZFRvcnF1ZShoYW5kbGUsIHRvcnF1ZSwgd2FrZVVwKSB7XG4gICAgICAgIHdhc20ucmF3cmlnaWRib2R5c2V0X3JiQWRkVG9ycXVlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIHRvcnF1ZSwgd2FrZVVwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBcHBsaWVzIGFuIGltcHVsc2l2ZSB0b3JxdWUgYXQgdGhlIGNlbnRlci1vZi1tYXNzIG9mIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqXG4gICAgKiAjIFBhcmFtZXRlcnNcbiAgICAqIC0gYHRvcnF1ZSBpbXB1bHNlYDogdGhlIHRvcnF1ZSBpbXB1bHNlIHRvIGFwcGx5IG9uIHRoZSByaWdpZC1ib2R5LlxuICAgICogLSBgd2FrZVVwYDogc2hvdWxkIHRoZSByaWdpZC1ib2R5IGJlIGF1dG9tYXRpY2FsbHkgd29rZW4tdXA/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gdG9ycXVlX2ltcHVsc2VcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2FrZVVwXG4gICAgKi9cbiAgICByYkFwcGx5VG9ycXVlSW1wdWxzZShoYW5kbGUsIHRvcnF1ZV9pbXB1bHNlLCB3YWtlVXApIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJBcHBseVRvcnF1ZUltcHVsc2UodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgdG9ycXVlX2ltcHVsc2UsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQWRkcyBhIGZvcmNlIGF0IHRoZSBnaXZlbiB3b3JsZC1zcGFjZSBwb2ludCBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGBmb3JjZWA6IHRoZSB3b3JsZC1zcGFjZSBmb3JjZSB0byBhcHBseSBvbiB0aGUgcmlnaWQtYm9keS5cbiAgICAqIC0gYHBvaW50YDogdGhlIHdvcmxkLXNwYWNlIHBvaW50IHdoZXJlIHRoZSBpbXB1bHNlIGlzIHRvIGJlIGFwcGxpZWQgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgKiAtIGB3YWtlVXBgOiBzaG91bGQgdGhlIHJpZ2lkLWJvZHkgYmUgYXV0b21hdGljYWxseSB3b2tlbi11cD9cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBmb3JjZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHBvaW50XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VVcFxuICAgICovXG4gICAgcmJBZGRGb3JjZUF0UG9pbnQoaGFuZGxlLCBmb3JjZSwgcG9pbnQsIHdha2VVcCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoZm9yY2UsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwb2ludCwgUmF3VmVjdG9yKTtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJBZGRGb3JjZUF0UG9pbnQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgZm9yY2UuX193YmdfcHRyLCBwb2ludC5fX3diZ19wdHIsIHdha2VVcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyBhbiBpbXB1bHNlIGF0IHRoZSBnaXZlbiB3b3JsZC1zcGFjZSBwb2ludCBvZiB0aGlzIHJpZ2lkLWJvZHkuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGBpbXB1bHNlYDogdGhlIHdvcmxkLXNwYWNlIGltcHVsc2UgdG8gYXBwbHkgb24gdGhlIHJpZ2lkLWJvZHkuXG4gICAgKiAtIGBwb2ludGA6IHRoZSB3b3JsZC1zcGFjZSBwb2ludCB3aGVyZSB0aGUgaW1wdWxzZSBpcyB0byBiZSBhcHBsaWVkIG9uIHRoZSByaWdpZC1ib2R5LlxuICAgICogLSBgd2FrZVVwYDogc2hvdWxkIHRoZSByaWdpZC1ib2R5IGJlIGF1dG9tYXRpY2FsbHkgd29rZW4tdXA/XG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gaW1wdWxzZVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHBvaW50XG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdha2VVcFxuICAgICovXG4gICAgcmJBcHBseUltcHVsc2VBdFBvaW50KGhhbmRsZSwgaW1wdWxzZSwgcG9pbnQsIHdha2VVcCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaW1wdWxzZSwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHBvaW50LCBSYXdWZWN0b3IpO1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYkFwcGx5SW1wdWxzZUF0UG9pbnQodGhpcy5fX3diZ19wdHIsIGhhbmRsZSwgaW1wdWxzZS5fX3diZ19wdHIsIHBvaW50Ll9fd2JnX3B0ciwgd2FrZVVwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgcmJBZGRpdGlvbmFsU29sdmVySXRlcmF0aW9ucyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJBZGRpdGlvbmFsU29sdmVySXRlcmF0aW9ucyh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaXRlcnNcbiAgICAqL1xuICAgIHJiU2V0QWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnMoaGFuZGxlLCBpdGVycykge1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9yYlNldEFkZGl0aW9uYWxTb2x2ZXJJdGVyYXRpb25zKHRoaXMuX193YmdfcHRyLCBoYW5kbGUsIGl0ZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBBbiBhcmJpdHJhcnkgdXNlci1kZWZpbmVkIDMyLWJpdCBpbnRlZ2VyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgcmJVc2VyRGF0YShoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJVc2VyRGF0YSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIHJldCA+Pj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIHRoZSB1c2VyLWRlZmluZWQgMzItYml0IGludGVnZXIgb2YgdGhpcyByaWdpZC1ib2R5LlxuICAgICpcbiAgICAqICMgUGFyYW1ldGVyc1xuICAgICogLSBgZGF0YWA6IGFuIGFyYml0cmFyeSB1c2VyLWRlZmluZWQgMzItYml0IGludGVnZXIuXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge251bWJlcn0gZGF0YVxuICAgICovXG4gICAgcmJTZXRVc2VyRGF0YShoYW5kbGUsIGRhdGEpIHtcbiAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJTZXRVc2VyRGF0YSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXRyaWV2ZXMgdGhlIGNvbnN0YW50IGZvcmNlKHMpIHRoZSB1c2VyIGFkZGVkIHRvIHRoaXMgcmlnaWQtYm9keS5cbiAgICAqIFJldHVybnMgemVybyBpZiB0aGUgcmlnaWQtYm9keSBpcyBub3QgZHluYW1pYy5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGVcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICByYlVzZXJGb3JjZShoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJVc2VyRm9yY2UodGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0cmlldmVzIHRoZSBjb25zdGFudCB0b3JxdWUocykgdGhlIHVzZXIgYWRkZWQgdG8gdGhpcyByaWdpZC1ib2R5LlxuICAgICogUmV0dXJucyB6ZXJvIGlmIHRoZSByaWdpZC1ib2R5IGlzIG5vdCBkeW5hbWljLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIHJiVXNlclRvcnF1ZShoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfcmJVc2VyVG9ycXVlKHRoaXMuX193YmdfcHRyLCBoYW5kbGUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JpZ2lkYm9keXNldF9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHRyYW5zbGF0aW9uXG4gICAgKiBAcGFyYW0ge1Jhd1JvdGF0aW9ufSByb3RhdGlvblxuICAgICogQHBhcmFtIHtudW1iZXJ9IGdyYXZpdHlTY2FsZVxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1hc3NcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbWFzc09ubHlcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBjZW50ZXJPZk1hc3NcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBsaW52ZWxcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmd2ZWxcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmluY2lwYWxBbmd1bGFySW5lcnRpYVxuICAgICogQHBhcmFtIHtib29sZWFufSB0cmFuc2xhdGlvbkVuYWJsZWRYXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYW5zbGF0aW9uRW5hYmxlZFlcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcm90YXRpb25zRW5hYmxlZFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVhckRhbXBpbmdcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmd1bGFyRGFtcGluZ1xuICAgICogQHBhcmFtIHtSYXdSaWdpZEJvZHlUeXBlfSByYl90eXBlXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblNsZWVwXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNsZWVwaW5nXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc29mdENjZFByZWRpY2l0b25cbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2NkRW5hYmxlZFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGRvbWluYW5jZUdyb3VwXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYWRkaXRpb25hbF9zb2x2ZXJfaXRlcmF0aW9uc1xuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGNyZWF0ZVJpZ2lkQm9keShlbmFibGVkLCB0cmFuc2xhdGlvbiwgcm90YXRpb24sIGdyYXZpdHlTY2FsZSwgbWFzcywgbWFzc09ubHksIGNlbnRlck9mTWFzcywgbGludmVsLCBhbmd2ZWwsIHByaW5jaXBhbEFuZ3VsYXJJbmVydGlhLCB0cmFuc2xhdGlvbkVuYWJsZWRYLCB0cmFuc2xhdGlvbkVuYWJsZWRZLCByb3RhdGlvbnNFbmFibGVkLCBsaW5lYXJEYW1waW5nLCBhbmd1bGFyRGFtcGluZywgcmJfdHlwZSwgY2FuU2xlZXAsIHNsZWVwaW5nLCBzb2Z0Q2NkUHJlZGljaXRvbiwgY2NkRW5hYmxlZCwgZG9taW5hbmNlR3JvdXAsIGFkZGl0aW9uYWxfc29sdmVyX2l0ZXJhdGlvbnMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHRyYW5zbGF0aW9uLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mocm90YXRpb24sIFJhd1JvdGF0aW9uKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNlbnRlck9mTWFzcywgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGxpbnZlbCwgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfY3JlYXRlUmlnaWRCb2R5KHRoaXMuX193YmdfcHRyLCBlbmFibGVkLCB0cmFuc2xhdGlvbi5fX3diZ19wdHIsIHJvdGF0aW9uLl9fd2JnX3B0ciwgZ3Jhdml0eVNjYWxlLCBtYXNzLCBtYXNzT25seSwgY2VudGVyT2ZNYXNzLl9fd2JnX3B0ciwgbGludmVsLl9fd2JnX3B0ciwgYW5ndmVsLCBwcmluY2lwYWxBbmd1bGFySW5lcnRpYSwgdHJhbnNsYXRpb25FbmFibGVkWCwgdHJhbnNsYXRpb25FbmFibGVkWSwgcm90YXRpb25zRW5hYmxlZCwgbGluZWFyRGFtcGluZywgYW5ndWxhckRhbXBpbmcsIHJiX3R5cGUsIGNhblNsZWVwLCBzbGVlcGluZywgc29mdENjZFByZWRpY2l0b24sIGNjZEVuYWJsZWQsIGRvbWluYW5jZUdyb3VwLCBhZGRpdGlvbmFsX3NvbHZlcl9pdGVyYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlXG4gICAgKiBAcGFyYW0ge1Jhd0lzbGFuZE1hbmFnZXJ9IGlzbGFuZHNcbiAgICAqIEBwYXJhbSB7UmF3Q29sbGlkZXJTZXR9IGNvbGxpZGVyc1xuICAgICogQHBhcmFtIHtSYXdJbXB1bHNlSm9pbnRTZXR9IGpvaW50c1xuICAgICogQHBhcmFtIHtSYXdNdWx0aWJvZHlKb2ludFNldH0gYXJ0aWN1bGF0aW9uc1xuICAgICovXG4gICAgcmVtb3ZlKGhhbmRsZSwgaXNsYW5kcywgY29sbGlkZXJzLCBqb2ludHMsIGFydGljdWxhdGlvbnMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGlzbGFuZHMsIFJhd0lzbGFuZE1hbmFnZXIpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoY29sbGlkZXJzLCBSYXdDb2xsaWRlclNldCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhqb2ludHMsIFJhd0ltcHVsc2VKb2ludFNldCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhhcnRpY3VsYXRpb25zLCBSYXdNdWx0aWJvZHlKb2ludFNldCk7XG4gICAgICAgIHdhc20ucmF3cmlnaWRib2R5c2V0X3JlbW92ZSh0aGlzLl9fd2JnX3B0ciwgaGFuZGxlLCBpc2xhbmRzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0ciwgam9pbnRzLl9fd2JnX3B0ciwgYXJ0aWN1bGF0aW9ucy5fX3diZ19wdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFRoZSBudW1iZXIgb2YgcmlnaWQtYm9kaWVzIG9uIHRoaXMgc2V0LlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGxlbigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNldF9sZW4odGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ID4+PiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIENoZWNrcyBpZiBhIHJpZ2lkLWJvZHkgd2l0aCB0aGUgZ2l2ZW4gaW50ZWdlciBoYW5kbGUgZXhpc3RzLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZVxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBjb250YWlucyhoYW5kbGUpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdyaWdpZGJvZHlzZXRfY29udGFpbnModGhpcy5fX3diZ19wdHIsIGhhbmRsZSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQXBwbGllcyB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBmdW5jdGlvbiB0byB0aGUgaW50ZWdlciBoYW5kbGUgb2YgZWFjaCByaWdpZC1ib2R5IG1hbmFnZWQgYnkgdGhpcyBzZXQuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGBmKGhhbmRsZSlgOiB0aGUgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGludGVnZXIgaGFuZGxlIG9mIGVhY2ggcmlnaWQtYm9keSBtYW5hZ2VkIGJ5IHRoaXMgc2V0LiBDYWxsZWQgYXMgYGYoY29sbGlkZXIpYC5cbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICAqL1xuICAgIGZvckVhY2hSaWdpZEJvZHlIYW5kbGUoZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2FzbS5yYXdyaWdpZGJvZHlzZXRfZm9yRWFjaFJpZ2lkQm9keUhhbmRsZSh0aGlzLl9fd2JnX3B0ciwgYWRkQm9ycm93ZWRPYmplY3QoZikpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaGVhcFtzdGFja19wb2ludGVyKytdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdDb2xsaWRlclNldH0gY29sbGlkZXJzXG4gICAgKi9cbiAgICBwcm9wYWdhdGVNb2RpZmllZEJvZHlQb3NpdGlvbnNUb0NvbGxpZGVycyhjb2xsaWRlcnMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKGNvbGxpZGVycywgUmF3Q29sbGlkZXJTZXQpO1xuICAgICAgICB3YXNtLnJhd3JpZ2lkYm9keXNldF9wcm9wYWdhdGVNb2RpZmllZEJvZHlQb3NpdGlvbnNUb0NvbGxpZGVycyh0aGlzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0cik7XG4gICAgfVxufVxuXG5jb25zdCBSYXdSb3RhdGlvbkZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19yYXdyb3RhdGlvbl9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qIEEgcm90YXRpb24gcXVhdGVybmlvbi5cbiovXG5leHBvcnQgY2xhc3MgUmF3Um90YXRpb24ge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJhd1JvdGF0aW9uLnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFJhd1JvdGF0aW9uRmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd1JvdGF0aW9uRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXdyb3RhdGlvbl9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGlkZW50aXR5IHJvdGF0aW9uLlxuICAgICogQHJldHVybnMge1Jhd1JvdGF0aW9ufVxuICAgICovXG4gICAgc3RhdGljIGlkZW50aXR5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JvdGF0aW9uX2lkZW50aXR5KCk7XG4gICAgICAgIHJldHVybiBSYXdSb3RhdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgcm90YXRpb24gd2l0aCB0aGVnaXZlbiBhbmdsZS5cbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICogQHJldHVybnMge1Jhd1JvdGF0aW9ufVxuICAgICovXG4gICAgc3RhdGljIGZyb21BbmdsZShhbmdsZSkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JvdGF0aW9uX2Zyb21BbmdsZShhbmdsZSk7XG4gICAgICAgIHJldHVybiBSYXdSb3RhdGlvbi5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgaW1hZ2luYXJ5IHBhcnQgb2YgdGhpcyBjb21wbGV4IG51bWJlci5cbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBnZXQgaW0oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2R0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgcmVhbCBwYXJ0IG9mIHRoaXMgY29tcGxleCBudW1iZXIuXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IHJlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3JvdGF0aW9uX3JlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBUaGUgcm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBnZXQgYW5nbGUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cm90YXRpb25fYW5nbGUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuY29uc3QgUmF3U2VyaWFsaXphdGlvblBpcGVsaW5lRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Jhd3NlcmlhbGl6YXRpb25waXBlbGluZV9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd1NlcmlhbGl6YXRpb25QaXBlbGluZSB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd1NlcmlhbGl6YXRpb25QaXBlbGluZUZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3c2VyaWFsaXphdGlvbnBpcGVsaW5lX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzZXJpYWxpemF0aW9ucGlwZWxpbmVfbmV3KCk7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gcmV0ID4+PiAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gZ3Jhdml0eVxuICAgICogQHBhcmFtIHtSYXdJbnRlZ3JhdGlvblBhcmFtZXRlcnN9IGludGVncmF0aW9uUGFyYW1ldGVyc1xuICAgICogQHBhcmFtIHtSYXdJc2xhbmRNYW5hZ2VyfSBpc2xhbmRzXG4gICAgKiBAcGFyYW0ge1Jhd0Jyb2FkUGhhc2V9IGJyb2FkUGhhc2VcbiAgICAqIEBwYXJhbSB7UmF3TmFycm93UGhhc2V9IG5hcnJvd1BoYXNlXG4gICAgKiBAcGFyYW0ge1Jhd1JpZ2lkQm9keVNldH0gYm9kaWVzXG4gICAgKiBAcGFyYW0ge1Jhd0NvbGxpZGVyU2V0fSBjb2xsaWRlcnNcbiAgICAqIEBwYXJhbSB7UmF3SW1wdWxzZUpvaW50U2V0fSBpbXB1bHNlX2pvaW50c1xuICAgICogQHBhcmFtIHtSYXdNdWx0aWJvZHlKb2ludFNldH0gbXVsdGlib2R5X2pvaW50c1xuICAgICogQHJldHVybnMge1VpbnQ4QXJyYXkgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBzZXJpYWxpemVBbGwoZ3Jhdml0eSwgaW50ZWdyYXRpb25QYXJhbWV0ZXJzLCBpc2xhbmRzLCBicm9hZFBoYXNlLCBuYXJyb3dQaGFzZSwgYm9kaWVzLCBjb2xsaWRlcnMsIGltcHVsc2Vfam9pbnRzLCBtdWx0aWJvZHlfam9pbnRzKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhncmF2aXR5LCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaW50ZWdyYXRpb25QYXJhbWV0ZXJzLCBSYXdJbnRlZ3JhdGlvblBhcmFtZXRlcnMpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MoaXNsYW5kcywgUmF3SXNsYW5kTWFuYWdlcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhicm9hZFBoYXNlLCBSYXdCcm9hZFBoYXNlKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKG5hcnJvd1BoYXNlLCBSYXdOYXJyb3dQaGFzZSk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhib2RpZXMsIFJhd1JpZ2lkQm9keVNldCk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhjb2xsaWRlcnMsIFJhd0NvbGxpZGVyU2V0KTtcbiAgICAgICAgX2Fzc2VydENsYXNzKGltcHVsc2Vfam9pbnRzLCBSYXdJbXB1bHNlSm9pbnRTZXQpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MobXVsdGlib2R5X2pvaW50cywgUmF3TXVsdGlib2R5Sm9pbnRTZXQpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NlcmlhbGl6YXRpb25waXBlbGluZV9zZXJpYWxpemVBbGwodGhpcy5fX3diZ19wdHIsIGdyYXZpdHkuX193YmdfcHRyLCBpbnRlZ3JhdGlvblBhcmFtZXRlcnMuX193YmdfcHRyLCBpc2xhbmRzLl9fd2JnX3B0ciwgYnJvYWRQaGFzZS5fX3diZ19wdHIsIG5hcnJvd1BoYXNlLl9fd2JnX3B0ciwgYm9kaWVzLl9fd2JnX3B0ciwgY29sbGlkZXJzLl9fd2JnX3B0ciwgaW1wdWxzZV9qb2ludHMuX193YmdfcHRyLCBtdWx0aWJvZHlfam9pbnRzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiB0YWtlT2JqZWN0KHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gICAgKiBAcmV0dXJucyB7UmF3RGVzZXJpYWxpemVkV29ybGQgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBkZXNlcmlhbGl6ZUFsbChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3c2VyaWFsaXphdGlvbnBpcGVsaW5lX2Rlc2VyaWFsaXplQWxsKHRoaXMuX193YmdfcHRyLCBhZGRIZWFwT2JqZWN0KGRhdGEpKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd0Rlc2VyaWFsaXplZFdvcmxkLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgUmF3U2hhcGVGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3c2hhcGVfZnJlZShwdHIgPj4+IDApKTtcbi8qKlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdTaGFwZSB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3U2hhcGUucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3U2hhcGVGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3U2hhcGVGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd3NoYXBlX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaHhcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoeVxuICAgICogQHJldHVybnMge1Jhd1NoYXBlfVxuICAgICovXG4gICAgc3RhdGljIGN1Ym9pZChoeCwgaHkpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV9jdWJvaWQoaHgsIGh5KTtcbiAgICAgICAgcmV0dXJuIFJhd1NoYXBlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoeFxuICAgICogQHBhcmFtIHtudW1iZXJ9IGh5XG4gICAgKiBAcGFyYW0ge251bWJlcn0gYm9yZGVyUmFkaXVzXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGV9XG4gICAgKi9cbiAgICBzdGF0aWMgcm91bmRDdWJvaWQoaHgsIGh5LCBib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV9yb3VuZEN1Ym9pZChoeCwgaHksIGJvcmRlclJhZGl1cyk7XG4gICAgICAgIHJldHVybiBSYXdTaGFwZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGV9XG4gICAgKi9cbiAgICBzdGF0aWMgYmFsbChyYWRpdXMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV9iYWxsKHJhZGl1cyk7XG4gICAgICAgIHJldHVybiBSYXdTaGFwZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gbm9ybWFsXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGV9XG4gICAgKi9cbiAgICBzdGF0aWMgaGFsZnNwYWNlKG5vcm1hbCkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Mobm9ybWFsLCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX2hhbGZzcGFjZShub3JtYWwuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd1NoYXBlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYWxmSGVpZ2h0XG4gICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGV9XG4gICAgKi9cbiAgICBzdGF0aWMgY2Fwc3VsZShoYWxmSGVpZ2h0LCByYWRpdXMpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV9jYXBzdWxlKGhhbGZIZWlnaHQsIHJhZGl1cyk7XG4gICAgICAgIHJldHVybiBSYXdTaGFwZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmVydGljZXNcbiAgICAqIEBwYXJhbSB7VWludDMyQXJyYXl9IGluZGljZXNcbiAgICAqIEByZXR1cm5zIHtSYXdTaGFwZX1cbiAgICAqL1xuICAgIHN0YXRpYyBwb2x5bGluZSh2ZXJ0aWNlcywgaW5kaWNlcykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5RjMyVG9XYXNtMCh2ZXJ0aWNlcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzQXJyYXkzMlRvV2FzbTAoaW5kaWNlcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3c2hhcGVfcG9seWxpbmUocHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgIHJldHVybiBSYXdTaGFwZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmVydGljZXNcbiAgICAqIEBwYXJhbSB7VWludDMyQXJyYXl9IGluZGljZXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICAgICogQHJldHVybnMge1Jhd1NoYXBlfVxuICAgICovXG4gICAgc3RhdGljIHRyaW1lc2godmVydGljZXMsIGluZGljZXMsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlGMzJUb1dhc20wKHZlcnRpY2VzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NBcnJheTMyVG9XYXNtMChpbmRpY2VzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV90cmltZXNoKHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIGZsYWdzKTtcbiAgICAgICAgcmV0dXJuIFJhd1NoYXBlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBoZWlnaHRzXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2NhbGVcbiAgICAqIEByZXR1cm5zIHtSYXdTaGFwZX1cbiAgICAqL1xuICAgIHN0YXRpYyBoZWlnaHRmaWVsZChoZWlnaHRzLCBzY2FsZSkge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5RjMyVG9XYXNtMChoZWlnaHRzLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNjYWxlLCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX2hlaWdodGZpZWxkKHB0cjAsIGxlbjAsIHNjYWxlLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSYXdTaGFwZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcDFcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBwMlxuICAgICogQHJldHVybnMge1Jhd1NoYXBlfVxuICAgICovXG4gICAgc3RhdGljIHNlZ21lbnQocDEsIHAyKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwMSwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHAyLCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX3NlZ21lbnQocDEuX193YmdfcHRyLCBwMi5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3U2hhcGUuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHAxXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcDJcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBwM1xuICAgICogQHJldHVybnMge1Jhd1NoYXBlfVxuICAgICovXG4gICAgc3RhdGljIHRyaWFuZ2xlKHAxLCBwMiwgcDMpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHAxLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocDIsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwMywgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV90cmlhbmdsZShwMS5fX3diZ19wdHIsIHAyLl9fd2JnX3B0ciwgcDMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd1NoYXBlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBwMVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHAyXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcDNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3JkZXJSYWRpdXNcbiAgICAqIEByZXR1cm5zIHtSYXdTaGFwZX1cbiAgICAqL1xuICAgIHN0YXRpYyByb3VuZFRyaWFuZ2xlKHAxLCBwMiwgcDMsIGJvcmRlclJhZGl1cykge1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocDEsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwMiwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHAzLCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX3JvdW5kVHJpYW5nbGUocDEuX193YmdfcHRyLCBwMi5fX3diZ19wdHIsIHAzLl9fd2JnX3B0ciwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIFJhd1NoYXBlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBwb2ludHNcbiAgICAqIEByZXR1cm5zIHtSYXdTaGFwZSB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHN0YXRpYyBjb252ZXhIdWxsKHBvaW50cykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5RjMyVG9XYXNtMChwb2ludHMsIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX2NvbnZleEh1bGwocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdTaGFwZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gcG9pbnRzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gYm9yZGVyUmFkaXVzXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGUgfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBzdGF0aWMgcm91bmRDb252ZXhIdWxsKHBvaW50cywgYm9yZGVyUmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXlGMzJUb1dhc20wKHBvaW50cywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3c2hhcGVfcm91bmRDb252ZXhIdWxsKHB0cjAsIGxlbjAsIGJvcmRlclJhZGl1cyk7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdTaGFwZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmVydGljZXNcbiAgICAqIEByZXR1cm5zIHtSYXdTaGFwZSB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHN0YXRpYyBjb252ZXhQb2x5bGluZSh2ZXJ0aWNlcykge1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5RjMyVG9XYXNtMCh2ZXJ0aWNlcywgd2FzbS5fX3diaW5kZ2VuX21hbGxvYyk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3c2hhcGVfY29udmV4UG9seWxpbmUocHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdTaGFwZS5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmVydGljZXNcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3JkZXJSYWRpdXNcbiAgICAqIEByZXR1cm5zIHtSYXdTaGFwZSB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHN0YXRpYyByb3VuZENvbnZleFBvbHlsaW5lKHZlcnRpY2VzLCBib3JkZXJSYWRpdXMpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheUYzMlRvV2FzbTAodmVydGljZXMsIHdhc20uX193YmluZGdlbl9tYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX3JvdW5kQ29udmV4UG9seWxpbmUocHRyMCwgbGVuMCwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd1NoYXBlLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBzaGFwZVBvczFcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHNoYXBlUm90MVxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHNoYXBlVmVsMVxuICAgICogQHBhcmFtIHtSYXdTaGFwZX0gc2hhcGUyXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGVQb3MyXG4gICAgKiBAcGFyYW0ge1Jhd1JvdGF0aW9ufSBzaGFwZVJvdDJcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBzaGFwZVZlbDJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRfZGlzdGFuY2VcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhUb2lcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RvcF9hdF9wZW5ldHJhdGlvblxuICAgICogQHJldHVybnMge1Jhd1NoYXBlQ2FzdEhpdCB8IHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIGNhc3RTaGFwZShzaGFwZVBvczEsIHNoYXBlUm90MSwgc2hhcGVWZWwxLCBzaGFwZTIsIHNoYXBlUG9zMiwgc2hhcGVSb3QyLCBzaGFwZVZlbDIsIHRhcmdldF9kaXN0YW5jZSwgbWF4VG9pLCBzdG9wX2F0X3BlbmV0cmF0aW9uKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVBvczEsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVJvdDEsIFJhd1JvdGF0aW9uKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlVmVsMSwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlMiwgUmF3U2hhcGUpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVQb3MyLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVSb3QyLCBSYXdSb3RhdGlvbik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVZlbDIsIFJhd1ZlY3Rvcik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3c2hhcGVfY2FzdFNoYXBlKHRoaXMuX193YmdfcHRyLCBzaGFwZVBvczEuX193YmdfcHRyLCBzaGFwZVJvdDEuX193YmdfcHRyLCBzaGFwZVZlbDEuX193YmdfcHRyLCBzaGFwZTIuX193YmdfcHRyLCBzaGFwZVBvczIuX193YmdfcHRyLCBzaGFwZVJvdDIuX193YmdfcHRyLCBzaGFwZVZlbDIuX193YmdfcHRyLCB0YXJnZXRfZGlzdGFuY2UsIG1heFRvaSwgc3RvcF9hdF9wZW5ldHJhdGlvbik7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdTaGFwZUNhc3RIaXQuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHNoYXBlUG9zMVxuICAgICogQHBhcmFtIHtSYXdSb3RhdGlvbn0gc2hhcGVSb3QxXG4gICAgKiBAcGFyYW0ge1Jhd1NoYXBlfSBzaGFwZTJcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBzaGFwZVBvczJcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHNoYXBlUm90MlxuICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgKi9cbiAgICBpbnRlcnNlY3RzU2hhcGUoc2hhcGVQb3MxLCBzaGFwZVJvdDEsIHNoYXBlMiwgc2hhcGVQb3MyLCBzaGFwZVJvdDIpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlUG9zMSwgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlUm90MSwgUmF3Um90YXRpb24pO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGUyLCBSYXdTaGFwZSk7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVBvczIsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVJvdDIsIFJhd1JvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV9pbnRlcnNlY3RzU2hhcGUodGhpcy5fX3diZ19wdHIsIHNoYXBlUG9zMS5fX3diZ19wdHIsIHNoYXBlUm90MS5fX3diZ19wdHIsIHNoYXBlMi5fX3diZ19wdHIsIHNoYXBlUG9zMi5fX3diZ19wdHIsIHNoYXBlUm90Mi5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0ICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBzaGFwZVBvczFcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHNoYXBlUm90MVxuICAgICogQHBhcmFtIHtSYXdTaGFwZX0gc2hhcGUyXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGVQb3MyXG4gICAgKiBAcGFyYW0ge1Jhd1JvdGF0aW9ufSBzaGFwZVJvdDJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVkaWN0aW9uXG4gICAgKiBAcmV0dXJucyB7UmF3U2hhcGVDb250YWN0IHwgdW5kZWZpbmVkfVxuICAgICovXG4gICAgY29udGFjdFNoYXBlKHNoYXBlUG9zMSwgc2hhcGVSb3QxLCBzaGFwZTIsIHNoYXBlUG9zMiwgc2hhcGVSb3QyLCBwcmVkaWN0aW9uKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVBvczEsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVJvdDEsIFJhd1JvdGF0aW9uKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlMiwgUmF3U2hhcGUpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVQb3MyLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVSb3QyLCBSYXdSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3c2hhcGVfY29udGFjdFNoYXBlKHRoaXMuX193YmdfcHRyLCBzaGFwZVBvczEuX193YmdfcHRyLCBzaGFwZVJvdDEuX193YmdfcHRyLCBzaGFwZTIuX193YmdfcHRyLCBzaGFwZVBvczIuX193YmdfcHRyLCBzaGFwZVJvdDIuX193YmdfcHRyLCBwcmVkaWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJldCA9PT0gMCA/IHVuZGVmaW5lZCA6IFJhd1NoYXBlQ29udGFjdC5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGVQb3NcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHNoYXBlUm90XG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcG9pbnRcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgY29udGFpbnNQb2ludChzaGFwZVBvcywgc2hhcGVSb3QsIHBvaW50KSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVBvcywgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlUm90LCBSYXdSb3RhdGlvbik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhwb2ludCwgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV9jb250YWluc1BvaW50KHRoaXMuX193YmdfcHRyLCBzaGFwZVBvcy5fX3diZ19wdHIsIHNoYXBlUm90Ll9fd2JnX3B0ciwgcG9pbnQuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gc2hhcGVQb3NcbiAgICAqIEBwYXJhbSB7UmF3Um90YXRpb259IHNoYXBlUm90XG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcG9pbnRcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc29saWRcbiAgICAqIEByZXR1cm5zIHtSYXdQb2ludFByb2plY3Rpb259XG4gICAgKi9cbiAgICBwcm9qZWN0UG9pbnQoc2hhcGVQb3MsIHNoYXBlUm90LCBwb2ludCwgc29saWQpIHtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlUG9zLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVSb3QsIFJhd1JvdGF0aW9uKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHBvaW50LCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX3Byb2plY3RQb2ludCh0aGlzLl9fd2JnX3B0ciwgc2hhcGVQb3MuX193YmdfcHRyLCBzaGFwZVJvdC5fX3diZ19wdHIsIHBvaW50Ll9fd2JnX3B0ciwgc29saWQpO1xuICAgICAgICByZXR1cm4gUmF3UG9pbnRQcm9qZWN0aW9uLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSBzaGFwZVBvc1xuICAgICogQHBhcmFtIHtSYXdSb3RhdGlvbn0gc2hhcGVSb3RcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSByYXlPcmlnXG4gICAgKiBAcGFyYW0ge1Jhd1ZlY3Rvcn0gcmF5RGlyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VG9pXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIGludGVyc2VjdHNSYXkoc2hhcGVQb3MsIHNoYXBlUm90LCByYXlPcmlnLCByYXlEaXIsIG1heFRvaSkge1xuICAgICAgICBfYXNzZXJ0Q2xhc3Moc2hhcGVQb3MsIFJhd1ZlY3Rvcik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVJvdCwgUmF3Um90YXRpb24pO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmF5T3JpZywgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHJheURpciwgUmF3VmVjdG9yKTtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZV9pbnRlcnNlY3RzUmF5KHRoaXMuX193YmdfcHRyLCBzaGFwZVBvcy5fX3diZ19wdHIsIHNoYXBlUm90Ll9fd2JnX3B0ciwgcmF5T3JpZy5fX3diZ19wdHIsIHJheURpci5fX3diZ19wdHIsIG1heFRvaSk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHNoYXBlUG9zXG4gICAgKiBAcGFyYW0ge1Jhd1JvdGF0aW9ufSBzaGFwZVJvdFxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHJheU9yaWdcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSByYXlEaXJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhUb2lcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc29saWRcbiAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgKi9cbiAgICBjYXN0UmF5KHNoYXBlUG9zLCBzaGFwZVJvdCwgcmF5T3JpZywgcmF5RGlyLCBtYXhUb2ksIHNvbGlkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVBvcywgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlUm90LCBSYXdSb3RhdGlvbik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyYXlPcmlnLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmF5RGlyLCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX2Nhc3RSYXkodGhpcy5fX3diZ19wdHIsIHNoYXBlUG9zLl9fd2JnX3B0ciwgc2hhcGVSb3QuX193YmdfcHRyLCByYXlPcmlnLl9fd2JnX3B0ciwgcmF5RGlyLl9fd2JnX3B0ciwgbWF4VG9pLCBzb2xpZCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHNoYXBlUG9zXG4gICAgKiBAcGFyYW0ge1Jhd1JvdGF0aW9ufSBzaGFwZVJvdFxuICAgICogQHBhcmFtIHtSYXdWZWN0b3J9IHJheU9yaWdcbiAgICAqIEBwYXJhbSB7UmF3VmVjdG9yfSByYXlEaXJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhUb2lcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc29saWRcbiAgICAqIEByZXR1cm5zIHtSYXdSYXlJbnRlcnNlY3Rpb24gfCB1bmRlZmluZWR9XG4gICAgKi9cbiAgICBjYXN0UmF5QW5kR2V0Tm9ybWFsKHNoYXBlUG9zLCBzaGFwZVJvdCwgcmF5T3JpZywgcmF5RGlyLCBtYXhUb2ksIHNvbGlkKSB7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhzaGFwZVBvcywgUmF3VmVjdG9yKTtcbiAgICAgICAgX2Fzc2VydENsYXNzKHNoYXBlUm90LCBSYXdSb3RhdGlvbik7XG4gICAgICAgIF9hc3NlcnRDbGFzcyhyYXlPcmlnLCBSYXdWZWN0b3IpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3MocmF5RGlyLCBSYXdWZWN0b3IpO1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3NoYXBlX2Nhc3RSYXlBbmRHZXROb3JtYWwodGhpcy5fX3diZ19wdHIsIHNoYXBlUG9zLl9fd2JnX3B0ciwgc2hhcGVSb3QuX193YmdfcHRyLCByYXlPcmlnLl9fd2JnX3B0ciwgcmF5RGlyLl9fd2JnX3B0ciwgbWF4VG9pLCBzb2xpZCk7XG4gICAgICAgIHJldHVybiByZXQgPT09IDAgPyB1bmRlZmluZWQgOiBSYXdSYXlJbnRlcnNlY3Rpb24uX193cmFwKHJldCk7XG4gICAgfVxufVxuXG5jb25zdCBSYXdTaGFwZUNhc3RIaXRGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfcmF3c2hhcGVjYXN0aGl0X2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiovXG5leHBvcnQgY2xhc3MgUmF3U2hhcGVDYXN0SGl0IHtcblxuICAgIHN0YXRpYyBfX3dyYXAocHRyKSB7XG4gICAgICAgIHB0ciA9IHB0ciA+Pj4gMDtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShSYXdTaGFwZUNhc3RIaXQucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgUmF3U2hhcGVDYXN0SGl0RmluYWxpemF0aW9uLnJlZ2lzdGVyKG9iaiwgb2JqLl9fd2JnX3B0ciwgb2JqKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIFJhd1NoYXBlQ2FzdEhpdEZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfcmF3c2hhcGVjYXN0aGl0X2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgdGltZV9vZl9pbXBhY3QoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cm90YXRpb25fcmUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICB3aXRuZXNzMSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdzaGFwZWNhc3RoaXRfd2l0bmVzczEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICB3aXRuZXNzMigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjb2xsaWRlcnNoYXBlY2FzdGhpdF93aXRuZXNzMSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIG5vcm1hbDEoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3Y29sbGlkZXJzaGFwZWNhc3RoaXRfd2l0bmVzczIodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBub3JtYWwyKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbGxpZGVyc2hhcGVjYXN0aGl0X25vcm1hbDEodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgUmF3U2hhcGVDb250YWN0RmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Jhd3NoYXBlY29udGFjdF9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qL1xuZXhwb3J0IGNsYXNzIFJhd1NoYXBlQ29udGFjdCB7XG5cbiAgICBzdGF0aWMgX193cmFwKHB0cikge1xuICAgICAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoUmF3U2hhcGVDb250YWN0LnByb3RvdHlwZSk7XG4gICAgICAgIG9iai5fX3diZ19wdHIgPSBwdHI7XG4gICAgICAgIFJhd1NoYXBlQ29udGFjdEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBSYXdTaGFwZUNvbnRhY3RGaW5hbGl6YXRpb24udW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHB0cjtcbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fZGVzdHJveV9pbnRvX3JhdygpO1xuICAgICAgICB3YXNtLl9fd2JnX3Jhd3NoYXBlY29udGFjdF9mcmVlKHB0cik7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAqL1xuICAgIGRpc3RhbmNlKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbnRhY3Rmb3JjZWV2ZW50X3RvdGFsX2ZvcmNlX21hZ25pdHVkZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHBvaW50MSgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdwb2ludHByb2plY3Rpb25fcG9pbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBwb2ludDIoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fcG9pbnQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICBub3JtYWwxKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd2NvbnRhY3Rmb3JjZWV2ZW50X3RvdGFsX2ZvcmNlKHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIFJhd1ZlY3Rvci5fX3dyYXAocmV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAcmV0dXJucyB7UmF3VmVjdG9yfVxuICAgICovXG4gICAgbm9ybWFsMigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXdjaGFyYWN0ZXJjb2xsaXNpb25fdHJhbnNsYXRpb25EZWx0YUFwcGxpZWQodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgUmF3VmVjdG9yRmluYWxpemF0aW9uID0gKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgPyB7IHJlZ2lzdGVyOiAoKSA9PiB7fSwgdW5yZWdpc3RlcjogKCkgPT4ge30gfVxuICAgIDogbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KHB0ciA9PiB3YXNtLl9fd2JnX3Jhd3ZlY3Rvcl9mcmVlKHB0ciA+Pj4gMCkpO1xuLyoqXG4qIEEgdmVjdG9yLlxuKi9cbmV4cG9ydCBjbGFzcyBSYXdWZWN0b3Ige1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFJhd1ZlY3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBvYmouX193YmdfcHRyID0gcHRyO1xuICAgICAgICBSYXdWZWN0b3JGaW5hbGl6YXRpb24ucmVnaXN0ZXIob2JqLCBvYmouX193YmdfcHRyLCBvYmopO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9fZGVzdHJveV9pbnRvX3JhdygpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX3diZ19wdHI7XG4gICAgICAgIHRoaXMuX193YmdfcHRyID0gMDtcbiAgICAgICAgUmF3VmVjdG9yRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19yYXd2ZWN0b3JfZnJlZShwdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGZpbGxlZCB3aXRoIHplcm9zLlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHN0YXRpYyB6ZXJvKCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3ZlY3Rvcl96ZXJvKCk7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhIG5ldyAyRCB2ZWN0b3IgZnJvbSBpdHMgdHdvIGNvbXBvbmVudHMuXG4gICAgKlxuICAgICogIyBQYXJhbWV0ZXJzXG4gICAgKiAtIGB4YDogdGhlIGB4YCBjb21wb25lbnQgb2YgdGhpcyAyRCB2ZWN0b3IuXG4gICAgKiAtIGB5YDogdGhlIGB5YCBjb21wb25lbnQgb2YgdGhpcyAyRCB2ZWN0b3IuXG4gICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXd2ZWN0b3JfbmV3KHgsIHkpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGB4YCBjb21wb25lbnQgb2YgdGhpcyB2ZWN0b3IuXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3cm90YXRpb25fcmUodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHMgdGhlIGB4YCBjb21wb25lbnQgb2YgdGhpcyB2ZWN0b3IuXG4gICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICovXG4gICAgc2V0IHgoeCkge1xuICAgICAgICB3YXNtLnJhd3ZlY3Rvcl9zZXRfeCh0aGlzLl9fd2JnX3B0ciwgeCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVGhlIGB5YCBjb21wb25lbnQgb2YgdGhpcyB2ZWN0b3IuXG4gICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20ucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2R0KHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIHRoZSBgeWAgY29tcG9uZW50IG9mIHRoaXMgdmVjdG9yLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAqL1xuICAgIHNldCB5KHkpIHtcbiAgICAgICAgd2FzbS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X2R0KHRoaXMuX193YmdfcHRyLCB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgMkQgdmVjdG9yIGZyb20gdGhpcyB2ZWN0b3Igd2l0aCBpdHMgY29tcG9uZW50cyByZWFycmFuZ2VkIGFzIGB7eCwgeX1gLlxuICAgICogQHJldHVybnMge1Jhd1ZlY3Rvcn1cbiAgICAqL1xuICAgIHh5KCkge1xuICAgICAgICBjb25zdCByZXQgPSB3YXNtLnJhd3ZlY3Rvcl94eSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBSYXdWZWN0b3IuX193cmFwKHJldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogQ3JlYXRlIGEgbmV3IDJEIHZlY3RvciBmcm9tIHRoaXMgdmVjdG9yIHdpdGggaXRzIGNvbXBvbmVudHMgcmVhcnJhbmdlZCBhcyBge3ksIHh9YC5cbiAgICAqIEByZXR1cm5zIHtSYXdWZWN0b3J9XG4gICAgKi9cbiAgICB5eCgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5yYXd2ZWN0b3JfeXgodGhpcy5fX3diZ19wdHIpO1xuICAgICAgICByZXR1cm4gUmF3VmVjdG9yLl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5fbnVtYmVyX25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gYXJnMDtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5fYm9vbGVhbl9nZXQoYXJnMCkge1xuICAgIGNvbnN0IHYgPSBnZXRPYmplY3QoYXJnMCk7XG4gICAgY29uc3QgcmV0ID0gdHlwZW9mKHYpID09PSAnYm9vbGVhbicgPyAodiA/IDEgOiAwKSA6IDI7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZihhcmcwKSB7XG4gICAgdGFrZU9iamVjdChhcmcwKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX251bWJlcl9nZXQoYXJnMCwgYXJnMSkge1xuICAgIGNvbnN0IG9iaiA9IGdldE9iamVjdChhcmcxKTtcbiAgICBjb25zdCByZXQgPSB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcicgPyBvYmogOiB1bmRlZmluZWQ7XG4gICAgZ2V0RmxvYXQ2NE1lbW9yeTAoKVthcmcwIC8gOCArIDFdID0gaXNMaWtlTm9uZShyZXQpID8gMCA6IHJldDtcbiAgICBnZXRJbnQzMk1lbW9yeTAoKVthcmcwIC8gNCArIDBdID0gIWlzTGlrZU5vbmUocmV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diaW5kZ2VuX2lzX2Z1bmN0aW9uKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSB0eXBlb2YoZ2V0T2JqZWN0KGFyZzApKSA9PT0gJ2Z1bmN0aW9uJztcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX3Jhd3JheWNvbGxpZGVyaW50ZXJzZWN0aW9uX25ldyhhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gUmF3UmF5Q29sbGlkZXJJbnRlcnNlY3Rpb24uX193cmFwKGFyZzApO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfcmF3Y29udGFjdGZvcmNlZXZlbnRfbmV3KGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBSYXdDb250YWN0Rm9yY2VFdmVudC5fX3dyYXAoYXJnMCk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19jYWxsX2IzY2E3YzYwNTFmOWJlYzEoKSB7IHJldHVybiBoYW5kbGVFcnJvcihmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5jYWxsKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfY2FsbF84ZTdjYjYwODc4OWMyNTI4KCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSwgZ2V0T2JqZWN0KGFyZzMpKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufSwgYXJndW1lbnRzKSB9O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfY2FsbF85Mzg5OTJjODMyZjc0MzE0KCkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkuY2FsbChnZXRPYmplY3QoYXJnMSksIGdldE9iamVjdChhcmcyKSwgZ2V0T2JqZWN0KGFyZzMpLCBnZXRPYmplY3QoYXJnNCkpO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59LCBhcmd1bWVudHMpIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19iaW5kXzRkODU3YjU5ODY5NTIwNWUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5iaW5kKGdldE9iamVjdChhcmcxKSwgZ2V0T2JqZWN0KGFyZzIpLCBnZXRPYmplY3QoYXJnMykpO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfYnVmZmVyXzEyZDA3OWNjMjFlMTRiZGIoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChhcmcwKS5idWZmZXI7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9hYTRhMTdjMzNhMDZlNWNiKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgVWludDhBcnJheShnZXRPYmplY3QoYXJnMCksIGFyZzEgPj4+IDAsIGFyZzIgPj4+IDApO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfbmV3XzYzYjkyYmM4NjcxZWQ0NjQoYXJnMCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OEFycmF5KGdldE9iamVjdChhcmcwKSk7XG4gICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19zZXRfYTQ3YmFjNzAzMDZhMTlhNyhhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgZ2V0T2JqZWN0KGFyZzApLnNldChnZXRPYmplY3QoYXJnMSksIGFyZzIgPj4+IDApO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX2xlbmd0aF9jMjBhNDBmMTUwMjBkNjhhKGFyZzApIHtcbiAgICBjb25zdCByZXQgPSBnZXRPYmplY3QoYXJnMCkubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfNGE2NTlkMDc5YTE2NTBlMChhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEZsb2F0MzJBcnJheShnZXRPYmplY3QoYXJnMCksIGFyZzEgPj4+IDAsIGFyZzIgPj4+IDApO1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX193Ymdfc2V0X2JkOTc1OTM0ZDFiMWZkZGIoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgIGdldE9iamVjdChhcmcwKS5zZXQoZ2V0T2JqZWN0KGFyZzEpLCBhcmcyID4+PiAwKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19sZW5ndGhfZDI1YmJjYmMzMzY3ZjY4NChhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gZ2V0T2JqZWN0KGFyZzApLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JnX25ld3dpdGhsZW5ndGhfMWU4YjgzOWEwNmRlMDFjNShhcmcwKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEZsb2F0MzJBcnJheShhcmcwID4+PiAwKTtcbiAgICByZXR1cm4gYWRkSGVhcE9iamVjdChyZXQpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5fdGhyb3coYXJnMCwgYXJnMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fd2JpbmRnZW5fbWVtb3J5KCkge1xuICAgIGNvbnN0IHJldCA9IHdhc20ubWVtb3J5O1xuICAgIHJldHVybiBhZGRIZWFwT2JqZWN0KHJldCk7XG59O1xuXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm":
/*!*******************************************************************!*\
  !*** ../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./rapier_wasm2d_bg.js */ "(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js");
module.exports = __webpack_require__.v(exports, module.id, "929e0fec1729d4af", {
	"./rapier_wasm2d_bg.js": {
		"__wbindgen_number_new": WEBPACK_IMPORTED_MODULE_0.__wbindgen_number_new,
		"__wbindgen_boolean_get": WEBPACK_IMPORTED_MODULE_0.__wbindgen_boolean_get,
		"__wbindgen_object_drop_ref": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_drop_ref,
		"__wbindgen_number_get": WEBPACK_IMPORTED_MODULE_0.__wbindgen_number_get,
		"__wbindgen_is_function": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_function,
		"__wbg_rawraycolliderintersection_new": WEBPACK_IMPORTED_MODULE_0.__wbg_rawraycolliderintersection_new,
		"__wbg_rawcontactforceevent_new": WEBPACK_IMPORTED_MODULE_0.__wbg_rawcontactforceevent_new,
		"__wbg_call_b3ca7c6051f9bec1": WEBPACK_IMPORTED_MODULE_0.__wbg_call_b3ca7c6051f9bec1,
		"__wbg_call_8e7cb608789c2528": WEBPACK_IMPORTED_MODULE_0.__wbg_call_8e7cb608789c2528,
		"__wbg_call_938992c832f74314": WEBPACK_IMPORTED_MODULE_0.__wbg_call_938992c832f74314,
		"__wbg_bind_4d857b598695205e": WEBPACK_IMPORTED_MODULE_0.__wbg_bind_4d857b598695205e,
		"__wbg_buffer_12d079cc21e14bdb": WEBPACK_IMPORTED_MODULE_0.__wbg_buffer_12d079cc21e14bdb,
		"__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb,
		"__wbg_new_63b92bc8671ed464": WEBPACK_IMPORTED_MODULE_0.__wbg_new_63b92bc8671ed464,
		"__wbg_set_a47bac70306a19a7": WEBPACK_IMPORTED_MODULE_0.__wbg_set_a47bac70306a19a7,
		"__wbg_length_c20a40f15020d68a": WEBPACK_IMPORTED_MODULE_0.__wbg_length_c20a40f15020d68a,
		"__wbg_newwithbyteoffsetandlength_4a659d079a1650e0": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_4a659d079a1650e0,
		"__wbg_set_bd975934d1b1fddb": WEBPACK_IMPORTED_MODULE_0.__wbg_set_bd975934d1b1fddb,
		"__wbg_length_d25bbcbc3367f684": WEBPACK_IMPORTED_MODULE_0.__wbg_length_d25bbcbc3367f684,
		"__wbg_newwithlength_1e8b839a06de01c5": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithlength_1e8b839a06de01c5,
		"__wbindgen_throw": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,
		"__wbindgen_memory": WEBPACK_IMPORTED_MODULE_0.__wbindgen_memory
	}
});

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*************************************************************************!*\
  !*** ../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(pages-dir-browser)/../../node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(pages-dir-browser)/../../node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(pages-dir-browser)/../../node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(pages-dir-browser)/../../node_modules/redux-thunk/dist/redux-thunk.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/../../node_modules/process/browser.js\");\n// src/index.ts\n\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args) => {\n  const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n  const createDraftSafeSelector2 = Object.assign((...args2) => {\n    const selector = createSelector2(...args2);\n    const wrappedSelector = (value, ...rest) => selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n    Object.assign(wrappedSelector, selector);\n    return wrappedSelector;\n  }, {\n    withTypes: () => createDraftSafeSelector2\n  });\n  return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n\n// src/configureStore.ts\n\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {\n  if (arguments.length === 0) return void 0;\n  if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer = typeof window !== \"undefined\" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {\n  return function(noop3) {\n    return noop3;\n  };\n};\n\n// src/getDefaultMiddleware.ts\n\n\n// src/createAction.ts\n\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v) => {\n  return v && typeof v.match === \"function\";\n};\n\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n  function actionCreator(...args) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args);\n      if (!prepared) {\n        throw new Error( false ? 0 : \"prepareAction did not return an object\");\n      }\n      return {\n        type,\n        payload: prepared.payload,\n        ...\"meta\" in prepared && {\n          meta: prepared.meta\n        },\n        ...\"error\" in prepared && {\n          error: prepared.error\n        }\n      };\n    }\n    return {\n      type,\n      payload: args[0]\n    };\n  }\n  actionCreator.toString = () => `${type}`;\n  actionCreator.type = type;\n  actionCreator.match = (action) => (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n  return actionCreator;\n}\nfunction isActionCreator(action) {\n  return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n  hasMatchFunction(action);\n}\nfunction isFSA(action) {\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n  return [\"type\", \"payload\", \"error\", \"meta\"].indexOf(key) > -1;\n}\n\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n  const splitType = type ? `${type}`.split(\"/\") : [];\n  const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n  return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n  if (false) {}\n  const {\n    isActionCreator: isActionCreator2 = isActionCreator\n  } = options;\n  return () => (next) => (action) => {\n    if (isActionCreator2(action)) {\n      console.warn(getMessage(action.type));\n    }\n    return next(action);\n  };\n}\n\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n  let elapsed = 0;\n  return {\n    measureTime(fn) {\n      const started = Date.now();\n      try {\n        return fn();\n      } finally {\n        const finished = Date.now();\n        elapsed += finished - started;\n      }\n    },\n    warnIfExceeded() {\n      if (elapsed > maxDelay) {\n        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n      }\n    }\n  };\n}\nvar Tuple = class _Tuple extends Array {\n  constructor(...items) {\n    super(...items);\n    Object.setPrototypeOf(this, _Tuple.prototype);\n  }\n  static get [Symbol.species]() {\n    return _Tuple;\n  }\n  concat(...arr) {\n    return super.concat.apply(this, arr);\n  }\n  prepend(...arr) {\n    if (arr.length === 1 && Array.isArray(arr[0])) {\n      return new _Tuple(...arr[0].concat(this));\n    }\n    return new _Tuple(...arr.concat(this));\n  }\n};\nfunction freezeDraftable(val) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, () => {\n  }) : val;\n}\nfunction getOrInsertComputed(map, key, compute) {\n  if (map.has(key)) return map.get(key);\n  return map.set(key, compute(key)).get(key);\n}\n\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n  return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n  return {\n    detectMutations() {\n      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n    }\n  };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n  const tracked = {\n    value: obj\n  };\n  if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n    checkedObjects.add(obj);\n    tracked.children = {};\n    for (const key in obj) {\n      const childPath = path ? path + \".\" + key : key;\n      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n        continue;\n      }\n      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n    }\n  }\n  return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n  const prevObj = trackedProperty ? trackedProperty.value : void 0;\n  const sameRef = prevObj === obj;\n  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n    return {\n      wasMutated: true,\n      path\n    };\n  }\n  if (isImmutable(prevObj) || isImmutable(obj)) {\n    return {\n      wasMutated: false\n    };\n  }\n  const keysToDetect = {};\n  for (let key in trackedProperty.children) {\n    keysToDetect[key] = true;\n  }\n  for (let key in obj) {\n    keysToDetect[key] = true;\n  }\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (let key in keysToDetect) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n    if (result.wasMutated) {\n      return result;\n    }\n  }\n  return {\n    wasMutated: false\n  };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    let stringify2 = function(obj, serializer, indent, decycler) {\n      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n    }, getSerialize2 = function(serializer, decycler) {\n      let stack = [], keys = [];\n      if (!decycler) decycler = function(_, value) {\n        if (stack[0] === value) return \"[Circular ~]\";\n        return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n      };\n      return function(key, value) {\n        if (stack.length > 0) {\n          var thisPos = stack.indexOf(this);\n          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n          if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n        } else stack.push(value);\n        return serializer == null ? value : serializer.call(this, key, value);\n      };\n    };\n    var stringify = stringify2, getSerialize = getSerialize2;\n    let {\n      isImmutable = isImmutableDefault,\n      ignoredPaths,\n      warnAfter = 32\n    } = options;\n    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n    return ({\n      getState\n    }) => {\n      let state = getState();\n      let tracker = track(state);\n      let result;\n      return (next) => (action) => {\n        const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        const dispatchedAction = next(action);\n        measureUtils.measureTime(() => {\n          state = getState();\n          result = tracker.detectMutations();\n          tracker = track(state);\n          if (result.wasMutated) {\n            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n        return dispatchedAction;\n      };\n    };\n  }\n}\n\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n  const type = typeof val;\n  return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n  let foundNestedSerializable;\n  if (!isSerializable(value)) {\n    return {\n      keyPath: path || \"<root>\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  if (cache?.has(value)) return false;\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n  const hasIgnoredPaths = ignoredPaths.length > 0;\n  for (const [key, nestedValue] of entries) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (hasIgnoredPaths) {\n      const hasMatches = ignoredPaths.some((ignored) => {\n        if (ignored instanceof RegExp) {\n          return ignored.test(nestedPath);\n        }\n        return nestedPath === ignored;\n      });\n      if (hasMatches) {\n        continue;\n      }\n    }\n    if (!isSerializable(nestedValue)) {\n      return {\n        keyPath: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n      if (foundNestedSerializable) {\n        return foundNestedSerializable;\n      }\n    }\n  }\n  if (cache && isNestedFrozen(value)) cache.add(value);\n  return false;\n}\nfunction isNestedFrozen(value) {\n  if (!Object.isFrozen(value)) return false;\n  for (const nestedValue of Object.values(value)) {\n    if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n    if (!isNestedFrozen(nestedValue)) return false;\n  }\n  return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n  if (false) {} else {\n    const {\n      isSerializable = isPlain,\n      getEntries,\n      ignoredActions = [],\n      ignoredActionPaths = [\"meta.arg\", \"meta.baseQueryMeta\"],\n      ignoredPaths = [],\n      warnAfter = 32,\n      ignoreState = false,\n      ignoreActions = false,\n      disableCache = false\n    } = options;\n    const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n    return (storeAPI) => (next) => (action) => {\n      if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n        return next(action);\n      }\n      const result = next(action);\n      const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n        measureUtils.measureTime(() => {\n          const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n          if (foundActionNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundActionNonSerializableValue;\n            console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n          }\n        });\n      }\n      if (!ignoreState) {\n        measureUtils.measureTime(() => {\n          const state = storeAPI.getState();\n          const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n          if (foundStateNonSerializableValue) {\n            const {\n              keyPath,\n              value\n            } = foundStateNonSerializableValue;\n            console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n          }\n        });\n        measureUtils.warnIfExceeded();\n      }\n      return result;\n    };\n  }\n}\n\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n  return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {\n  const {\n    thunk = true,\n    immutableCheck = true,\n    serializableCheck = true,\n    actionCreatorCheck = true\n  } = options ?? {};\n  let middlewareArray = new Tuple();\n  if (thunk) {\n    if (isBoolean(thunk)) {\n      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n    } else {\n      middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n    }\n  }\n  if (true) {\n    if (immutableCheck) {\n      let immutableOptions = {};\n      if (!isBoolean(immutableCheck)) {\n        immutableOptions = immutableCheck;\n      }\n      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n    }\n    if (serializableCheck) {\n      let serializableOptions = {};\n      if (!isBoolean(serializableCheck)) {\n        serializableOptions = serializableCheck;\n      }\n      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n    }\n    if (actionCreatorCheck) {\n      let actionCreatorOptions = {};\n      if (!isBoolean(actionCreatorCheck)) {\n        actionCreatorOptions = actionCreatorCheck;\n      }\n      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n    }\n  }\n  return middlewareArray;\n};\n\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = () => (payload) => ({\n  payload,\n  meta: {\n    [SHOULD_AUTOBATCH]: true\n  }\n});\nvar createQueueWithTimer = (timeout) => {\n  return (notify) => {\n    setTimeout(notify, timeout);\n  };\n};\nvar autoBatchEnhancer = (options = {\n  type: \"raf\"\n}) => (next) => (...args) => {\n  const store = next(...args);\n  let notifying = true;\n  let shouldNotifyAtEndOfTick = false;\n  let notificationQueued = false;\n  const listeners = /* @__PURE__ */ new Set();\n  const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? (\n    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.\n    typeof window !== \"undefined\" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)\n  ) : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n  const notifyListeners = () => {\n    notificationQueued = false;\n    if (shouldNotifyAtEndOfTick) {\n      shouldNotifyAtEndOfTick = false;\n      listeners.forEach((l) => l());\n    }\n  };\n  return Object.assign({}, store, {\n    // Override the base `store.subscribe` method to keep original listeners\n    // from running if we're delaying notifications\n    subscribe(listener2) {\n      const wrappedListener = () => notifying && listener2();\n      const unsubscribe = store.subscribe(wrappedListener);\n      listeners.add(listener2);\n      return () => {\n        unsubscribe();\n        listeners.delete(listener2);\n      };\n    },\n    // Override the base `store.dispatch` method so that we can check actions\n    // for the `shouldAutoBatch` flag and determine if batching is active\n    dispatch(action) {\n      try {\n        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n        shouldNotifyAtEndOfTick = !notifying;\n        if (shouldNotifyAtEndOfTick) {\n          if (!notificationQueued) {\n            notificationQueued = true;\n            queueCallback(notifyListeners);\n          }\n        }\n        return store.dispatch(action);\n      } finally {\n        notifying = true;\n      }\n    }\n  });\n};\n\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {\n  const {\n    autoBatch = true\n  } = options ?? {};\n  let enhancerArray = new Tuple(middlewareEnhancer);\n  if (autoBatch) {\n    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n  }\n  return enhancerArray;\n};\n\n// src/configureStore.ts\nfunction configureStore(options) {\n  const getDefaultMiddleware = buildGetDefaultMiddleware();\n  const {\n    reducer = void 0,\n    middleware,\n    devTools = true,\n    preloadedState = void 0,\n    enhancers = void 0\n  } = options || {};\n  let rootReducer;\n  if (typeof reducer === \"function\") {\n    rootReducer = reducer;\n  } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n    rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n  } else {\n    throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n  }\n  if ( true && middleware && typeof middleware !== \"function\") {\n    throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n  }\n  let finalMiddleware;\n  if (typeof middleware === \"function\") {\n    finalMiddleware = middleware(getDefaultMiddleware);\n    if ( true && !Array.isArray(finalMiddleware)) {\n      throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n    }\n  } else {\n    finalMiddleware = getDefaultMiddleware();\n  }\n  if ( true && finalMiddleware.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n  }\n  let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n  if (devTools) {\n    finalCompose = composeWithDevTools({\n      // Enable capture of stack traces for dispatched Redux actions\n      trace: \"development\" !== \"production\",\n      ...typeof devTools === \"object\" && devTools\n    });\n  }\n  const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n  if ( true && enhancers && typeof enhancers !== \"function\") {\n    throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n  }\n  let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n  if ( true && !Array.isArray(storeEnhancers)) {\n    throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n  }\n  if ( true && storeEnhancers.some((item) => typeof item !== \"function\")) {\n    throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n  }\n  if ( true && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n    console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n  }\n  const composedEnhancer = finalCompose(...storeEnhancers);\n  return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n\n// src/createReducer.ts\n\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n  const actionsMap = {};\n  const actionMatchers = [];\n  let defaultCaseReducer;\n  const builder = {\n    addCase(typeOrActionCreator, reducer) {\n      if (true) {\n        if (actionMatchers.length > 0) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n        }\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n      if (!type) {\n        throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n      }\n      if (type in actionsMap) {\n        throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n      }\n      actionsMap[type] = reducer;\n      return builder;\n    },\n    addMatcher(matcher, reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n        }\n      }\n      actionMatchers.push({\n        matcher,\n        reducer\n      });\n      return builder;\n    },\n    addDefaultCase(reducer) {\n      if (true) {\n        if (defaultCaseReducer) {\n          throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n        }\n      }\n      defaultCaseReducer = reducer;\n      return builder;\n    }\n  };\n  builderCallback(builder);\n  return [actionsMap, actionMatchers, defaultCaseReducer];\n}\n\n// src/createReducer.ts\nfunction isStateFunction(x) {\n  return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n  if (true) {\n    if (typeof mapOrBuilderCallback === \"object\") {\n      throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n    }\n  }\n  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n  let getInitialState;\n  if (isStateFunction(initialState)) {\n    getInitialState = () => freezeDraftable(initialState());\n  } else {\n    const frozenInitialState = freezeDraftable(initialState);\n    getInitialState = () => frozenInitialState;\n  }\n  function reducer(state = getInitialState(), action) {\n    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({\n      matcher\n    }) => matcher(action)).map(({\n      reducer: reducer2\n    }) => reducer2)];\n    if (caseReducers.filter((cr) => !!cr).length === 0) {\n      caseReducers = [finalDefaultCaseReducer];\n    }\n    return caseReducers.reduce((previousState, caseReducer) => {\n      if (caseReducer) {\n        if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n          const draft = previousState;\n          const result = caseReducer(draft, action);\n          if (result === void 0) {\n            return previousState;\n          }\n          return result;\n        } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n          const result = caseReducer(previousState, action);\n          if (result === void 0) {\n            if (previousState === null) {\n              return previousState;\n            }\n            throw Error(\"A case reducer on a non-draftable value must not return undefined\");\n          }\n          return result;\n        } else {\n          return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft) => {\n            return caseReducer(draft, action);\n          });\n        }\n      }\n      return previousState;\n    }, state);\n  }\n  reducer.getInitialState = getInitialState;\n  return reducer;\n}\n\n// src/matchers.ts\nvar matches = (matcher, action) => {\n  if (hasMatchFunction(matcher)) {\n    return matcher.match(action);\n  } else {\n    return matcher(action);\n  }\n};\nfunction isAnyOf(...matchers) {\n  return (action) => {\n    return matchers.some((matcher) => matches(matcher, action));\n  };\n}\nfunction isAllOf(...matchers) {\n  return (action) => {\n    return matchers.every((matcher) => matches(matcher, action));\n  };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n  if (!action || !action.meta) return false;\n  const hasValidRequestId = typeof action.meta.requestId === \"string\";\n  const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n  return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n  return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isPending()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));\n}\nfunction isRejected(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejected()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));\n}\nfunction isRejectedWithValue(...asyncThunks) {\n  const hasFlag = (action) => {\n    return action && action.meta && action.meta.rejectedWithValue;\n  };\n  if (asyncThunks.length === 0) {\n    return isAllOf(isRejected(...asyncThunks), hasFlag);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isRejectedWithValue()(asyncThunks[0]);\n  }\n  return isAllOf(isRejected(...asyncThunks), hasFlag);\n}\nfunction isFulfilled(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"fulfilled\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isFulfilled()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n  if (asyncThunks.length === 0) {\n    return (action) => hasExpectedRequestMetadata(action, [\"pending\", \"fulfilled\", \"rejected\"]);\n  }\n  if (!isAsyncThunkArray(asyncThunks)) {\n    return isAsyncThunkAction()(asyncThunks[0]);\n  }\n  return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));\n}\n\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21) => {\n  let id = \"\";\n  let i = size;\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n  return id;\n};\n\n// src/createAsyncThunk.ts\nvar commonProperties = [\"name\", \"message\", \"stack\", \"code\"];\nvar RejectWithValue = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar FulfillWithMeta = class {\n  constructor(payload, meta) {\n    this.payload = payload;\n    this.meta = meta;\n  }\n  /*\n  type-only property to distinguish between RejectWithValue and FulfillWithMeta\n  does not exist at runtime\n  */\n  _type;\n};\nvar miniSerializeError = (value) => {\n  if (typeof value === \"object\" && value !== null) {\n    const simpleError = {};\n    for (const property of commonProperties) {\n      if (typeof value[property] === \"string\") {\n        simpleError[property] = value[property];\n      }\n    }\n    return simpleError;\n  }\n  return {\n    message: String(value)\n  };\n};\nvar createAsyncThunk = /* @__PURE__ */ (() => {\n  function createAsyncThunk2(typePrefix, payloadCreator, options) {\n    const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta) => ({\n      payload,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"fulfilled\"\n      }\n    }));\n    const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta) => ({\n      payload: void 0,\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        requestStatus: \"pending\"\n      }\n    }));\n    const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta) => ({\n      payload,\n      error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n      meta: {\n        ...meta || {},\n        arg,\n        requestId,\n        rejectedWithValue: !!payload,\n        requestStatus: \"rejected\",\n        aborted: error?.name === \"AbortError\",\n        condition: error?.name === \"ConditionError\"\n      }\n    }));\n    function actionCreator(arg) {\n      return (dispatch, getState, extra) => {\n        const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n        const abortController = new AbortController();\n        let abortHandler;\n        let abortReason;\n        function abort(reason) {\n          abortReason = reason;\n          abortController.abort();\n        }\n        const promise = async function() {\n          let finalAction;\n          try {\n            let conditionResult = options?.condition?.(arg, {\n              getState,\n              extra\n            });\n            if (isThenable(conditionResult)) {\n              conditionResult = await conditionResult;\n            }\n            if (conditionResult === false || abortController.signal.aborted) {\n              throw {\n                name: \"ConditionError\",\n                message: \"Aborted due to condition callback returning false.\"\n              };\n            }\n            const abortedPromise = new Promise((_, reject) => {\n              abortHandler = () => {\n                reject({\n                  name: \"AbortError\",\n                  message: abortReason || \"Aborted\"\n                });\n              };\n              abortController.signal.addEventListener(\"abort\", abortHandler);\n            });\n            dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n              requestId,\n              arg\n            }, {\n              getState,\n              extra\n            })));\n            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {\n              dispatch,\n              getState,\n              extra,\n              requestId,\n              signal: abortController.signal,\n              abort,\n              rejectWithValue: (value, meta) => {\n                return new RejectWithValue(value, meta);\n              },\n              fulfillWithValue: (value, meta) => {\n                return new FulfillWithMeta(value, meta);\n              }\n            })).then((result) => {\n              if (result instanceof RejectWithValue) {\n                throw result;\n              }\n              if (result instanceof FulfillWithMeta) {\n                return fulfilled(result.payload, requestId, arg, result.meta);\n              }\n              return fulfilled(result, requestId, arg);\n            })]);\n          } catch (err) {\n            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n          } finally {\n            if (abortHandler) {\n              abortController.signal.removeEventListener(\"abort\", abortHandler);\n            }\n          }\n          const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n          if (!skipDispatch) {\n            dispatch(finalAction);\n          }\n          return finalAction;\n        }();\n        return Object.assign(promise, {\n          abort,\n          requestId,\n          arg,\n          unwrap() {\n            return promise.then(unwrapResult);\n          }\n        });\n      };\n    }\n    return Object.assign(actionCreator, {\n      pending,\n      rejected,\n      fulfilled,\n      settled: isAnyOf(rejected, fulfilled),\n      typePrefix\n    });\n  }\n  createAsyncThunk2.withTypes = () => createAsyncThunk2;\n  return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n  if (action.meta && action.meta.rejectedWithValue) {\n    throw action.payload;\n  }\n  if (action.error) {\n    throw action.error;\n  }\n  return action.payload;\n}\nfunction isThenable(value) {\n  return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n\n// src/createSlice.ts\nvar asyncThunkSymbol = /* @__PURE__ */ Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n  [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2) => {\n  ReducerType2[\"reducer\"] = \"reducer\";\n  ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n  ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n  return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n  return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({\n  creators\n} = {}) {\n  const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n  return function createSlice2(options) {\n    const {\n      name,\n      reducerPath = name\n    } = options;\n    if (!name) {\n      throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n    }\n    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n      if (options.initialState === void 0) {\n        console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n      }\n    }\n    const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n    const reducerNames = Object.keys(reducers);\n    const context = {\n      sliceCaseReducersByName: {},\n      sliceCaseReducersByType: {},\n      actionCreators: {},\n      sliceMatchers: []\n    };\n    const contextMethods = {\n      addCase(typeOrActionCreator, reducer2) {\n        const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n        if (!type) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n        }\n        if (type in context.sliceCaseReducersByType) {\n          throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n        }\n        context.sliceCaseReducersByType[type] = reducer2;\n        return contextMethods;\n      },\n      addMatcher(matcher, reducer2) {\n        context.sliceMatchers.push({\n          matcher,\n          reducer: reducer2\n        });\n        return contextMethods;\n      },\n      exposeAction(name2, actionCreator) {\n        context.actionCreators[name2] = actionCreator;\n        return contextMethods;\n      },\n      exposeCaseReducer(name2, reducer2) {\n        context.sliceCaseReducersByName[name2] = reducer2;\n        return contextMethods;\n      }\n    };\n    reducerNames.forEach((reducerName) => {\n      const reducerDefinition = reducers[reducerName];\n      const reducerDetails = {\n        reducerName,\n        type: getType(name, reducerName),\n        createNotation: typeof options.reducers === \"function\"\n      };\n      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n      } else {\n        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n      }\n    });\n    function buildReducer() {\n      if (true) {\n        if (typeof options.extraReducers === \"object\") {\n          throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n        }\n      }\n      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];\n      const finalCaseReducers = {\n        ...extraReducers,\n        ...context.sliceCaseReducersByType\n      };\n      return createReducer(options.initialState, (builder) => {\n        for (let key in finalCaseReducers) {\n          builder.addCase(key, finalCaseReducers[key]);\n        }\n        for (let sM of context.sliceMatchers) {\n          builder.addMatcher(sM.matcher, sM.reducer);\n        }\n        for (let m of actionMatchers) {\n          builder.addMatcher(m.matcher, m.reducer);\n        }\n        if (defaultCaseReducer) {\n          builder.addDefaultCase(defaultCaseReducer);\n        }\n      });\n    }\n    const selectSelf = (state) => state;\n    const injectedSelectorCache = /* @__PURE__ */ new Map();\n    let _reducer;\n    function reducer(state, action) {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer(state, action);\n    }\n    function getInitialState() {\n      if (!_reducer) _reducer = buildReducer();\n      return _reducer.getInitialState();\n    }\n    function makeSelectorProps(reducerPath2, injected = false) {\n      function selectSlice(state) {\n        let sliceState = state[reducerPath2];\n        if (typeof sliceState === \"undefined\") {\n          if (injected) {\n            sliceState = getInitialState();\n          } else if (true) {\n            throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n          }\n        }\n        return sliceState;\n      }\n      function getSelectors(selectState = selectSelf) {\n        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());\n        return getOrInsertComputed(selectorCache, selectState, () => {\n          const map = {};\n          for (const [name2, selector] of Object.entries(options.selectors ?? {})) {\n            map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n          }\n          return map;\n        });\n      }\n      return {\n        reducerPath: reducerPath2,\n        getSelectors,\n        get selectors() {\n          return getSelectors(selectSlice);\n        },\n        selectSlice\n      };\n    }\n    const slice = {\n      name,\n      reducer,\n      actions: context.actionCreators,\n      caseReducers: context.sliceCaseReducersByName,\n      getInitialState,\n      ...makeSelectorProps(reducerPath),\n      injectInto(injectable, {\n        reducerPath: pathOpt,\n        ...config\n      } = {}) {\n        const newReducerPath = pathOpt ?? reducerPath;\n        injectable.inject({\n          reducerPath: newReducerPath,\n          reducer\n        }, config);\n        return {\n          ...slice,\n          ...makeSelectorProps(newReducerPath, true)\n        };\n      }\n    };\n    return slice;\n  };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n  function wrapper(rootState, ...args) {\n    let sliceState = selectState(rootState);\n    if (typeof sliceState === \"undefined\") {\n      if (injected) {\n        sliceState = getInitialState();\n      } else if (true) {\n        throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n      }\n    }\n    return selector(sliceState, ...args);\n  }\n  wrapper.unwrapped = selector;\n  return wrapper;\n}\nvar createSlice = /* @__PURE__ */ buildCreateSlice();\nfunction buildReducerCreators() {\n  function asyncThunk(payloadCreator, config) {\n    return {\n      _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */,\n      payloadCreator,\n      ...config\n    };\n  }\n  asyncThunk.withTypes = () => asyncThunk;\n  return {\n    reducer(caseReducer) {\n      return Object.assign({\n        // hack so the wrapping function has the same name as the original\n        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n        [caseReducer.name](...args) {\n          return caseReducer(...args);\n        }\n      }[caseReducer.name], {\n        _reducerDefinitionType: \"reducer\" /* reducer */\n      });\n    },\n    preparedReducer(prepare, reducer) {\n      return {\n        _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */,\n        prepare,\n        reducer\n      };\n    },\n    asyncThunk\n  };\n}\nfunction handleNormalReducerDefinition({\n  type,\n  reducerName,\n  createNotation\n}, maybeReducerWithPrepare, context) {\n  let caseReducer;\n  let prepareCallback;\n  if (\"reducer\" in maybeReducerWithPrepare) {\n    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n      throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n    }\n    caseReducer = maybeReducerWithPrepare.reducer;\n    prepareCallback = maybeReducerWithPrepare.prepare;\n  } else {\n    caseReducer = maybeReducerWithPrepare;\n  }\n  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n  return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */;\n}\nfunction handleThunkCaseReducerDefinition({\n  type,\n  reducerName\n}, reducerDefinition, context, cAT) {\n  if (!cAT) {\n    throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n  }\n  const {\n    payloadCreator,\n    fulfilled,\n    pending,\n    rejected,\n    settled,\n    options\n  } = reducerDefinition;\n  const thunk = cAT(type, payloadCreator, options);\n  context.exposeAction(reducerName, thunk);\n  if (fulfilled) {\n    context.addCase(thunk.fulfilled, fulfilled);\n  }\n  if (pending) {\n    context.addCase(thunk.pending, pending);\n  }\n  if (rejected) {\n    context.addCase(thunk.rejected, rejected);\n  }\n  if (settled) {\n    context.addMatcher(thunk.settled, settled);\n  }\n  context.exposeCaseReducer(reducerName, {\n    fulfilled: fulfilled || noop,\n    pending: pending || noop,\n    rejected: rejected || noop,\n    settled: settled || noop\n  });\n}\nfunction noop() {\n}\n\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n  return {\n    ids: [],\n    entities: {}\n  };\n}\nfunction createInitialStateFactory(stateAdapter) {\n  function getInitialState(additionalState = {}, entities) {\n    const state = Object.assign(getInitialEntityState(), additionalState);\n    return entities ? stateAdapter.setAll(state, entities) : state;\n  }\n  return {\n    getInitialState\n  };\n}\n\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n  function getSelectors(selectState, options = {}) {\n    const {\n      createSelector: createSelector2 = createDraftSafeSelector\n    } = options;\n    const selectIds = (state) => state.ids;\n    const selectEntities = (state) => state.entities;\n    const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id) => entities[id]));\n    const selectId = (_, id) => id;\n    const selectById = (entities, id) => entities[id];\n    const selectTotal = createSelector2(selectIds, (ids) => ids.length);\n    if (!selectState) {\n      return {\n        selectIds,\n        selectEntities,\n        selectAll,\n        selectTotal,\n        selectById: createSelector2(selectEntities, selectId, selectById)\n      };\n    }\n    const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n    return {\n      selectIds: createSelector2(selectState, selectIds),\n      selectEntities: selectGlobalizedEntities,\n      selectAll: createSelector2(selectState, selectAll),\n      selectTotal: createSelector2(selectState, selectTotal),\n      selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n    };\n  }\n  return {\n    getSelectors\n  };\n}\n\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n  const operator = createStateOperator((_, state) => mutator(state));\n  return function operation(state) {\n    return operator(state, void 0);\n  };\n}\nfunction createStateOperator(mutator) {\n  return function operation(state, arg) {\n    function isPayloadActionArgument(arg2) {\n      return isFSA(arg2);\n    }\n    const runMutator = (draft) => {\n      if (isPayloadActionArgument(arg)) {\n        mutator(arg.payload, draft);\n      } else {\n        mutator(arg, draft);\n      }\n    };\n    if (isDraftTyped(state)) {\n      runMutator(state);\n      return state;\n    }\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n  };\n}\n\n// src/entities/utils.ts\n\nfunction selectIdValue(entity, selectId) {\n  const key = selectId(entity);\n  if ( true && key === void 0) {\n    console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n  }\n  return key;\n}\nfunction ensureEntitiesArray(entities) {\n  if (!Array.isArray(entities)) {\n    entities = Object.values(entities);\n  }\n  return entities;\n}\nfunction getCurrent(value) {\n  return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n  newEntities = ensureEntitiesArray(newEntities);\n  const existingIdsArray = getCurrent(state.ids);\n  const existingIds = new Set(existingIdsArray);\n  const added = [];\n  const updated = [];\n  for (const entity of newEntities) {\n    const id = selectIdValue(entity, selectId);\n    if (existingIds.has(id)) {\n      updated.push({\n        id,\n        changes: entity\n      });\n    } else {\n      added.push(entity);\n    }\n  }\n  return [added, updated, existingIdsArray];\n}\n\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n  function addOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (key in state.entities) {\n      return;\n    }\n    state.ids.push(key);\n    state.entities[key] = entity;\n  }\n  function addManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      addOneMutably(entity, state);\n    }\n  }\n  function setOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n    if (!(key in state.entities)) {\n      state.ids.push(key);\n    }\n    ;\n    state.entities[key] = entity;\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    for (const entity of newEntities) {\n      setOneMutably(entity, state);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.ids = [];\n    state.entities = {};\n    addManyMutably(newEntities, state);\n  }\n  function removeOneMutably(key, state) {\n    return removeManyMutably([key], state);\n  }\n  function removeManyMutably(keys, state) {\n    let didMutate = false;\n    keys.forEach((key) => {\n      if (key in state.entities) {\n        delete state.entities[key];\n        didMutate = true;\n      }\n    });\n    if (didMutate) {\n      state.ids = state.ids.filter((id) => id in state.entities);\n    }\n  }\n  function removeAllMutably(state) {\n    Object.assign(state, {\n      ids: [],\n      entities: {}\n    });\n  }\n  function takeNewKey(keys, update, state) {\n    const original3 = state.entities[update.id];\n    if (original3 === void 0) {\n      return false;\n    }\n    const updated = Object.assign({}, original3, update.changes);\n    const newKey = selectIdValue(updated, selectId);\n    const hasNewKey = newKey !== update.id;\n    if (hasNewKey) {\n      keys[update.id] = newKey;\n      delete state.entities[update.id];\n    }\n    ;\n    state.entities[newKey] = updated;\n    return hasNewKey;\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    const newKeys = {};\n    const updatesPerEntity = {};\n    updates.forEach((update) => {\n      if (update.id in state.entities) {\n        updatesPerEntity[update.id] = {\n          id: update.id,\n          // Spreads ignore falsy values, so this works even if there isn't\n          // an existing update already at this key\n          changes: {\n            ...updatesPerEntity[update.id]?.changes,\n            ...update.changes\n          }\n        };\n      }\n    });\n    updates = Object.values(updatesPerEntity);\n    const didMutateEntities = updates.length > 0;\n    if (didMutateEntities) {\n      const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;\n      if (didMutateIds) {\n        state.ids = Object.values(state.entities).map((e) => selectIdValue(e, selectId));\n      }\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    updateManyMutably(updated, state);\n    addManyMutably(added, state);\n  }\n  return {\n    removeAll: createSingleArgumentStateOperator(removeAllMutably),\n    addOne: createStateOperator(addOneMutably),\n    addMany: createStateOperator(addManyMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    removeOne: createStateOperator(removeOneMutably),\n    removeMany: createStateOperator(removeManyMutably)\n  };\n}\n\n// src/entities/sorted_state_adapter.ts\nfunction findInsertIndex(sortedItems, item, comparisonFunction) {\n  let lowIndex = 0;\n  let highIndex = sortedItems.length;\n  while (lowIndex < highIndex) {\n    let middleIndex = lowIndex + highIndex >>> 1;\n    const currentItem = sortedItems[middleIndex];\n    const res = comparisonFunction(item, currentItem);\n    if (res >= 0) {\n      lowIndex = middleIndex + 1;\n    } else {\n      highIndex = middleIndex;\n    }\n  }\n  return lowIndex;\n}\nfunction insert(sortedItems, item, comparisonFunction) {\n  const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);\n  sortedItems.splice(insertAtIndex, 0, item);\n  return sortedItems;\n}\nfunction createSortedStateAdapter(selectId, comparer) {\n  const {\n    removeOne,\n    removeMany,\n    removeAll\n  } = createUnsortedStateAdapter(selectId);\n  function addOneMutably(entity, state) {\n    return addManyMutably([entity], state);\n  }\n  function addManyMutably(newEntities, state, existingIds) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const existingKeys = new Set(existingIds ?? getCurrent(state.ids));\n    const models = newEntities.filter((model) => !existingKeys.has(selectIdValue(model, selectId)));\n    if (models.length !== 0) {\n      mergeFunction(state, models);\n    }\n  }\n  function setOneMutably(entity, state) {\n    return setManyMutably([entity], state);\n  }\n  function setManyMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    if (newEntities.length !== 0) {\n      for (const item of newEntities) {\n        delete state.entities[selectId(item)];\n      }\n      mergeFunction(state, newEntities);\n    }\n  }\n  function setAllMutably(newEntities, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    state.entities = {};\n    state.ids = [];\n    addManyMutably(newEntities, state, []);\n  }\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n  function updateManyMutably(updates, state) {\n    let appliedUpdates = false;\n    let replacedIds = false;\n    for (let update of updates) {\n      const entity = state.entities[update.id];\n      if (!entity) {\n        continue;\n      }\n      appliedUpdates = true;\n      Object.assign(entity, update.changes);\n      const newId = selectId(entity);\n      if (update.id !== newId) {\n        replacedIds = true;\n        delete state.entities[update.id];\n        const oldIndex = state.ids.indexOf(update.id);\n        state.ids[oldIndex] = newId;\n        state.entities[newId] = entity;\n      }\n    }\n    if (appliedUpdates) {\n      mergeFunction(state, [], appliedUpdates, replacedIds);\n    }\n  }\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n  function upsertManyMutably(newEntities, state) {\n    const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);\n    if (updated.length) {\n      updateManyMutably(updated, state);\n    }\n    if (added.length) {\n      addManyMutably(added, state, existingIdsArray);\n    }\n  }\n  function areArraysEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] === b[i]) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  const mergeFunction = (state, addedItems, appliedUpdates, replacedIds) => {\n    const currentEntities = getCurrent(state.entities);\n    const currentIds = getCurrent(state.ids);\n    const stateEntities = state.entities;\n    let ids = currentIds;\n    if (replacedIds) {\n      ids = new Set(currentIds);\n    }\n    let sortedEntities = [];\n    for (const id of ids) {\n      const entity = currentEntities[id];\n      if (entity) {\n        sortedEntities.push(entity);\n      }\n    }\n    const wasPreviouslyEmpty = sortedEntities.length === 0;\n    for (const item of addedItems) {\n      stateEntities[selectId(item)] = item;\n      if (!wasPreviouslyEmpty) {\n        insert(sortedEntities, item, comparer);\n      }\n    }\n    if (wasPreviouslyEmpty) {\n      sortedEntities = addedItems.slice().sort(comparer);\n    } else if (appliedUpdates) {\n      sortedEntities.sort(comparer);\n    }\n    const newSortedIds = sortedEntities.map(selectId);\n    if (!areArraysEqual(currentIds, newSortedIds)) {\n      state.ids = newSortedIds;\n    }\n  };\n  return {\n    removeOne,\n    removeMany,\n    removeAll,\n    addOne: createStateOperator(addOneMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    addMany: createStateOperator(addManyMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertMany: createStateOperator(upsertManyMutably)\n  };\n}\n\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n  const {\n    selectId,\n    sortComparer\n  } = {\n    sortComparer: false,\n    selectId: (instance) => instance.id,\n    ...options\n  };\n  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n  const stateFactory = createInitialStateFactory(stateAdapter);\n  const selectorsFactory = createSelectorsFactory();\n  return {\n    selectId,\n    sortComparer,\n    ...stateFactory,\n    ...selectorsFactory,\n    ...stateAdapter\n  };\n}\n\n// src/listenerMiddleware/index.ts\n\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n  constructor(code) {\n    this.code = code;\n    this.message = `${task} ${cancelled} (reason: ${code})`;\n  }\n  name = \"TaskAbortError\";\n  message;\n};\n\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected) => {\n  if (typeof func !== \"function\") {\n    throw new TypeError( false ? 0 : `${expected} is not a function`);\n  }\n};\nvar noop2 = () => {\n};\nvar catchRejection = (promise, onError = noop2) => {\n  promise.catch(onError);\n  return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback) => {\n  abortSignal.addEventListener(\"abort\", callback, {\n    once: true\n  });\n  return () => abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason) => {\n  const signal = abortController.signal;\n  if (signal.aborted) {\n    return;\n  }\n  if (!(\"reason\" in signal)) {\n    Object.defineProperty(signal, \"reason\", {\n      enumerable: true,\n      value: reason,\n      configurable: true,\n      writable: true\n    });\n  }\n  ;\n  abortController.abort(reason);\n};\n\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal) => {\n  if (signal.aborted) {\n    const {\n      reason\n    } = signal;\n    throw new TaskAbortError(reason);\n  }\n};\nfunction raceWithSignal(signal, promise) {\n  let cleanup = noop2;\n  return new Promise((resolve, reject) => {\n    const notifyRejection = () => reject(new TaskAbortError(signal.reason));\n    if (signal.aborted) {\n      notifyRejection();\n      return;\n    }\n    cleanup = addAbortSignalListener(signal, notifyRejection);\n    promise.finally(() => cleanup()).then(resolve, reject);\n  }).finally(() => {\n    cleanup = noop2;\n  });\n}\nvar runTask = async (task2, cleanUp) => {\n  try {\n    await Promise.resolve();\n    const value = await task2();\n    return {\n      status: \"ok\",\n      value\n    };\n  } catch (error) {\n    return {\n      status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n      error\n    };\n  } finally {\n    cleanUp?.();\n  }\n};\nvar createPause = (signal) => {\n  return (promise) => {\n    return catchRejection(raceWithSignal(signal, promise).then((output) => {\n      validateActive(signal);\n      return output;\n    }));\n  };\n};\nvar createDelay = (signal) => {\n  const pause = createPause(signal);\n  return (timeoutMs) => {\n    return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));\n  };\n};\n\n// src/listenerMiddleware/index.ts\nvar {\n  assign\n} = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises) => {\n  const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));\n  return (taskExecutor, opts) => {\n    assertFunction(taskExecutor, \"taskExecutor\");\n    const childAbortController = new AbortController();\n    linkControllers(childAbortController);\n    const result = runTask(async () => {\n      validateActive(parentAbortSignal);\n      validateActive(childAbortController.signal);\n      const result2 = await taskExecutor({\n        pause: createPause(childAbortController.signal),\n        delay: createDelay(childAbortController.signal),\n        signal: childAbortController.signal\n      });\n      validateActive(childAbortController.signal);\n      return result2;\n    }, () => abortControllerWithReason(childAbortController, taskCompleted));\n    if (opts?.autoJoin) {\n      parentBlockingPromises.push(result.catch(noop2));\n    }\n    return {\n      result: createPause(parentAbortSignal)(result),\n      cancel() {\n        abortControllerWithReason(childAbortController, taskCancelled);\n      }\n    };\n  };\n};\nvar createTakePattern = (startListening, signal) => {\n  const take = async (predicate, timeout) => {\n    validateActive(signal);\n    let unsubscribe = () => {\n    };\n    const tuplePromise = new Promise((resolve, reject) => {\n      let stopListening = startListening({\n        predicate,\n        effect: (action, listenerApi) => {\n          listenerApi.unsubscribe();\n          resolve([action, listenerApi.getState(), listenerApi.getOriginalState()]);\n        }\n      });\n      unsubscribe = () => {\n        stopListening();\n        reject();\n      };\n    });\n    const promises = [tuplePromise];\n    if (timeout != null) {\n      promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));\n    }\n    try {\n      const output = await raceWithSignal(signal, Promise.race(promises));\n      validateActive(signal);\n      return output;\n    } finally {\n      unsubscribe();\n    }\n  };\n  return (predicate, timeout) => catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options) => {\n  let {\n    type,\n    actionCreator,\n    matcher,\n    predicate,\n    effect\n  } = options;\n  if (type) {\n    predicate = createAction(type).match;\n  } else if (actionCreator) {\n    type = actionCreator.type;\n    predicate = actionCreator.match;\n  } else if (matcher) {\n    predicate = matcher;\n  } else if (predicate) {\n  } else {\n    throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n  }\n  assertFunction(effect, \"options.listener\");\n  return {\n    predicate,\n    type,\n    effect\n  };\n};\nvar createListenerEntry = /* @__PURE__ */ assign((options) => {\n  const {\n    type,\n    predicate,\n    effect\n  } = getListenerEntryPropsFrom(options);\n  const entry = {\n    id: nanoid(),\n    effect,\n    type,\n    predicate,\n    pending: /* @__PURE__ */ new Set(),\n    unsubscribe: () => {\n      throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n    }\n  };\n  return entry;\n}, {\n  withTypes: () => createListenerEntry\n});\nvar findListenerEntry = (listenerMap, options) => {\n  const {\n    type,\n    effect,\n    predicate\n  } = getListenerEntryPropsFrom(options);\n  return Array.from(listenerMap.values()).find((entry) => {\n    const matchPredicateOrType = typeof type === \"string\" ? entry.type === type : entry.predicate === predicate;\n    return matchPredicateOrType && entry.effect === effect;\n  });\n};\nvar cancelActiveListeners = (entry) => {\n  entry.pending.forEach((controller) => {\n    abortControllerWithReason(controller, listenerCancelled);\n  });\n};\nvar createClearListenerMiddleware = (listenerMap) => {\n  return () => {\n    listenerMap.forEach(cancelActiveListeners);\n    listenerMap.clear();\n  };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {\n  try {\n    errorHandler(errorToNotify, errorInfo);\n  } catch (errorHandlerError) {\n    setTimeout(() => {\n      throw errorHandlerError;\n    }, 0);\n  }\n};\nvar addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {\n  withTypes: () => addListener\n});\nvar clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);\nvar removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {\n  withTypes: () => removeListener\n});\nvar defaultErrorHandler = (...args) => {\n  console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {}) => {\n  const listenerMap = /* @__PURE__ */ new Map();\n  const {\n    extra,\n    onError = defaultErrorHandler\n  } = middlewareOptions;\n  assertFunction(onError, \"onError\");\n  const insertEntry = (entry) => {\n    entry.unsubscribe = () => listenerMap.delete(entry.id);\n    listenerMap.set(entry.id, entry);\n    return (cancelOptions) => {\n      entry.unsubscribe();\n      if (cancelOptions?.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    };\n  };\n  const startListening = (options) => {\n    const entry = findListenerEntry(listenerMap, options) ?? createListenerEntry(options);\n    return insertEntry(entry);\n  };\n  assign(startListening, {\n    withTypes: () => startListening\n  });\n  const stopListening = (options) => {\n    const entry = findListenerEntry(listenerMap, options);\n    if (entry) {\n      entry.unsubscribe();\n      if (options.cancelActive) {\n        cancelActiveListeners(entry);\n      }\n    }\n    return !!entry;\n  };\n  assign(stopListening, {\n    withTypes: () => stopListening\n  });\n  const notifyListener = async (entry, action, api, getOriginalState) => {\n    const internalTaskController = new AbortController();\n    const take = createTakePattern(startListening, internalTaskController.signal);\n    const autoJoinPromises = [];\n    try {\n      entry.pending.add(internalTaskController);\n      await Promise.resolve(entry.effect(\n        action,\n        // Use assign() rather than ... to avoid extra helper functions added to bundle\n        assign({}, api, {\n          getOriginalState,\n          condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),\n          take,\n          delay: createDelay(internalTaskController.signal),\n          pause: createPause(internalTaskController.signal),\n          extra,\n          signal: internalTaskController.signal,\n          fork: createFork(internalTaskController.signal, autoJoinPromises),\n          unsubscribe: entry.unsubscribe,\n          subscribe: () => {\n            listenerMap.set(entry.id, entry);\n          },\n          cancelActiveListeners: () => {\n            entry.pending.forEach((controller, _, set) => {\n              if (controller !== internalTaskController) {\n                abortControllerWithReason(controller, listenerCancelled);\n                set.delete(controller);\n              }\n            });\n          },\n          cancel: () => {\n            abortControllerWithReason(internalTaskController, listenerCancelled);\n            entry.pending.delete(internalTaskController);\n          },\n          throwIfCancelled: () => {\n            validateActive(internalTaskController.signal);\n          }\n        })\n      ));\n    } catch (listenerError) {\n      if (!(listenerError instanceof TaskAbortError)) {\n        safelyNotifyError(onError, listenerError, {\n          raisedBy: \"effect\"\n        });\n      }\n    } finally {\n      await Promise.all(autoJoinPromises);\n      abortControllerWithReason(internalTaskController, listenerCompleted);\n      entry.pending.delete(internalTaskController);\n    }\n  };\n  const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n  const middleware = (api) => (next) => (action) => {\n    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n      return next(action);\n    }\n    if (addListener.match(action)) {\n      return startListening(action.payload);\n    }\n    if (clearAllListeners.match(action)) {\n      clearListenerMiddleware();\n      return;\n    }\n    if (removeListener.match(action)) {\n      return stopListening(action.payload);\n    }\n    let originalState = api.getState();\n    const getOriginalState = () => {\n      if (originalState === INTERNAL_NIL_TOKEN) {\n        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n      }\n      return originalState;\n    };\n    let result;\n    try {\n      result = next(action);\n      if (listenerMap.size > 0) {\n        const currentState = api.getState();\n        const listenerEntries = Array.from(listenerMap.values());\n        for (const entry of listenerEntries) {\n          let runListener = false;\n          try {\n            runListener = entry.predicate(action, currentState, originalState);\n          } catch (predicateError) {\n            runListener = false;\n            safelyNotifyError(onError, predicateError, {\n              raisedBy: \"predicate\"\n            });\n          }\n          if (!runListener) {\n            continue;\n          }\n          notifyListener(entry, action, api, getOriginalState);\n        }\n      }\n    } finally {\n      originalState = INTERNAL_NIL_TOKEN;\n    }\n    return result;\n  };\n  return {\n    middleware,\n    startListening,\n    stopListening,\n    clearListeners: clearListenerMiddleware\n  };\n};\n\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware) => ({\n  middleware,\n  applied: /* @__PURE__ */ new Map()\n});\nvar matchInstance = (instanceId) => (action) => action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = () => {\n  const instanceId = nanoid();\n  const middlewareMap = /* @__PURE__ */ new Map();\n  const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares) => ({\n    payload: middlewares,\n    meta: {\n      instanceId\n    }\n  })), {\n    withTypes: () => withMiddleware\n  });\n  const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n    middlewares.forEach((middleware2) => {\n      getOrInsertComputed(middlewareMap, middleware2, createMiddlewareEntry);\n    });\n  }, {\n    withTypes: () => addMiddleware\n  });\n  const getFinalMiddleware = (api) => {\n    const appliedMiddleware = Array.from(middlewareMap.values()).map((entry) => getOrInsertComputed(entry.applied, api, entry.middleware));\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n  };\n  const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n  const middleware = (api) => (next) => (action) => {\n    if (isWithMiddleware(action)) {\n      addMiddleware(...action.payload);\n      return api.dispatch;\n    }\n    return getFinalMiddleware(api)(next)(action);\n  };\n  return {\n    middleware,\n    addMiddleware,\n    withMiddleware,\n    instanceId\n  };\n};\n\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike) => \"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices) => slices.flatMap((sliceOrMap) => isSliceLike(sliceOrMap) ? [[sliceOrMap.reducerPath, sliceOrMap.reducer]] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value) => !!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap) => getOrInsertComputed(stateProxyMap, state, () => new Proxy(state, {\n  get: (target, prop, receiver) => {\n    if (prop === ORIGINAL_STATE) return target;\n    const result = Reflect.get(target, prop, receiver);\n    if (typeof result === \"undefined\") {\n      const reducer = reducerMap[prop.toString()];\n      if (reducer) {\n        const reducerResult = reducer(void 0, {\n          type: nanoid()\n        });\n        if (typeof reducerResult === \"undefined\") {\n          throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n        }\n        return reducerResult;\n      }\n    }\n    return result;\n  }\n}));\nvar original = (state) => {\n  if (!isStateProxy(state)) {\n    throw new Error( false ? 0 : \"original must be used on state Proxy\");\n  }\n  return state[ORIGINAL_STATE];\n};\nvar noopReducer = (state = {}) => state;\nfunction combineSlices(...slices) {\n  const reducerMap = Object.fromEntries(getReducers(slices));\n  const getReducer = () => Object.keys(reducerMap).length ? (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap) : noopReducer;\n  let reducer = getReducer();\n  function combinedReducer(state, action) {\n    return reducer(state, action);\n  }\n  combinedReducer.withLazyLoadedSlices = () => combinedReducer;\n  const inject = (slice, config = {}) => {\n    const {\n      reducerPath,\n      reducer: reducerToInject\n    } = slice;\n    const currentReducer = reducerMap[reducerPath];\n    if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n      if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n        console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n      }\n      return combinedReducer;\n    }\n    reducerMap[reducerPath] = reducerToInject;\n    reducer = getReducer();\n    return combinedReducer;\n  };\n  const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n    return function selector2(state, ...args) {\n      return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n    };\n  }, {\n    original\n  });\n  return Object.assign(combinedReducer, {\n    inject,\n    selector\n  });\n}\n\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n  return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n\n//# sourceMappingURL=redux-toolkit.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDc0I7QUFDbUY7QUFDaUM7O0FBRTFJO0FBQ3lDO0FBQ3dCO0FBQ2pFO0FBQ0EsMEJBQTBCLCtEQUFxQjtBQUMvQztBQUNBO0FBQ0EseURBQXlELDhDQUFPLFVBQVUsOENBQU87QUFDakY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkVBQTZFLG9EQUFjOztBQUUzRjtBQUM0SDs7QUFFNUg7QUFDZ0M7QUFDaEM7QUFDQTtBQUNBLCtDQUErQywwQ0FBTztBQUN0RCxTQUFTLDBDQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwRTs7QUFFMUU7QUFDaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFxQyxHQUFHLENBQXlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0Esb0NBQW9DLCtDQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQ0FBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFLGtGQUFrRixXQUFXLDhCQUE4QixXQUFXO0FBQ3RJO0FBQ0EsNERBQTREO0FBQzVELE1BQU0sS0FBcUMsRUFBRSxFQUUxQztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxPQUFPLFFBQVEsa0RBQWtELFNBQVM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtEQUFXLFFBQVEsOENBQWU7QUFDM0MsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxNQUFNLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFxQyxHQUFHLENBQTBCLHFFQUFxRSxrQkFBa0I7QUFDckw7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQXFDLEdBQUcsQ0FBMEIsb0VBQW9FLGtCQUFrQixzREFBc0QsbUJBQW1CO0FBQzdQO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBO0FBQ0EsOEdBQThHLG9EQUFhO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsTUFBTSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsV0FBVywrQ0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGdHQUFnRyxRQUFRO0FBQ3hHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnR0FBZ0csUUFBUTtBQUN4RywyREFBMkQsWUFBWTtBQUN2RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQWU7QUFDMUMsTUFBTTtBQUNOLDJCQUEyQiw4REFBaUI7QUFDNUM7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUksU0FBUyxvREFBYztBQUMzQixrQkFBa0Isc0RBQWU7QUFDakMsSUFBSTtBQUNKLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0EsTUFBTSxLQUFxQztBQUMzQyxvQkFBb0IsTUFBcUMsR0FBRyxDQUF5QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0Msc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDdkY7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0Msb0JBQW9CLE1BQXFDLEdBQUcsQ0FBeUI7QUFDckY7QUFDQSxxQkFBcUIsMENBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFvQjtBQUNqQztBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QixzREFBZTtBQUM1QztBQUNBLE1BQU0sS0FBcUM7QUFDM0Msb0JBQW9CLE1BQXFDLEdBQUcsQ0FBeUI7QUFDckY7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0Msb0JBQW9CLE1BQXFDLEdBQUcsQ0FBeUI7QUFDckY7QUFDQSxNQUFNLEtBQXFDO0FBQzNDLG9CQUFvQixNQUFxQyxHQUFHLENBQXlCO0FBQ3JGO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTLGtEQUFXO0FBQ3BCOztBQUVBO0FBQ3NHOztBQUV0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQSwwQkFBMEIsTUFBcUMsR0FBRyxDQUEwQjtBQUM1RjtBQUNBO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBcUMsR0FBRyxDQUEwQjtBQUMxRjtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBMEIsdUZBQXVGLEtBQUs7QUFDdEw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVUsa0RBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpQkFBaUIsOENBQWdCO0FBQ2pDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBLFlBQVksTUFBTSxHQUFHLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQTBCO0FBQ3hGO0FBQ0EsZUFBZSxPQUFPLG9CQUFvQixhQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTBCO0FBQzVGO0FBQ0E7QUFDQSwwQkFBMEIsTUFBcUMsR0FBRyxDQUEwQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQSwwQkFBMEIsTUFBcUMsR0FBRyxDQUEwQjtBQUM1RjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTLElBQXFDO0FBQzFELDRCQUE0QixNQUFxQyxHQUFHLENBQTBCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUyxJQUFxQztBQUN0RCx3QkFBd0IsTUFBcUMsR0FBRyxDQUEwQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0JBQW9CLE1BQXFDLEdBQUcsQ0FBMEIsMEZBQTBGLFlBQVksaUNBQWlDO0FBQzdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lFO0FBQ3pFLG1CQUFtQiwwQ0FBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBZ0I7QUFDM0I7QUFDQTs7QUFFQTtBQUNpRTtBQUNqRTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBUSxVQUFVLDhDQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEMsNEJBQTRCLFVBQVU7QUFDdEMsMkJBQTJCLFNBQVMsR0FBRyxVQUFVO0FBQ2pELDJCQUEyQixTQUFTLEdBQUcsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTSxFQUFFLFdBQVcsV0FBVyxLQUFLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFxQyxHQUFHLENBQTBCLE1BQU0sVUFBVTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKLG9CQUFvQixNQUFxQyxHQUFHLENBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlFQUF5RSxJQUFJO0FBQzdFO0FBQ0EsQ0FBQztBQUNELHdEQUF3RCxJQUFJO0FBQzVELDRFQUE0RSxJQUFJO0FBQ2hGO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0NBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBMEIsTUFBTSxJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVyw4Q0FBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCLE1BQXFDLEdBQUcsQ0FBMEIsaUNBQWlDLGdCQUFnQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNERBQTRELHNEQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sb0JBQW9CLGFBQW9CO0FBQ2hFLGdGQUFnRixhQUFhO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTyxpREFBaUQsTUFBTTtBQUN4RztBQW9ERTtBQUNGIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXEByZWR1eGpzXFx0b29sa2l0XFxkaXN0XFxyZWR1eC10b29sa2l0Lm1vZGVybi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicmVkdXhcIjtcbmltcG9ydCB7IHByb2R1Y2UsIGN1cnJlbnQgYXMgY3VycmVudDMsIGZyZWV6ZSwgb3JpZ2luYWwgYXMgb3JpZ2luYWwyLCBpc0RyYWZ0IGFzIGlzRHJhZnQ1IH0gZnJvbSBcImltbWVyXCI7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JDcmVhdG9yIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjIsIGxydU1lbW9pemUsIHdlYWtNYXBNZW1vaXplIGFzIHdlYWtNYXBNZW1vaXplMiB9IGZyb20gXCJyZXNlbGVjdFwiO1xuXG4vLyBzcmMvY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IudHNcbmltcG9ydCB7IGN1cnJlbnQsIGlzRHJhZnQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciwgd2Vha01hcE1lbW9pemUgfSBmcm9tIFwicmVzZWxlY3RcIjtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSBjcmVhdGVTZWxlY3RvckNyZWF0b3IoLi4uYXJncyk7XG4gIGNvbnN0IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMiA9IE9iamVjdC5hc3NpZ24oKC4uLmFyZ3MyKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcjIoLi4uYXJnczIpO1xuICAgIGNvbnN0IHdyYXBwZWRTZWxlY3RvciA9ICh2YWx1ZSwgLi4ucmVzdCkgPT4gc2VsZWN0b3IoaXNEcmFmdCh2YWx1ZSkgPyBjdXJyZW50KHZhbHVlKSA6IHZhbHVlLCAuLi5yZXN0KTtcbiAgICBPYmplY3QuYXNzaWduKHdyYXBwZWRTZWxlY3Rvciwgc2VsZWN0b3IpO1xuICAgIHJldHVybiB3cmFwcGVkU2VsZWN0b3I7XG4gIH0sIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yMjtcbn07XG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yKHdlYWtNYXBNZW1vaXplKTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG5pbXBvcnQgeyBhcHBseU1pZGRsZXdhcmUsIGNyZWF0ZVN0b3JlLCBjb21wb3NlIGFzIGNvbXBvc2UyLCBjb21iaW5lUmVkdWNlcnMsIGlzUGxhaW5PYmplY3QgYXMgaXNQbGFpbk9iamVjdDIgfSBmcm9tIFwicmVkdXhcIjtcblxuLy8gc3JjL2RldnRvb2xzRXh0ZW5zaW9uLnRzXG5pbXBvcnQgeyBjb21wb3NlIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY29tcG9zZVdpdGhEZXZUb29scyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gOiBmdW5jdGlvbigpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKSByZXR1cm4gY29tcG9zZTtcbiAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24obm9vcDMpIHtcbiAgICByZXR1cm4gbm9vcDM7XG4gIH07XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IHRodW5rIGFzIHRodW5rTWlkZGxld2FyZSwgd2l0aEV4dHJhQXJndW1lbnQgfSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuaW1wb3J0IHsgaXNBY3Rpb24gfSBmcm9tIFwicmVkdXhcIjtcblxuLy8gc3JjL3RzSGVscGVycy50c1xudmFyIGhhc01hdGNoRnVuY3Rpb24gPSAodikgPT4ge1xuICByZXR1cm4gdiAmJiB0eXBlb2Ygdi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcbiAgICAgIGxldCBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24oLi4uYXJncyk7XG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHByZXBhcmVkLnBheWxvYWQsXG4gICAgICAgIC4uLlwibWV0YVwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICAgIH0sXG4gICAgICAgIC4uLlwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogYXJnc1swXVxuICAgIH07XG4gIH1cbiAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9ICgpID0+IGAke3R5cGV9YDtcbiAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb24pID0+IGlzQWN0aW9uKGFjdGlvbikgJiYgYWN0aW9uLnR5cGUgPT09IHR5cGU7XG4gIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufVxuZnVuY3Rpb24gaXNBY3Rpb25DcmVhdG9yKGFjdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiAvLyBoYXNNYXRjaEZ1bmN0aW9uIG9ubHkgd2FudHMgTWF0Y2hlcnMgYnV0IEkgZG9uJ3Qgc2VlIHRoZSBwb2ludCBpbiByZXdyaXRpbmcgaXRcbiAgaGFzTWF0Y2hGdW5jdGlvbihhY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XG4gIHJldHVybiBpc0FjdGlvbihhY3Rpb24pICYmIE9iamVjdC5rZXlzKGFjdGlvbikuZXZlcnkoaXNWYWxpZEtleSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gW1widHlwZVwiLCBcInBheWxvYWRcIiwgXCJlcnJvclwiLCBcIm1ldGFcIl0uaW5kZXhPZihrZXkpID4gLTE7XG59XG5cbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZ2V0TWVzc2FnZSh0eXBlKSB7XG4gIGNvbnN0IHNwbGl0VHlwZSA9IHR5cGUgPyBgJHt0eXBlfWAuc3BsaXQoXCIvXCIpIDogW107XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSBzcGxpdFR5cGVbc3BsaXRUeXBlLmxlbmd0aCAtIDFdIHx8IFwiYWN0aW9uQ3JlYXRvclwiO1xuICByZXR1cm4gYERldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcIiR7dHlwZSB8fCBcInVua25vd25cIn1cIiBiZWluZyBkaXNwYXRjaGVkLiBcbk1ha2Ugc3VyZSB5b3UncmUgY2FsbGluZyB0aGUgYWN0aW9uIGNyZWF0b3IgYmVmb3JlIGRpc3BhdGNoaW5nLCBpLmUuIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0oKSlcXGAgaW5zdGVhZCBvZiBcXGBkaXNwYXRjaCgke2FjdGlvbk5hbWV9KVxcYC4gVGhpcyBpcyBuZWNlc3NhcnkgZXZlbiBpZiB0aGUgYWN0aW9uIGhhcyBubyBwYXlsb2FkLmA7XG59XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpc0FjdGlvbkNyZWF0b3I6IGlzQWN0aW9uQ3JlYXRvcjIgPSBpc0FjdGlvbkNyZWF0b3JcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc0FjdGlvbkNyZWF0b3IyKGFjdGlvbikpIHtcbiAgICAgIGNvbnNvbGUud2FybihnZXRNZXNzYWdlKGFjdGlvbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsIGlzRHJhZnRhYmxlIH0gZnJvbSBcImltbWVyXCI7XG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcbiAgbGV0IGVsYXBzZWQgPSAwO1xuICByZXR1cm4ge1xuICAgIG1lYXN1cmVUaW1lKGZuKSB7XG4gICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgZmluaXNoZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhcm5JZkV4Y2VlZGVkKCkge1xuICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7Zm5OYW1lfSB0b29rICR7ZWxhcHNlZH1tcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiAke21heERlbGF5fW1zLiBcbklmIHlvdXIgc3RhdGUgb3IgYWN0aW9ucyBhcmUgdmVyeSBsYXJnZSwgeW91IG1heSB3YW50IHRvIGRpc2FibGUgdGhlIG1pZGRsZXdhcmUgYXMgaXQgbWlnaHQgY2F1c2UgdG9vIG11Y2ggb2YgYSBzbG93ZG93biBpbiBkZXZlbG9wbWVudCBtb2RlLiBTZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvZ2V0RGVmYXVsdE1pZGRsZXdhcmUgZm9yIGluc3RydWN0aW9ucy5cbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LmApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBUdXBsZSA9IGNsYXNzIF9UdXBsZSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoLi4uaXRlbXMpIHtcbiAgICBzdXBlciguLi5pdGVtcyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9UdXBsZS5wcm90b3R5cGUpO1xuICB9XG4gIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSgpIHtcbiAgICByZXR1cm4gX1R1cGxlO1xuICB9XG4gIGNvbmNhdCguLi5hcnIpIHtcbiAgICByZXR1cm4gc3VwZXIuY29uY2F0LmFwcGx5KHRoaXMsIGFycik7XG4gIH1cbiAgcHJlcGVuZCguLi5hcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcbiAgICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyclswXS5jb25jYXQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnIuY29uY2F0KHRoaXMpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZyZWV6ZURyYWZ0YWJsZSh2YWwpIHtcbiAgcmV0dXJuIGlzRHJhZnRhYmxlKHZhbCkgPyBjcmVhdGVOZXh0U3RhdGUodmFsLCAoKSA9PiB7XG4gIH0pIDogdmFsO1xufVxuZnVuY3Rpb24gZ2V0T3JJbnNlcnRDb21wdXRlZChtYXAsIGtleSwgY29tcHV0ZSkge1xuICBpZiAobWFwLmhhcyhrZXkpKSByZXR1cm4gbWFwLmdldChrZXkpO1xuICByZXR1cm4gbWFwLnNldChrZXksIGNvbXB1dGUoa2V5KSkuZ2V0KGtleSk7XG59XG5cbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzSW1tdXRhYmxlRGVmYXVsdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKSB7XG4gIGNvbnN0IHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcbiAgcmV0dXJuIHtcbiAgICBkZXRlY3RNdXRhdGlvbnMoKSB7XG4gICAgICByZXR1cm4gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnRpZXMsIG9iaik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocyA9IFtdLCBvYmosIHBhdGggPSBcIlwiLCBjaGVja2VkT2JqZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpIHtcbiAgY29uc3QgdHJhY2tlZCA9IHtcbiAgICB2YWx1ZTogb2JqXG4gIH07XG4gIGlmICghaXNJbW11dGFibGUob2JqKSAmJiAhY2hlY2tlZE9iamVjdHMuaGFzKG9iaikpIHtcbiAgICBjaGVja2VkT2JqZWN0cy5hZGQob2JqKTtcbiAgICB0cmFja2VkLmNoaWxkcmVuID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgICAgaWYgKGlnbm9yZVBhdGhzLmxlbmd0aCAmJiBpZ25vcmVQYXRocy5pbmRleE9mKGNoaWxkUGF0aCkgIT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqW2tleV0sIGNoaWxkUGF0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja2VkO1xufVxuZnVuY3Rpb24gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMgPSBbXSwgdHJhY2tlZFByb3BlcnR5LCBvYmosIHNhbWVQYXJlbnRSZWYgPSBmYWxzZSwgcGF0aCA9IFwiXCIpIHtcbiAgY29uc3QgcHJldk9iaiA9IHRyYWNrZWRQcm9wZXJ0eSA/IHRyYWNrZWRQcm9wZXJ0eS52YWx1ZSA6IHZvaWQgMDtcbiAgY29uc3Qgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcbiAgaWYgKHNhbWVQYXJlbnRSZWYgJiYgIXNhbWVSZWYgJiYgIU51bWJlci5pc05hTihvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IHRydWUsXG4gICAgICBwYXRoXG4gICAgfTtcbiAgfVxuICBpZiAoaXNJbW11dGFibGUocHJldk9iaikgfHwgaXNJbW11dGFibGUob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29uc3Qga2V5c1RvRGV0ZWN0ID0ge307XG4gIGZvciAobGV0IGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChsZXQga2V5IGluIGtleXNUb0RldGVjdCkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocywgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sIG9ialtrZXldLCBzYW1lUmVmLCBuZXN0ZWRQYXRoKTtcbiAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGxldCBzdHJpbmdpZnkyID0gZnVuY3Rpb24ob2JqLCBzZXJpYWxpemVyLCBpbmRlbnQsIGRlY3ljbGVyKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUyKHNlcmlhbGl6ZXIsIGRlY3ljbGVyKSwgaW5kZW50KTtcbiAgICB9LCBnZXRTZXJpYWxpemUyID0gZnVuY3Rpb24oc2VyaWFsaXplciwgZGVjeWNsZXIpIHtcbiAgICAgIGxldCBzdGFjayA9IFtdLCBrZXlzID0gW107XG4gICAgICBpZiAoIWRlY3ljbGVyKSBkZWN5Y2xlciA9IGZ1bmN0aW9uKF8sIHZhbHVlKSB7XG4gICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHJldHVybiBcIltDaXJjdWxhciB+XVwiO1xuICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Ugc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5MiwgZ2V0U2VyaWFsaXplID0gZ2V0U2VyaWFsaXplMjtcbiAgICBsZXQge1xuICAgICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXG4gICAgICBpZ25vcmVkUGF0aHMsXG4gICAgICB3YXJuQWZ0ZXIgPSAzMlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcbiAgICByZXR1cm4gKHtcbiAgICAgIGdldFN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHJldHVybiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9Jy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlZEFjdGlvbiA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjApIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogJHtyZXN1bHQucGF0aCB8fCBcIlwifS4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiAke3N0cmluZ2lmeTIoYWN0aW9uKX0uIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiBhcyBpc0FjdGlvbjIsIGlzUGxhaW5PYmplY3QgfSBmcm9tIFwicmVkdXhcIjtcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiLCBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocyA9IFtdLCBjYWNoZSkge1xuICBsZXQgZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleVBhdGg6IHBhdGggfHwgXCI8cm9vdD5cIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjYWNoZT8uaGFzKHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBlbnRyaWVzID0gZ2V0RW50cmllcyAhPSBudWxsID8gZ2V0RW50cmllcyh2YWx1ZSkgOiBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGNvbnN0IFtrZXksIG5lc3RlZFZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNTZXJpYWxpemFibGUobmVzdGVkVmFsdWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLFxuICAgICAgICB2YWx1ZTogbmVzdGVkVmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKG5lc3RlZFZhbHVlLCBuZXN0ZWRQYXRoLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICBpZiAoZm91bmROZXN0ZWRTZXJpYWxpemFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY2FjaGUgJiYgaXNOZXN0ZWRGcm96ZW4odmFsdWUpKSBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBuZXN0ZWRWYWx1ZSBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgbmVzdGVkVmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sXG4gICAgICBnZXRFbnRyaWVzLFxuICAgICAgaWdub3JlZEFjdGlvbnMgPSBbXSxcbiAgICAgIGlnbm9yZWRBY3Rpb25QYXRocyA9IFtcIm1ldGEuYXJnXCIsIFwibWV0YS5iYXNlUXVlcnlNZXRhXCJdLFxuICAgICAgaWdub3JlZFBhdGhzID0gW10sXG4gICAgICB3YXJuQWZ0ZXIgPSAzMixcbiAgICAgIGlnbm9yZVN0YXRlID0gZmFsc2UsXG4gICAgICBpZ25vcmVBY3Rpb25zID0gZmFsc2UsXG4gICAgICBkaXNhYmxlQ2FjaGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNhY2hlID0gIWRpc2FibGVDYWNoZSAmJiBXZWFrU2V0ID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIChzdG9yZUFQSSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICAgIGlmICghaXNBY3Rpb24yKGFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIlNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgIGlmICghaWdub3JlQWN0aW9ucyAmJiAhKGlnbm9yZWRBY3Rpb25zLmxlbmd0aCAmJiBpZ25vcmVkQWN0aW9ucy5pbmRleE9mKGFjdGlvbi50eXBlKSAhPT0gLTEpKSB7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShhY3Rpb24sIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkQWN0aW9uUGF0aHMsIGNhY2hlKTtcbiAgICAgICAgICBpZiAoZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IFxcYCR7a2V5UGF0aH1cXGAuIFZhbHVlOmAsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSBsb2dpYyB0aGF0IGRpc3BhdGNoZWQgdGhpcyBhY3Rpb246IFwiLCBhY3Rpb24sIFwiXFxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvYWN0aW9ucyN3aHktc2hvdWxkLXR5cGUtYmUtYS1zdHJpbmctb3ItYXQtbGVhc3Qtc2VyaWFsaXphYmxlLXdoeS1zaG91bGQtbXktYWN0aW9uLXR5cGVzLWJlLWNvbnN0YW50cylcIiwgXCJcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlnbm9yZVN0YXRlKSB7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZUFQSS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShzdGF0ZSwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIHRoZSBzdGF0ZSwgaW4gdGhlIHBhdGg6IFxcYCR7a2V5UGF0aH1cXGAuIFZhbHVlOmAsIHZhbHVlLCBgXG5UYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGlzIGFjdGlvbiB0eXBlOiAke2FjdGlvbi50eXBlfS5cbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL29yZ2FuaXppbmctc3RhdGUjY2FuLWktcHV0LWZ1bmN0aW9ucy1wcm9taXNlcy1vci1vdGhlci1ub24tc2VyaWFsaXphYmxlLWl0ZW1zLWluLW15LXN0b3JlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNCb29sZWFuKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImJvb2xlYW5cIjtcbn1cbnZhciBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlID0gKCkgPT4gZnVuY3Rpb24gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgdGh1bmsgPSB0cnVlLFxuICAgIGltbXV0YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBzZXJpYWxpemFibGVDaGVjayA9IHRydWUsXG4gICAgYWN0aW9uQ3JlYXRvckNoZWNrID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IG1pZGRsZXdhcmVBcnJheSA9IG5ldyBUdXBsZSgpO1xuICBpZiAodGh1bmspIHtcbiAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2god2l0aEV4dHJhQXJndW1lbnQodGh1bmsuZXh0cmFBcmd1bWVudCkpO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgaW1tdXRhYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oaW1tdXRhYmxlQ2hlY2spKSB7XG4gICAgICAgIGltbXV0YWJsZU9wdGlvbnMgPSBpbW11dGFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShpbW11dGFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xuICAgICAgbGV0IHNlcmlhbGl6YWJsZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKHNlcmlhbGl6YWJsZUNoZWNrKSkge1xuICAgICAgICBzZXJpYWxpemFibGVPcHRpb25zID0gc2VyaWFsaXphYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaChjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoc2VyaWFsaXphYmxlT3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uQ3JlYXRvckNoZWNrKSB7XG4gICAgICBsZXQgYWN0aW9uQ3JlYXRvck9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGFjdGlvbkNyZWF0b3JDaGVjaykpIHtcbiAgICAgICAgYWN0aW9uQ3JlYXRvck9wdGlvbnMgPSBhY3Rpb25DcmVhdG9yQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShhY3Rpb25DcmVhdG9yT3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWlkZGxld2FyZUFycmF5O1xufTtcblxuLy8gc3JjL2F1dG9CYXRjaEVuaGFuY2VyLnRzXG52YXIgU0hPVUxEX0FVVE9CQVRDSCA9IFwiUlRLX2F1dG9CYXRjaFwiO1xudmFyIHByZXBhcmVBdXRvQmF0Y2hlZCA9ICgpID0+IChwYXlsb2FkKSA9PiAoe1xuICBwYXlsb2FkLFxuICBtZXRhOiB7XG4gICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gIH1cbn0pO1xudmFyIGNyZWF0ZVF1ZXVlV2l0aFRpbWVyID0gKHRpbWVvdXQpID0+IHtcbiAgcmV0dXJuIChub3RpZnkpID0+IHtcbiAgICBzZXRUaW1lb3V0KG5vdGlmeSwgdGltZW91dCk7XG4gIH07XG59O1xudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gKG9wdGlvbnMgPSB7XG4gIHR5cGU6IFwicmFmXCJcbn0pID0+IChuZXh0KSA9PiAoLi4uYXJncykgPT4ge1xuICBjb25zdCBzdG9yZSA9IG5leHQoLi4uYXJncyk7XG4gIGxldCBub3RpZnlpbmcgPSB0cnVlO1xuICBsZXQgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgbGV0IG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrIDogb3B0aW9ucy50eXBlID09PSBcInJhZlwiID8gKFxuICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3b24ndCBleGlzdCBpbiBTU1IgZW52aXJvbm1lbnRzLiBGYWxsIGJhY2sgdG8gYSB2YWd1ZSBhcHByb3hpbWF0aW9uIGp1c3QgdG8ga2VlcCBmcm9tIGVycm9yaW5nLlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBjcmVhdGVRdWV1ZVdpdGhUaW1lcigxMClcbiAgKSA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4gbCgpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdG9yZSwge1xuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5zdWJzY3JpYmVgIG1ldGhvZCB0byBrZWVwIG9yaWdpbmFsIGxpc3RlbmVyc1xuICAgIC8vIGZyb20gcnVubmluZyBpZiB3ZSdyZSBkZWxheWluZyBub3RpZmljYXRpb25zXG4gICAgc3Vic2NyaWJlKGxpc3RlbmVyMikge1xuICAgICAgY29uc3Qgd3JhcHBlZExpc3RlbmVyID0gKCkgPT4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUod3JhcHBlZExpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIyKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIyKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuZGlzcGF0Y2hgIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjaGVjayBhY3Rpb25zXG4gICAgLy8gZm9yIHRoZSBgc2hvdWxkQXV0b0JhdGNoYCBmbGFnIGFuZCBkZXRlcm1pbmUgaWYgYmF0Y2hpbmcgaXMgYWN0aXZlXG4gICAgZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBub3RpZnlpbmcgPSAhYWN0aW9uPy5tZXRhPy5bU0hPVUxEX0FVVE9CQVRDSF07XG4gICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gc3JjL2dldERlZmF1bHRFbmhhbmNlcnMudHNcbnZhciBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMgPSAobWlkZGxld2FyZUVuaGFuY2VyKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0RW5oYW5jZXJzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGF1dG9CYXRjaCA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBlbmhhbmNlckFycmF5ID0gbmV3IFR1cGxlKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmIChhdXRvQmF0Y2gpIHtcbiAgICBlbmhhbmNlckFycmF5LnB1c2goYXV0b0JhdGNoRW5oYW5jZXIodHlwZW9mIGF1dG9CYXRjaCA9PT0gXCJvYmplY3RcIiA/IGF1dG9CYXRjaCA6IHZvaWQgMCkpO1xuICB9XG4gIHJldHVybiBlbmhhbmNlckFycmF5O1xufTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XG4gIGNvbnN0IGdldERlZmF1bHRNaWRkbGV3YXJlID0gYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICBjb25zdCB7XG4gICAgcmVkdWNlciA9IHZvaWQgMCxcbiAgICBtaWRkbGV3YXJlLFxuICAgIGRldlRvb2xzID0gdHJ1ZSxcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHZvaWQgMCxcbiAgICBlbmhhbmNlcnMgPSB2b2lkIDBcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGxldCByb290UmVkdWNlcjtcbiAgaWYgKHR5cGVvZiByZWR1Y2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByb290UmVkdWNlciA9IHJlZHVjZXI7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdDIocmVkdWNlcikpIHtcbiAgICByb290UmVkdWNlciA9IGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2VyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxKSA6IFwiYHJlZHVjZXJgIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQsIGFuZCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IG9mIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gY29tYmluZVJlZHVjZXJzXCIpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBcImBtaWRkbGV3YXJlYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IGZpbmFsTWlkZGxld2FyZTtcbiAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlKGdldERlZmF1bHRNaWRkbGV3YXJlKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJ3aGVuIHVzaW5nIGEgbWlkZGxld2FyZSBidWlsZGVyIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBtaWRkbGV3YXJlIG11c3QgYmUgcmV0dXJuZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmFsTWlkZGxld2FyZSA9IGdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0KSA6IFwiZWFjaCBtaWRkbGV3YXJlIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBsZXQgZmluYWxDb21wb3NlID0gY29tcG9zZTI7XG4gIGlmIChkZXZUb29scykge1xuICAgIGZpbmFsQ29tcG9zZSA9IGNvbXBvc2VXaXRoRGV2VG9vbHMoe1xuICAgICAgLy8gRW5hYmxlIGNhcHR1cmUgb2Ygc3RhY2sgdHJhY2VzIGZvciBkaXNwYXRjaGVkIFJlZHV4IGFjdGlvbnNcbiAgICAgIHRyYWNlOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIsXG4gICAgICAuLi50eXBlb2YgZGV2VG9vbHMgPT09IFwib2JqZWN0XCIgJiYgZGV2VG9vbHNcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUoLi4uZmluYWxNaWRkbGV3YXJlKTtcbiAgY29uc3QgZ2V0RGVmYXVsdEVuaGFuY2VycyA9IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyhtaWRkbGV3YXJlRW5oYW5jZXIpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGVuaGFuY2VycyAmJiB0eXBlb2YgZW5oYW5jZXJzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IFwiYGVuaGFuY2Vyc2AgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBzdG9yZUVuaGFuY2VycyA9IHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGVuaGFuY2VycyhnZXREZWZhdWx0RW5oYW5jZXJzKSA6IGdldERlZmF1bHRFbmhhbmNlcnMoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhQXJyYXkuaXNBcnJheShzdG9yZUVuaGFuY2VycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6IFwiYGVuaGFuY2Vyc2AgY2FsbGJhY2sgbXVzdCByZXR1cm4gYW4gYXJyYXlcIik7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBzdG9yZUVuaGFuY2Vycy5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDcpIDogXCJlYWNoIGVuaGFuY2VyIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZpbmFsTWlkZGxld2FyZS5sZW5ndGggJiYgIXN0b3JlRW5oYW5jZXJzLmluY2x1ZGVzKG1pZGRsZXdhcmVFbmhhbmNlcikpIHtcbiAgICBjb25zb2xlLmVycm9yKFwibWlkZGxld2FyZXMgd2VyZSBwcm92aWRlZCwgYnV0IG1pZGRsZXdhcmUgZW5oYW5jZXIgd2FzIG5vdCBpbmNsdWRlZCBpbiBmaW5hbCBlbmhhbmNlcnMgLSBtYWtlIHN1cmUgdG8gY2FsbCBgZ2V0RGVmYXVsdEVuaGFuY2Vyc2BcIik7XG4gIH1cbiAgY29uc3QgY29tcG9zZWRFbmhhbmNlciA9IGZpbmFsQ29tcG9zZSguLi5zdG9yZUVuaGFuY2Vycyk7XG4gIHJldHVybiBjcmVhdGVTdG9yZShyb290UmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGNvbXBvc2VkRW5oYW5jZXIpO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUyLCBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcbiAgY29uc3QgYWN0aW9uc01hcCA9IHt9O1xuICBjb25zdCBhY3Rpb25NYXRjaGVycyA9IFtdO1xuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xuICBjb25zdCBidWlsZGVyID0ge1xuICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoYWN0aW9uTWF0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI2KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNykgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjgpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5KSA6IGBcXGBidWlsZGVyLmFkZENhc2VcXGAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGUgJyR7dHlwZX0nYCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEpIDogXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gIH07XG4gIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcbiAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIG1hcE9yQnVpbGRlckNhbGxiYWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcbiAgbGV0IGdldEluaXRpYWxTdGF0ZTtcbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpLCBhY3Rpb24pIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgIH0pID0+IHJlZHVjZXIyKV07XG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoKGNyKSA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XG4gICAgfVxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0MihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0RyYWZ0YWJsZTIocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUyKHByZXZpb3VzU3RhdGUsIChkcmFmdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICB9LCBzdGF0ZSk7XG4gIH1cbiAgcmVkdWNlci5nZXRJbml0aWFsU3RhdGUgPSBnZXRJbml0aWFsU3RhdGU7XG4gIHJldHVybiByZWR1Y2VyO1xufVxuXG4vLyBzcmMvbWF0Y2hlcnMudHNcbnZhciBtYXRjaGVzID0gKG1hdGNoZXIsIGFjdGlvbikgPT4ge1xuICBpZiAoaGFzTWF0Y2hGdW5jdGlvbihtYXRjaGVyKSkge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQW55T2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWxsT2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XG4gIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoYXNWYWxpZFJlcXVlc3RJZCA9IHR5cGVvZiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQgPT09IFwic3RyaW5nXCI7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcbiAgcmV0dXJuIGhhc1ZhbGlkUmVxdWVzdElkICYmIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgXCJwZW5kaW5nXCIgaW4gYVswXSAmJiBcImZ1bGZpbGxlZFwiIGluIGFbMF0gJiYgXCJyZWplY3RlZFwiIGluIGFbMF07XG59XG5mdW5jdGlvbiBpc1BlbmRpbmcoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZygpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gaXNBbnlPZiguLi5hc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucGVuZGluZykpO1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZCguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLnJlamVjdGVkKSk7XG59XG5mdW5jdGlvbiBpc1JlamVjdGVkV2l0aFZhbHVlKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGNvbnN0IGhhc0ZsYWcgPSAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIGFjdGlvbiAmJiBhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZTtcbiAgfTtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBpc0FsbE9mKGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpLCBoYXNGbGFnKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkV2l0aFZhbHVlKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FsbE9mKGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpLCBoYXNGbGFnKTtcbn1cbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiBpc0FueU9mKC4uLmFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbiguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIGlzQW55T2YoLi4uYXN5bmNUaHVua3MuZmxhdE1hcCgoYXN5bmNUaHVuaykgPT4gW2FzeW5jVGh1bmsucGVuZGluZywgYXN5bmNUaHVuay5yZWplY3RlZCwgYXN5bmNUaHVuay5mdWxmaWxsZWRdKSk7XG59XG5cbi8vIHNyYy9uYW5vaWQudHNcbnZhciB1cmxBbHBoYWJldCA9IFwiTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRV1wiO1xudmFyIG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkgPSBzaXplO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHNcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1wibmFtZVwiLCBcIm1lc3NhZ2VcIiwgXCJzdGFja1wiLCBcImNvZGVcIl07XG52YXIgUmVqZWN0V2l0aFZhbHVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIEZ1bGZpbGxXaXRoTWV0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgbWV0YSkge1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuICAvKlxuICB0eXBlLW9ubHkgcHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBSZWplY3RXaXRoVmFsdWUgYW5kIEZ1bGZpbGxXaXRoTWV0YVxuICBkb2VzIG5vdCBleGlzdCBhdCBydW50aW1lXG4gICovXG4gIF90eXBlO1xufTtcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNpbXBsZUVycm9yID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzaW1wbGVFcnJvcltwcm9wZXJ0eV0gPSB2YWx1ZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGVFcnJvcjtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSlcbiAgfTtcbn07XG52YXIgY3JlYXRlQXN5bmNUaHVuayA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rMih0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcImZ1bGZpbGxlZFwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZDogdm9pZCAwLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcmVqZWN0ZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3JlamVjdGVkXCIsIChlcnJvciwgcmVxdWVzdElkLCBhcmcsIHBheWxvYWQsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICBhYm9ydGVkOiBlcnJvcj8ubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIsXG4gICAgICAgIGNvbmRpdGlvbjogZXJyb3I/Lm5hbWUgPT09IFwiQ29uZGl0aW9uRXJyb3JcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKGFyZykge1xuICAgICAgcmV0dXJuIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IG9wdGlvbnM/LmlkR2VuZXJhdG9yID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgbGV0IGFib3J0SGFuZGxlcjtcbiAgICAgICAgbGV0IGFib3J0UmVhc29uO1xuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IGZpbmFsQWN0aW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gb3B0aW9ucz8uY29uZGl0aW9uPy4oYXJnLCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZShjb25kaXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IGF3YWl0IGNvbmRpdGlvblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQgPT09IGZhbHNlIHx8IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDb25kaXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJBYm9ydEVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBhYm9ydFJlYXNvbiB8fCBcIkFib3J0ZWRcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCBvcHRpb25zPy5nZXRQZW5kaW5nTWV0YT8uKHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBhcmdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2Fib3J0ZWRQcm9taXNlLCBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiAodmFsdWUsIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bGZpbGxXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVsZmlsbFdpdGhNZXRhKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdWxmaWxsV2l0aE1ldGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyLnBheWxvYWQsIGVyci5tZXRhKSA6IHJlamVjdGVkKGVyciwgcmVxdWVzdElkLCBhcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNraXBEaXNwYXRjaCA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24gJiYgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmIGZpbmFsQWN0aW9uLm1ldGEuY29uZGl0aW9uO1xuICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XG4gICAgICAgICAgICBkaXNwYXRjaChmaW5hbEFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaW5hbEFjdGlvbjtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7XG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICB1bndyYXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHVud3JhcFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjdGlvbkNyZWF0b3IsIHtcbiAgICAgIHBlbmRpbmcsXG4gICAgICByZWplY3RlZCxcbiAgICAgIGZ1bGZpbGxlZCxcbiAgICAgIHNldHRsZWQ6IGlzQW55T2YocmVqZWN0ZWQsIGZ1bGZpbGxlZCksXG4gICAgICB0eXBlUHJlZml4XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQXN5bmNUaHVuazIud2l0aFR5cGVzID0gKCkgPT4gY3JlYXRlQXN5bmNUaHVuazI7XG4gIHJldHVybiBjcmVhdGVBc3luY1RodW5rMjtcbn0pKCk7XG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZSkge1xuICAgIHRocm93IGFjdGlvbi5wYXlsb2FkO1xuICB9XG4gIGlmIChhY3Rpb24uZXJyb3IpIHtcbiAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XG4gIH1cbiAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xufVxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy9jcmVhdGVTbGljZS50c1xudmFyIGFzeW5jVGh1bmtTeW1ib2wgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJ0ay1zbGljZS1jcmVhdGVhc3luY3RodW5rXCIpO1xudmFyIGFzeW5jVGh1bmtDcmVhdG9yID0ge1xuICBbYXN5bmNUaHVua1N5bWJvbF06IGNyZWF0ZUFzeW5jVGh1bmtcbn07XG52YXIgUmVkdWNlclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZWR1Y2VyVHlwZTIpID0+IHtcbiAgUmVkdWNlclR5cGUyW1wicmVkdWNlclwiXSA9IFwicmVkdWNlclwiO1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyV2l0aFByZXBhcmVcIl0gPSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiO1xuICBSZWR1Y2VyVHlwZTJbXCJhc3luY1RodW5rXCJdID0gXCJhc3luY1RodW5rXCI7XG4gIHJldHVybiBSZWR1Y2VyVHlwZTI7XG59KShSZWR1Y2VyVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBnZXRUeXBlKHNsaWNlLCBhY3Rpb25LZXkpIHtcbiAgcmV0dXJuIGAke3NsaWNlfS8ke2FjdGlvbktleX1gO1xufVxuZnVuY3Rpb24gYnVpbGRDcmVhdGVTbGljZSh7XG4gIGNyZWF0b3JzXG59ID0ge30pIHtcbiAgY29uc3QgY0FUID0gY3JlYXRvcnM/LmFzeW5jVGh1bms/Llthc3luY1RodW5rU3ltYm9sXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNsaWNlMihvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXJQYXRoID0gbmFtZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWR1Y2VycyA9ICh0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yZWR1Y2VycyhidWlsZFJlZHVjZXJDcmVhdG9ycygpKSA6IG9wdGlvbnMucmVkdWNlcnMpIHx8IHt9O1xuICAgIGNvbnN0IHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IHt9LFxuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGU6IHt9LFxuICAgICAgYWN0aW9uQ3JlYXRvcnM6IHt9LFxuICAgICAgc2xpY2VNYXRjaGVyczogW11cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHRNZXRob2RzID0ge1xuICAgICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyMikge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHR5cGVPckFjdGlvbkNyZWF0b3IgPT09IFwic3RyaW5nXCIgPyB0eXBlT3JBY3Rpb25DcmVhdG9yIDogdHlwZU9yQWN0aW9uQ3JlYXRvci50eXBlO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMikgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSBpbiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMpIDogXCJgY29udGV4dC5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gcmVkdWNlcjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQWN0aW9uKG5hbWUyLCBhY3Rpb25DcmVhdG9yKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aW9uQ3JlYXRvcnNbbmFtZTJdID0gYWN0aW9uQ3JlYXRvcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUNhc2VSZWR1Y2VyKG5hbWUyLCByZWR1Y2VyMikge1xuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW25hbWUyXSA9IHJlZHVjZXIyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaCgocmVkdWNlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZWZpbml0aW9uID0gcmVkdWNlcnNbcmVkdWNlck5hbWVdO1xuICAgICAgY29uc3QgcmVkdWNlckRldGFpbHMgPSB7XG4gICAgICAgIHJlZHVjZXJOYW1lLFxuICAgICAgICB0eXBlOiBnZXRUeXBlKG5hbWUsIHJlZHVjZXJOYW1lKSxcbiAgICAgICAgY3JlYXRlTm90YXRpb246IHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpZiAoaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcywgY0FUKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IFtleHRyYVJlZHVjZXJzID0ge30sIGFjdGlvbk1hdGNoZXJzID0gW10sIGRlZmF1bHRDYXNlUmVkdWNlciA9IHZvaWQgMF0gPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHtcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZENhc2Uoa2V5LCBmaW5hbENhc2VSZWR1Y2Vyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzTSBvZiBjb250ZXh0LnNsaWNlTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIoc00ubWF0Y2hlciwgc00ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkRGVmYXVsdENhc2UoZGVmYXVsdENhc2VSZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGUpID0+IHN0YXRlO1xuICAgIGNvbnN0IGluamVjdGVkU2VsZWN0b3JDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IF9yZWR1Y2VyO1xuICAgIGZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgaWYgKCFfcmVkdWNlcikgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgaWYgKCFfcmVkdWNlcikgX3JlZHVjZXIgPSBidWlsZFJlZHVjZXIoKTtcbiAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVNlbGVjdG9yUHJvcHMocmVkdWNlclBhdGgyLCBpbmplY3RlZCA9IGZhbHNlKSB7XG4gICAgICBmdW5jdGlvbiBzZWxlY3RTbGljZShzdGF0ZSkge1xuICAgICAgICBsZXQgc2xpY2VTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoMl07XG4gICAgICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICAgICAgc2xpY2VTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiBcInNlbGVjdFNsaWNlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2VTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSA9IHNlbGVjdFNlbGYpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JDYWNoZSA9IGdldE9ySW5zZXJ0Q29tcHV0ZWQoaW5qZWN0ZWRTZWxlY3RvckNhY2hlLCBpbmplY3RlZCwgKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICByZXR1cm4gZ2V0T3JJbnNlcnRDb21wdXRlZChzZWxlY3RvckNhY2hlLCBzZWxlY3RTdGF0ZSwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgW25hbWUyLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zZWxlY3RvcnMgPz8ge30pKSB7XG4gICAgICAgICAgICBtYXBbbmFtZTJdID0gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBpbmplY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgZ2V0U2VsZWN0b3JzLFxuICAgICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcnMoc2VsZWN0U2xpY2UpO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RTbGljZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2UgPSB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlcixcbiAgICAgIGFjdGlvbnM6IGNvbnRleHQuYWN0aW9uQ3JlYXRvcnMsXG4gICAgICBjYXNlUmVkdWNlcnM6IGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUsXG4gICAgICBnZXRJbml0aWFsU3RhdGUsXG4gICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhyZWR1Y2VyUGF0aCksXG4gICAgICBpbmplY3RJbnRvKGluamVjdGFibGUsIHtcbiAgICAgICAgcmVkdWNlclBhdGg6IHBhdGhPcHQsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5ld1JlZHVjZXJQYXRoID0gcGF0aE9wdCA/PyByZWR1Y2VyUGF0aDtcbiAgICAgICAgaW5qZWN0YWJsZS5pbmplY3Qoe1xuICAgICAgICAgIHJlZHVjZXJQYXRoOiBuZXdSZWR1Y2VyUGF0aCxcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uc2xpY2UsXG4gICAgICAgICAgLi4ubWFrZVNlbGVjdG9yUHJvcHMobmV3UmVkdWNlclBhdGgsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2U7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwU2VsZWN0b3Ioc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBnZXRJbml0aWFsU3RhdGUsIGluamVjdGVkKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlLCAuLi5hcmdzKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZShyb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IFwic2VsZWN0U3RhdGUgcmV0dXJuZWQgdW5kZWZpbmVkIGZvciBhbiB1bmluamVjdGVkIHNsaWNlIHJlZHVjZXJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcihzbGljZVN0YXRlLCAuLi5hcmdzKTtcbiAgfVxuICB3cmFwcGVyLnVud3JhcHBlZCA9IHNlbGVjdG9yO1xuICByZXR1cm4gd3JhcHBlcjtcbn1cbnZhciBjcmVhdGVTbGljZSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZENyZWF0ZVNsaWNlKCk7XG5mdW5jdGlvbiBidWlsZFJlZHVjZXJDcmVhdG9ycygpIHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi8sXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVtjYXNlUmVkdWNlci5uYW1lXSwge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJcIiAvKiByZWR1Y2VyICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBhcmVkUmVkdWNlcihwcmVwYXJlLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLyxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jVGh1bmtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWUsXG4gIGNyZWF0ZU5vdGF0aW9uXG59LCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSwgY29udGV4dCkge1xuICBsZXQgY2FzZVJlZHVjZXI7XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XG4gIGlmIChcInJlZHVjZXJcIiBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnkoc3RhdGVBZGFwdGVyKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSwgZW50aXRpZXMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGVudGl0aWVzID8gc3RhdGVBZGFwdGVyLnNldEFsbChzdGF0ZSwgZW50aXRpZXMpIDogc3RhdGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRJbml0aWFsU3RhdGVcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX3NlbGVjdG9ycy50c1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKHNlbGVjdFN0YXRlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWxlY3RJZHMgPSAoc3RhdGUpID0+IHN0YXRlLmlkcztcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZSkgPT4gc3RhdGUuZW50aXRpZXM7XG4gICAgY29uc3Qgc2VsZWN0QWxsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgc2VsZWN0RW50aXRpZXMsIChpZHMsIGVudGl0aWVzKSA9PiBpZHMubWFwKChpZCkgPT4gZW50aXRpZXNbaWRdKSk7XG4gICAgY29uc3Qgc2VsZWN0SWQgPSAoXywgaWQpID0+IGlkO1xuICAgIGNvbnN0IHNlbGVjdEJ5SWQgPSAoZW50aXRpZXMsIGlkKSA9PiBlbnRpdGllc1tpZF07XG4gICAgY29uc3Qgc2VsZWN0VG90YWwgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0SWRzLCAoaWRzKSA9PiBpZHMubGVuZ3RoKTtcbiAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RJZHMsXG4gICAgICAgIHNlbGVjdEVudGl0aWVzLFxuICAgICAgICBzZWxlY3RBbGwsXG4gICAgICAgIHNlbGVjdFRvdGFsLFxuICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RFbnRpdGllcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdElkczogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RJZHMpLFxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RBbGwpLFxuICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0VG90YWwpLFxuICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFNlbGVjdG9yc1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfYWRhcHRlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUzLCBpc0RyYWZ0IGFzIGlzRHJhZnQzIH0gZnJvbSBcImltbWVyXCI7XG52YXIgaXNEcmFmdFR5cGVkID0gaXNEcmFmdDM7XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICBjb25zdCBvcGVyYXRvciA9IGNyZWF0ZVN0YXRlT3BlcmF0b3IoKF8sIHN0YXRlKSA9PiBtdXRhdG9yKHN0YXRlKSk7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUsIHZvaWQgMCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSwgYXJnKSB7XG4gICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnMikge1xuICAgICAgcmV0dXJuIGlzRlNBKGFyZzIpO1xuICAgIH1cbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0KSA9PiB7XG4gICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xuICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzRHJhZnRUeXBlZChzdGF0ZSkpIHtcbiAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMyhzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xuaW1wb3J0IHsgY3VycmVudCBhcyBjdXJyZW50MiwgaXNEcmFmdCBhcyBpc0RyYWZ0NCB9IGZyb20gXCJpbW1lclwiO1xuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2V5ID09PSB2b2lkIDApIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuXCIsIFwiWW91IHNob3VsZCBwcm9iYWJseSBwcm92aWRlIHlvdXIgb3duIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24uXCIsIFwiVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6XCIsIGVudGl0eSwgXCJUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjpcIiwgc2VsZWN0SWQudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUVudGl0aWVzQXJyYXkoZW50aXRpZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xuICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcyk7XG4gIH1cbiAgcmV0dXJuIGVudGl0aWVzO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudCh2YWx1ZSkge1xuICByZXR1cm4gaXNEcmFmdDQodmFsdWUpID8gY3VycmVudDIodmFsdWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcbiAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgY29uc3QgZXhpc3RpbmdJZHNBcnJheSA9IGdldEN1cnJlbnQoc3RhdGUuaWRzKTtcbiAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGV4aXN0aW5nSWRzQXJyYXkpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCB1cGRhdGVkID0gW107XG4gIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChleGlzdGluZ0lkcy5oYXMoaWQpKSB7XG4gICAgICB1cGRhdGVkLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhbmdlczogZW50aXR5XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkZWQucHVzaChlbnRpdHkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2FkZGVkLCB1cGRhdGVkLCBleGlzdGluZ0lkc0FycmF5XTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKSB7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoIShrZXkgaW4gc3RhdGUuZW50aXRpZXMpKSB7XG4gICAgICBzdGF0ZS5pZHMucHVzaChrZXkpO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xuICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldO1xuICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoKGlkKSA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICBpZHM6IFtdLFxuICAgICAgZW50aXRpZXM6IHt9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwzID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICBpZiAob3JpZ2luYWwzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMywgdXBkYXRlLmNoYW5nZXMpO1xuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XG4gICAgcmV0dXJuIGhhc05ld0tleTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5ld0tleXMgPSB7fTtcbiAgICBjb25zdCB1cGRhdGVzUGVyRW50aXR5ID0ge307XG4gICAgdXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHtcbiAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xuICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXG4gICAgICAgICAgLy8gU3ByZWFkcyBpZ25vcmUgZmFsc3kgdmFsdWVzLCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgdGhlcmUgaXNuJ3RcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXT8uY2hhbmdlcyxcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xuICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xuICAgICAgY29uc3QgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoKHVwZGF0ZSkgPT4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKSkubGVuZ3RoID4gMDtcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcbiAgICAgICAgc3RhdGUuaWRzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcykubWFwKChlKSA9PiBzZWxlY3RJZFZhbHVlKGUsIHNlbGVjdElkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBmaW5kSW5zZXJ0SW5kZXgoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICBsZXQgbG93SW5kZXggPSAwO1xuICBsZXQgaGlnaEluZGV4ID0gc29ydGVkSXRlbXMubGVuZ3RoO1xuICB3aGlsZSAobG93SW5kZXggPCBoaWdoSW5kZXgpIHtcbiAgICBsZXQgbWlkZGxlSW5kZXggPSBsb3dJbmRleCArIGhpZ2hJbmRleCA+Pj4gMTtcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9IHNvcnRlZEl0ZW1zW21pZGRsZUluZGV4XTtcbiAgICBjb25zdCByZXMgPSBjb21wYXJpc29uRnVuY3Rpb24oaXRlbSwgY3VycmVudEl0ZW0pO1xuICAgIGlmIChyZXMgPj0gMCkge1xuICAgICAgbG93SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2hJbmRleCA9IG1pZGRsZUluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG93SW5kZXg7XG59XG5mdW5jdGlvbiBpbnNlcnQoc29ydGVkSXRlbXMsIGl0ZW0sIGNvbXBhcmlzb25GdW5jdGlvbikge1xuICBjb25zdCBpbnNlcnRBdEluZGV4ID0gZmluZEluc2VydEluZGV4KHNvcnRlZEl0ZW1zLCBpdGVtLCBjb21wYXJpc29uRnVuY3Rpb24pO1xuICBzb3J0ZWRJdGVtcy5zcGxpY2UoaW5zZXJ0QXRJbmRleCwgMCwgaXRlbSk7XG4gIHJldHVybiBzb3J0ZWRJdGVtcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgY29tcGFyZXIpIHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbFxuICB9ID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUsIGV4aXN0aW5nSWRzKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBjb25zdCBleGlzdGluZ0tleXMgPSBuZXcgU2V0KGV4aXN0aW5nSWRzID8/IGdldEN1cnJlbnQoc3RhdGUuaWRzKSk7XG4gICAgY29uc3QgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKChtb2RlbCkgPT4gIWV4aXN0aW5nS2V5cy5oYXMoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpKSk7XG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlRnVuY3Rpb24oc3RhdGUsIG1vZGVscyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBzZXRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1tzZWxlY3RJZChpdGVtKV07XG4gICAgICB9XG4gICAgICBtZXJnZUZ1bmN0aW9uKHN0YXRlLCBuZXdFbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSwgW10pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XG4gICAgbGV0IGFwcGxpZWRVcGRhdGVzID0gZmFsc2U7XG4gICAgbGV0IHJlcGxhY2VkSWRzID0gZmFsc2U7XG4gICAgZm9yIChsZXQgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgICBpZiAoIWVudGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFwcGxpZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5hc3NpZ24oZW50aXR5LCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICBjb25zdCBuZXdJZCA9IHNlbGVjdElkKGVudGl0eSk7XG4gICAgICBpZiAodXBkYXRlLmlkICE9PSBuZXdJZCkge1xuICAgICAgICByZXBsYWNlZElkcyA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHN0YXRlLmlkcy5pbmRleE9mKHVwZGF0ZS5pZCk7XG4gICAgICAgIHN0YXRlLmlkc1tvbGRJbmRleF0gPSBuZXdJZDtcbiAgICAgICAgc3RhdGUuZW50aXRpZXNbbmV3SWRdID0gZW50aXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXBwbGllZFVwZGF0ZXMpIHtcbiAgICAgIG1lcmdlRnVuY3Rpb24oc3RhdGUsIFtdLCBhcHBsaWVkVXBkYXRlcywgcmVwbGFjZWRJZHMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWQsIGV4aXN0aW5nSWRzQXJyYXldID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICBpZiAodXBkYXRlZC5sZW5ndGgpIHtcbiAgICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlLCBleGlzdGluZ0lkc0FycmF5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgbWVyZ2VGdW5jdGlvbiA9IChzdGF0ZSwgYWRkZWRJdGVtcywgYXBwbGllZFVwZGF0ZXMsIHJlcGxhY2VkSWRzKSA9PiB7XG4gICAgY29uc3QgY3VycmVudEVudGl0aWVzID0gZ2V0Q3VycmVudChzdGF0ZS5lbnRpdGllcyk7XG4gICAgY29uc3QgY3VycmVudElkcyA9IGdldEN1cnJlbnQoc3RhdGUuaWRzKTtcbiAgICBjb25zdCBzdGF0ZUVudGl0aWVzID0gc3RhdGUuZW50aXRpZXM7XG4gICAgbGV0IGlkcyA9IGN1cnJlbnRJZHM7XG4gICAgaWYgKHJlcGxhY2VkSWRzKSB7XG4gICAgICBpZHMgPSBuZXcgU2V0KGN1cnJlbnRJZHMpO1xuICAgIH1cbiAgICBsZXQgc29ydGVkRW50aXRpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgY29uc3QgZW50aXR5ID0gY3VycmVudEVudGl0aWVzW2lkXTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgc29ydGVkRW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YXNQcmV2aW91c2x5RW1wdHkgPSBzb3J0ZWRFbnRpdGllcy5sZW5ndGggPT09IDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFkZGVkSXRlbXMpIHtcbiAgICAgIHN0YXRlRW50aXRpZXNbc2VsZWN0SWQoaXRlbSldID0gaXRlbTtcbiAgICAgIGlmICghd2FzUHJldmlvdXNseUVtcHR5KSB7XG4gICAgICAgIGluc2VydChzb3J0ZWRFbnRpdGllcywgaXRlbSwgY29tcGFyZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2FzUHJldmlvdXNseUVtcHR5KSB7XG4gICAgICBzb3J0ZWRFbnRpdGllcyA9IGFkZGVkSXRlbXMuc2xpY2UoKS5zb3J0KGNvbXBhcmVyKTtcbiAgICB9IGVsc2UgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICBzb3J0ZWRFbnRpdGllcy5zb3J0KGNvbXBhcmVyKTtcbiAgICB9XG4gICAgY29uc3QgbmV3U29ydGVkSWRzID0gc29ydGVkRW50aXRpZXMubWFwKHNlbGVjdElkKTtcbiAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGN1cnJlbnRJZHMsIG5ld1NvcnRlZElkcykpIHtcbiAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkcztcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH0gPSB7XG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5pZCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeShzdGF0ZUFkYXB0ZXIpO1xuICBjb25zdCBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSgpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlcixcbiAgICAuLi5zdGF0ZUZhY3RvcnksXG4gICAgLi4uc2VsZWN0b3JzRmFjdG9yeSxcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcbiAgfTtcbn1cblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xuaW1wb3J0IHsgaXNBY3Rpb24gYXMgaXNBY3Rpb24zIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xudmFyIHRhc2sgPSBcInRhc2tcIjtcbnZhciBsaXN0ZW5lciA9IFwibGlzdGVuZXJcIjtcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xudmFyIGNhbmNlbGxlZCA9IFwiY2FuY2VsbGVkXCI7XG52YXIgdGFza0NhbmNlbGxlZCA9IGB0YXNrLSR7Y2FuY2VsbGVkfWA7XG52YXIgdGFza0NvbXBsZXRlZCA9IGB0YXNrLSR7Y29tcGxldGVkfWA7XG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBgJHtsaXN0ZW5lcn0tJHtjYW5jZWxsZWR9YDtcbnZhciBsaXN0ZW5lckNvbXBsZXRlZCA9IGAke2xpc3RlbmVyfS0ke2NvbXBsZXRlZH1gO1xudmFyIFRhc2tBYm9ydEVycm9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0YXNrfSAke2NhbmNlbGxlZH0gKHJlYXNvbjogJHtjb2RlfSlgO1xuICB9XG4gIG5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XG4gIG1lc3NhZ2U7XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXG52YXIgYXNzZXJ0RnVuY3Rpb24gPSAoZnVuYywgZXhwZWN0ZWQpID0+IHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIpIDogYCR7ZXhwZWN0ZWR9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cbn07XG52YXIgbm9vcDIgPSAoKSA9PiB7XG59O1xudmFyIGNhdGNoUmVqZWN0aW9uID0gKHByb21pc2UsIG9uRXJyb3IgPSBub29wMikgPT4ge1xuICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IChhYm9ydFNpZ25hbCwgY2FsbGJhY2spID0+IHtcbiAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrLCB7XG4gICAgb25jZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7XG59O1xudmFyIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24gPSAoYWJvcnRDb250cm9sbGVyLCByZWFzb24pID0+IHtcbiAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcmVhc29uLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICA7XG4gIGFib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS90YXNrLnRzXG52YXIgdmFsaWRhdGVBY3RpdmUgPSAoc2lnbmFsKSA9PiB7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlYXNvblxuICAgIH0gPSBzaWduYWw7XG4gICAgdGhyb3cgbmV3IFRhc2tBYm9ydEVycm9yKHJlYXNvbik7XG4gIH1cbn07XG5mdW5jdGlvbiByYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpIHtcbiAgbGV0IGNsZWFudXAgPSBub29wMjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBjbGVhbnVwID0gbm9vcDI7XG4gIH0pO1xufVxudmFyIHJ1blRhc2sgPSBhc3luYyAodGFzazIsIGNsZWFuVXApID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRhc2syKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGNsZWFuVXA/LigpO1xuICB9XG59O1xudmFyIGNyZWF0ZVBhdXNlID0gKHNpZ25hbCkgPT4ge1xuICByZXR1cm4gKHByb21pc2UpID0+IHtcbiAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKS50aGVuKChvdXRwdXQpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pKTtcbiAgfTtcbn07XG52YXIgY3JlYXRlRGVsYXkgPSAoc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcbiAgcmV0dXJuICh0aW1lb3V0TXMpID0+IHtcbiAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkpO1xuICB9O1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xudmFyIHtcbiAgYXNzaWduXG59ID0gT2JqZWN0O1xudmFyIElOVEVSTkFMX05JTF9UT0tFTiA9IHt9O1xudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XG52YXIgY3JlYXRlRm9yayA9IChwYXJlbnRBYm9ydFNpZ25hbCwgcGFyZW50QmxvY2tpbmdQcm9taXNlcykgPT4ge1xuICBjb25zdCBsaW5rQ29udHJvbGxlcnMgPSAoY29udHJvbGxlcikgPT4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pKTtcbiAgcmV0dXJuICh0YXNrRXhlY3V0b3IsIG9wdHMpID0+IHtcbiAgICBhc3NlcnRGdW5jdGlvbih0YXNrRXhlY3V0b3IsIFwidGFza0V4ZWN1dG9yXCIpO1xuICAgIGNvbnN0IGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gcnVuVGFzayhhc3luYyAoKSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShwYXJlbnRBYm9ydFNpZ25hbCk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRhc2tFeGVjdXRvcih7XG4gICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgc2lnbmFsOiBjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH0sICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDb21wbGV0ZWQpKTtcbiAgICBpZiAob3B0cz8uYXV0b0pvaW4pIHtcbiAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQuY2F0Y2gobm9vcDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogY3JlYXRlUGF1c2UocGFyZW50QWJvcnRTaWduYWwpKHJlc3VsdCksXG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xudmFyIGNyZWF0ZVRha2VQYXR0ZXJuID0gKHN0YXJ0TGlzdGVuaW5nLCBzaWduYWwpID0+IHtcbiAgY29uc3QgdGFrZSA9IGFzeW5jIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHtcbiAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgIGxldCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICB9O1xuICAgIGNvbnN0IHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzdG9wTGlzdGVuaW5nID0gc3RhcnRMaXN0ZW5pbmcoe1xuICAgICAgICBwcmVkaWNhdGUsXG4gICAgICAgIGVmZmVjdDogKGFjdGlvbiwgbGlzdGVuZXJBcGkpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUoW2FjdGlvbiwgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSwgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW3R1cGxlUHJvbWlzZV07XG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7XG59O1xudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSAob3B0aW9ucykgPT4ge1xuICBsZXQge1xuICAgIHR5cGUsXG4gICAgYWN0aW9uQ3JlYXRvcixcbiAgICBtYXRjaGVyLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlKSB7XG4gICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xuICB9IGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcbiAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xuICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XG4gIH0gZWxzZSBpZiAobWF0Y2hlcikge1xuICAgIHByZWRpY2F0ZSA9IG1hdGNoZXI7XG4gIH0gZWxzZSBpZiAocHJlZGljYXRlKSB7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjEpIDogXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XG4gIH1cbiAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlLFxuICAgIHR5cGUsXG4gICAgZWZmZWN0XG4gIH07XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSAvKiBAX19QVVJFX18gKi8gYXNzaWduKChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGlkOiBuYW5vaWQoKSxcbiAgICBlZmZlY3QsXG4gICAgdHlwZSxcbiAgICBwcmVkaWNhdGUsXG4gICAgcGVuZGluZzogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjIpIDogXCJVbnN1YnNjcmliZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZW50cnk7XG59LCB7XG4gIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlTGlzdGVuZXJFbnRyeVxufSk7XG52YXIgZmluZExpc3RlbmVyRW50cnkgPSAobGlzdGVuZXJNYXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZWZmZWN0LFxuICAgIHByZWRpY2F0ZVxuICB9ID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpLmZpbmQoKGVudHJ5KSA9PiB7XG4gICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5LnR5cGUgPT09IHR5cGUgOiBlbnRyeS5wcmVkaWNhdGUgPT09IHByZWRpY2F0ZTtcbiAgICByZXR1cm4gbWF0Y2hQcmVkaWNhdGVPclR5cGUgJiYgZW50cnkuZWZmZWN0ID09PSBlZmZlY3Q7XG4gIH0pO1xufTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyTWFwLmZvckVhY2goY2FuY2VsQWN0aXZlTGlzdGVuZXJzKTtcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSAvKiBAX19QVVJFX18gKi8gYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oYCR7YWxtfS9hZGRgKSwge1xuICB3aXRoVHlwZXM6ICgpID0+IGFkZExpc3RlbmVyXG59KTtcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oYCR7YWxtfS9yZW1vdmVBbGxgKTtcbnZhciByZW1vdmVMaXN0ZW5lciA9IC8qIEBfX1BVUkVfXyAqLyBhc3NpZ24oLyogQF9fUFVSRV9fICovIGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZWApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gcmVtb3ZlTGlzdGVuZXJcbn0pO1xudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2FsbX0vZXJyb3JgLCAuLi5hcmdzKTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlID0gKG1pZGRsZXdhcmVPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgb25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xuICBhc3NlcnRGdW5jdGlvbihvbkVycm9yLCBcIm9uRXJyb3JcIik7XG4gIGNvbnN0IGluc2VydEVudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xuICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIHJldHVybiAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjYW5jZWxPcHRpb25zPy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBzdGFydExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kTGlzdGVuZXJFbnRyeShsaXN0ZW5lck1hcCwgb3B0aW9ucykgPz8gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zKTtcbiAgICByZXR1cm4gaW5zZXJ0RW50cnkoZW50cnkpO1xuICB9O1xuICBhc3NpZ24oc3RhcnRMaXN0ZW5pbmcsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHN0YXJ0TGlzdGVuaW5nXG4gIH0pO1xuICBjb25zdCBzdG9wTGlzdGVuaW5nID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGZpbmRMaXN0ZW5lckVudHJ5KGxpc3RlbmVyTWFwLCBvcHRpb25zKTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH07XG4gIGFzc2lnbihzdG9wTGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdG9wTGlzdGVuaW5nXG4gIH0pO1xuICBjb25zdCBub3RpZnlMaXN0ZW5lciA9IGFzeW5jIChlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpID0+IHtcbiAgICBjb25zdCBpbnRlcm5hbFRhc2tDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRha2UgPSBjcmVhdGVUYWtlUGF0dGVybihzdGFydExpc3RlbmluZywgaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgIGNvbnN0IGF1dG9Kb2luUHJvbWlzZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZW50cnkucGVuZGluZy5hZGQoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoZW50cnkuZWZmZWN0KFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIC8vIFVzZSBhc3NpZ24oKSByYXRoZXIgdGhhbiAuLi4gdG8gYXZvaWQgZXh0cmEgaGVscGVyIGZ1bmN0aW9ucyBhZGRlZCB0byBidW5kbGVcbiAgICAgICAgYXNzaWduKHt9LCBhcGksIHtcbiAgICAgICAgICBnZXRPcmlnaW5hbFN0YXRlLFxuICAgICAgICAgIGNvbmRpdGlvbjogKHByZWRpY2F0ZSwgdGltZW91dCkgPT4gdGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpLnRoZW4oQm9vbGVhbiksXG4gICAgICAgICAgdGFrZSxcbiAgICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgc2lnbmFsOiBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICBmb3JrOiBjcmVhdGVGb3JrKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLCBhdXRvSm9pblByb21pc2VzKSxcbiAgICAgICAgICB1bnN1YnNjcmliZTogZW50cnkudW5zdWJzY3JpYmUsXG4gICAgICAgICAgc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVyczogKCkgPT4ge1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyLCBfLCBzZXQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIgIT09IGludGVybmFsVGFza0NvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgICAgICBzZXQuZGVsZXRlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZhbGlkYXRlQWN0aXZlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApKTtcbiAgICB9IGNhdGNoIChsaXN0ZW5lckVycm9yKSB7XG4gICAgICBpZiAoIShsaXN0ZW5lckVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IpKSB7XG4gICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIGxpc3RlbmVyRXJyb3IsIHtcbiAgICAgICAgICByYWlzZWRCeTogXCJlZmZlY3RcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXV0b0pvaW5Qcm9taXNlcyk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ29tcGxldGVkKTtcbiAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICghaXNBY3Rpb24zKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgfVxuICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhcnRMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoY2xlYXJBbGxMaXN0ZW5lcnMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdG9wTGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgbGV0IG9yaWdpbmFsU3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBnZXRPcmlnaW5hbFN0YXRlID0gKCkgPT4ge1xuICAgICAgaWYgKG9yaWdpbmFsU3RhdGUgPT09IElOVEVSTkFMX05JTF9UT0tFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMykgOiBgJHthbG19OiBnZXRPcmlnaW5hbFN0YXRlIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxTdGF0ZTtcbiAgICB9O1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGlmIChsaXN0ZW5lck1hcC5zaXplID4gMCkge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJFbnRyaWVzID0gQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSk7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgbGlzdGVuZXJFbnRyaWVzKSB7XG4gICAgICAgICAgbGV0IHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZW50cnkucHJlZGljYXRlKGFjdGlvbiwgY3VycmVudFN0YXRlLCBvcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgICB9IGNhdGNoIChwcmVkaWNhdGVFcnJvcikge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHNhZmVseU5vdGlmeUVycm9yKG9uRXJyb3IsIHByZWRpY2F0ZUVycm9yLCB7XG4gICAgICAgICAgICAgIHJhaXNlZEJ5OiBcInByZWRpY2F0ZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFydW5MaXN0ZW5lcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdGlmeUxpc3RlbmVyKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgb3JpZ2luYWxTdGF0ZSA9IElOVEVSTkFMX05JTF9UT0tFTjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIHN0YXJ0TGlzdGVuaW5nLFxuICAgIHN0b3BMaXN0ZW5pbmcsXG4gICAgY2xlYXJMaXN0ZW5lcnM6IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlXG4gIH07XG59O1xuXG4vLyBzcmMvZHluYW1pY01pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGNvbXBvc2UgYXMgY29tcG9zZTMgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjcmVhdGVNaWRkbGV3YXJlRW50cnkgPSAobWlkZGxld2FyZSkgPT4gKHtcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGdldE9ySW5zZXJ0Q29tcHV0ZWQobWlkZGxld2FyZU1hcCwgbWlkZGxld2FyZTIsIGNyZWF0ZU1pZGRsZXdhcmVFbnRyeSk7XG4gICAgfSk7XG4gIH0sIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IGFkZE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGdldEZpbmFsTWlkZGxld2FyZSA9IChhcGkpID0+IHtcbiAgICBjb25zdCBhcHBsaWVkTWlkZGxld2FyZSA9IEFycmF5LmZyb20obWlkZGxld2FyZU1hcC52YWx1ZXMoKSkubWFwKChlbnRyeSkgPT4gZ2V0T3JJbnNlcnRDb21wdXRlZChlbnRyeS5hcHBsaWVkLCBhcGksIGVudHJ5Lm1pZGRsZXdhcmUpKTtcbiAgICByZXR1cm4gY29tcG9zZTMoLi4uYXBwbGllZE1pZGRsZXdhcmUpO1xuICB9O1xuICBjb25zdCBpc1dpdGhNaWRkbGV3YXJlID0gaXNBbGxPZih3aXRoTWlkZGxld2FyZSwgbWF0Y2hJbnN0YW5jZShpbnN0YW5jZUlkKSk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc1dpdGhNaWRkbGV3YXJlKGFjdGlvbikpIHtcbiAgICAgIGFkZE1pZGRsZXdhcmUoLi4uYWN0aW9uLnBheWxvYWQpO1xuICAgICAgcmV0dXJuIGFwaS5kaXNwYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpbmFsTWlkZGxld2FyZShhcGkpKG5leHQpKGFjdGlvbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBhZGRNaWRkbGV3YXJlLFxuICAgIHdpdGhNaWRkbGV3YXJlLFxuICAgIGluc3RhbmNlSWRcbiAgfTtcbn07XG5cbi8vIHNyYy9jb21iaW5lU2xpY2VzLnRzXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgYXMgY29tYmluZVJlZHVjZXJzMiB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGlzU2xpY2VMaWtlID0gKG1heWJlU2xpY2VMaWtlKSA9PiBcInJlZHVjZXJQYXRoXCIgaW4gbWF5YmVTbGljZUxpa2UgJiYgdHlwZW9mIG1heWJlU2xpY2VMaWtlLnJlZHVjZXJQYXRoID09PSBcInN0cmluZ1wiO1xudmFyIGdldFJlZHVjZXJzID0gKHNsaWNlcykgPT4gc2xpY2VzLmZsYXRNYXAoKHNsaWNlT3JNYXApID0+IGlzU2xpY2VMaWtlKHNsaWNlT3JNYXApID8gW1tzbGljZU9yTWFwLnJlZHVjZXJQYXRoLCBzbGljZU9yTWFwLnJlZHVjZXJdXSA6IE9iamVjdC5lbnRyaWVzKHNsaWNlT3JNYXApKTtcbnZhciBPUklHSU5BTF9TVEFURSA9IFN5bWJvbC5mb3IoXCJydGstc3RhdGUtcHJveHktb3JpZ2luYWxcIik7XG52YXIgaXNTdGF0ZVByb3h5ID0gKHZhbHVlKSA9PiAhIXZhbHVlICYmICEhdmFsdWVbT1JJR0lOQUxfU1RBVEVdO1xudmFyIHN0YXRlUHJveHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBjcmVhdGVTdGF0ZVByb3h5ID0gKHN0YXRlLCByZWR1Y2VyTWFwKSA9PiBnZXRPckluc2VydENvbXB1dGVkKHN0YXRlUHJveHlNYXAsIHN0YXRlLCAoKSA9PiBuZXcgUHJveHkoc3RhdGUsIHtcbiAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSkgcmV0dXJuIHRhcmdldDtcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgIGlmIChyZWR1Y2VyKSB7XG4gICAgICAgIGNvbnN0IHJlZHVjZXJSZXN1bHQgPSByZWR1Y2VyKHZvaWQgMCwge1xuICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHJlZHVjZXJSZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVkdWNlclJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSkpO1xudmFyIG9yaWdpbmFsID0gKHN0YXRlKSA9PiB7XG4gIGlmICghaXNTdGF0ZVByb3h5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI1KSA6IFwib3JpZ2luYWwgbXVzdCBiZSB1c2VkIG9uIHN0YXRlIFByb3h5XCIpO1xuICB9XG4gIHJldHVybiBzdGF0ZVtPUklHSU5BTF9TVEFURV07XG59O1xudmFyIG5vb3BSZWR1Y2VyID0gKHN0YXRlID0ge30pID0+IHN0YXRlO1xuZnVuY3Rpb24gY29tYmluZVNsaWNlcyguLi5zbGljZXMpIHtcbiAgY29uc3QgcmVkdWNlck1hcCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRSZWR1Y2VycyhzbGljZXMpKTtcbiAgY29uc3QgZ2V0UmVkdWNlciA9ICgpID0+IE9iamVjdC5rZXlzKHJlZHVjZXJNYXApLmxlbmd0aCA/IGNvbWJpbmVSZWR1Y2VyczIocmVkdWNlck1hcCkgOiBub29wUmVkdWNlcjtcbiAgbGV0IHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gIGZ1bmN0aW9uIGNvbWJpbmVkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gIH1cbiAgY29tYmluZWRSZWR1Y2VyLndpdGhMYXp5TG9hZGVkU2xpY2VzID0gKCkgPT4gY29tYmluZWRSZWR1Y2VyO1xuICBjb25zdCBpbmplY3QgPSAoc2xpY2UsIGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICByZWR1Y2VyOiByZWR1Y2VyVG9JbmplY3RcbiAgICB9ID0gc2xpY2U7XG4gICAgY29uc3QgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAoIWNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhbGxlZCBcXGBpbmplY3RcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyByZWR1Y2VyICR7cmVkdWNlclBhdGh9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICAgIH1cbiAgICByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXSA9IHJlZHVjZXJUb0luamVjdDtcbiAgICByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBtYWtlU2VsZWN0b3Ioc2VsZWN0b3JGbiwgc2VsZWN0U3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZWN0b3IyKHN0YXRlLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGbihjcmVhdGVTdGF0ZVByb3h5KHNlbGVjdFN0YXRlID8gc2VsZWN0U3RhdGUoc3RhdGUsIC4uLmFyZ3MpIDogc3RhdGUsIHJlZHVjZXJNYXApLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9LCB7XG4gICAgb3JpZ2luYWxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KTtcbn1cblxuLy8gc3JjL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHNcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IFRvb2xraXQgZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuZXhwb3J0IHtcbiAgUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yLFxuICBUdXBsZSxcbiAgYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yLFxuICBhdXRvQmF0Y2hFbmhhbmNlcixcbiAgYnVpbGRDcmVhdGVTbGljZSxcbiAgY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlLFxuICBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVBc3luY1RodW5rLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcixcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSxcbiAgY3JlYXRlRW50aXR5QWRhcHRlcixcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiBhcyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlU2xpY2UsXG4gIGN1cnJlbnQzIGFzIGN1cnJlbnQsXG4gIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcbiAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSxcbiAgZnJlZXplLFxuICBpc0FjdGlvbkNyZWF0b3IsXG4gIGlzQWxsT2YsXG4gIGlzQW55T2YsXG4gIGlzQXN5bmNUaHVua0FjdGlvbixcbiAgaXNEcmFmdDUgYXMgaXNEcmFmdCxcbiAgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sXG4gIGlzRnVsZmlsbGVkLFxuICBpc0ltbXV0YWJsZURlZmF1bHQsXG4gIGlzUGVuZGluZyxcbiAgaXNQbGFpbixcbiAgaXNSZWplY3RlZCxcbiAgaXNSZWplY3RlZFdpdGhWYWx1ZSxcbiAgbHJ1TWVtb2l6ZSxcbiAgbWluaVNlcmlhbGl6ZUVycm9yLFxuICBuYW5vaWQsXG4gIG9yaWdpbmFsMiBhcyBvcmlnaW5hbCxcbiAgcHJlcGFyZUF1dG9CYXRjaGVkLFxuICByZW1vdmVMaXN0ZW5lcixcbiAgdW53cmFwUmVzdWx0LFxuICB3ZWFrTWFwTWVtb2l6ZTIgYXMgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC10b29sa2l0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/immer/dist/immer.mjs":
/*!***********************************************!*\
  !*** ../../node_modules/immer/dist/immer.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Immer: () => (/* binding */ Immer2),\n/* harmony export */   applyPatches: () => (/* binding */ applyPatches),\n/* harmony export */   castDraft: () => (/* binding */ castDraft),\n/* harmony export */   castImmutable: () => (/* binding */ castImmutable),\n/* harmony export */   createDraft: () => (/* binding */ createDraft),\n/* harmony export */   current: () => (/* binding */ current),\n/* harmony export */   enableMapSet: () => (/* binding */ enableMapSet),\n/* harmony export */   enablePatches: () => (/* binding */ enablePatches),\n/* harmony export */   finishDraft: () => (/* binding */ finishDraft),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   immerable: () => (/* binding */ DRAFTABLE),\n/* harmony export */   isDraft: () => (/* binding */ isDraft),\n/* harmony export */   isDraftable: () => (/* binding */ isDraftable),\n/* harmony export */   nothing: () => (/* binding */ NOTHING),\n/* harmony export */   original: () => (/* binding */ original),\n/* harmony export */   produce: () => (/* binding */ produce),\n/* harmony export */   produceWithPatches: () => (/* binding */ produceWithPatches),\n/* harmony export */   setAutoFreeze: () => (/* binding */ setAutoFreeze),\n/* harmony export */   setUseStrictShallowCopy: () => (/* binding */ setUseStrictShallowCopy)\n/* harmony export */ });\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n\n// src/utils/errors.ts\nvar errors =  true ? [\n  // All error codes, starting by 0:\n  function(plugin) {\n    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n  },\n  function(thing) {\n    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n  },\n  \"This object has been frozen and should not be mutated\",\n  function(data) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n  },\n  \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  \"Immer forbids circular references\",\n  \"The first or second argument to `produce` must be a function\",\n  \"The third argument to `produce` must be a function or undefined\",\n  \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  function(thing) {\n    return `'current' expects a draft, got: ${thing}`;\n  },\n  \"Object.defineProperty() cannot be used on an Immer draft\",\n  \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  \"Immer only supports deleting array indices\",\n  \"Immer only supports setting array indices and the 'length' property\",\n  function(thing) {\n    return `'original' expects a draft, got: ${thing}`;\n  }\n  // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n  // See Patches.ts for additional errors\n] : 0;\nfunction die(error, ...args) {\n  if (true) {\n    const e = errors[error];\n    const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(`[Immer] ${msg}`);\n  }\n  throw new Error(\n    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n  );\n}\n\n// src/utils/common.ts\nvar getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value)\n    return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\")\n    return false;\n  const proto = getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object)\n    return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value))\n    die(15, value);\n  return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0 /* Object */) {\n    Reflect.ownKeys(obj).forEach((key) => {\n      iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach((entry, index) => iter(index, entry, obj));\n  }\n}\nfunction getArchtype(thing) {\n  const state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;\n}\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n  const t = getArchtype(thing);\n  if (t === 2 /* Map */)\n    thing.set(propOrOldValue, value);\n  else if (t === 3 /* Set */) {\n    thing.add(value);\n  } else\n    thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction isMap(target) {\n  return target instanceof Map;\n}\nfunction isSet(target) {\n  return target instanceof Set;\n}\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n  if (isSet(base)) {\n    return new Set(base);\n  }\n  if (Array.isArray(base))\n    return Array.prototype.slice.call(base);\n  const isPlain = isPlainObject(base);\n  if (strict === true || strict === \"class_only\" && !isPlain) {\n    const descriptors = Object.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    let keys = Reflect.ownKeys(descriptors);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const desc = descriptors[key];\n      if (desc.writable === false) {\n        desc.writable = true;\n        desc.configurable = true;\n      }\n      if (desc.get || desc.set)\n        descriptors[key] = {\n          configurable: true,\n          writable: true,\n          // could live with !!desc.set as well here...\n          enumerable: desc.enumerable,\n          value: base[key]\n        };\n    }\n    return Object.create(getPrototypeOf(base), descriptors);\n  } else {\n    const proto = getPrototypeOf(base);\n    if (proto !== null && isPlain) {\n      return { ...base };\n    }\n    const obj = Object.create(proto);\n    return Object.assign(obj, base);\n  }\n}\nfunction freeze(obj, deep = false) {\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\n    return obj;\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n  Object.freeze(obj);\n  if (deep)\n    Object.entries(obj).forEach(([key, value]) => freeze(value, true));\n  return obj;\n}\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n}\n\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  const plugin = plugins[pluginKey];\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey])\n    plugins[pluginKey] = implementation;\n}\n\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n  return currentScope;\n}\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_,\n    immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n  const state = draft[DRAFT_STATE];\n  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)\n    state.revoke_();\n  else\n    state.revoked_ = true;\n}\n\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== void 0 && result !== baseDraft;\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_)\n        maybeFreeze(scope, result);\n    }\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(\n        baseDraft[DRAFT_STATE].base_,\n        result,\n        scope.patches_,\n        scope.inversePatches_\n      );\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n  revokeScope(scope);\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n  return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  if (!state) {\n    each(\n      value,\n      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)\n    );\n    return value;\n  }\n  if (state.scope_ !== rootScope)\n    return value;\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    const result = state.copy_;\n    let resultEach = result;\n    let isSet2 = false;\n    if (state.type_ === 3 /* Set */) {\n      resultEach = new Set(result);\n      result.clear();\n      isSet2 = true;\n    }\n    each(\n      resultEach,\n      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)\n    );\n    maybeFreeze(rootScope, result, false);\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(\n        state,\n        path,\n        rootScope.patches_,\n        rootScope.inversePatches_\n      );\n    }\n  }\n  return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if ( true && childValue === targetObject)\n    die(5);\n  if (isDraft(childValue)) {\n    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    const res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else\n      return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n    finalize(rootScope, childValue);\n    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))\n      maybeFreeze(rootScope, childValue);\n  }\n}\nfunction maybeFreeze(scope, value, deep = false) {\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n  const isArray = Array.isArray(base);\n  const state = {\n    type_: isArray ? 1 /* Array */ : 0 /* Object */,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  let target = state;\n  let traps = objectTraps;\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n  const { revoke, proxy } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\nvar objectTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE)\n      return state;\n    const source = latest(state);\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n    const value = source[prop];\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n    return value;\n  },\n  has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set(state, prop, value) {\n    const desc = getDescriptorFromProto(latest(state), prop);\n    if (desc?.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n    if (!state.modified_) {\n      const current2 = peek(latest(state), prop);\n      const currentState = current2?.[DRAFT_STATE];\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))\n        return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n    (value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))\n      return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(state, prop) {\n    const owner = latest(state);\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc)\n      return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1 /* Array */ || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty() {\n    die(11);\n  },\n  getPrototypeOf(state) {\n    return getPrototypeOf(state.base_);\n  },\n  setPrototypeOf() {\n    die(12);\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn) => {\n  arrayTraps[key] = function() {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function(state, prop) {\n  if ( true && isNaN(parseInt(prop)))\n    die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n  if ( true && prop !== \"length\" && isNaN(parseInt(prop)))\n    die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n  const desc = getDescriptorFromProto(source, prop);\n  return desc ? `value` in desc ? desc.value : (\n    // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_)\n  ) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source))\n    return void 0;\n  let proto = getPrototypeOf(source);\n  while (proto) {\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc)\n      return desc;\n    proto = getPrototypeOf(proto);\n  }\n  return void 0;\n}\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(\n      state.base_,\n      state.scope_.immer_.useStrictShallowCopy_\n    );\n  }\n}\n\n// src/core/immerClass.ts\nvar Immer2 = class {\n  constructor(config) {\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n    this.produce = (base, recipe, patchListener) => {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        const defaultBase = recipe;\n        recipe = base;\n        const self = this;\n        return function curriedProduce(base2 = defaultBase, ...args) {\n          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));\n        };\n      }\n      if (typeof recipe !== \"function\")\n        die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\")\n        die(7);\n      let result;\n      if (isDraftable(base)) {\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        let hasError = true;\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError)\n            revokeScope(scope);\n          else\n            leaveScope(scope);\n        }\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0)\n          result = base;\n        if (result === NOTHING)\n          result = void 0;\n        if (this.autoFreeze_)\n          freeze(result, true);\n        if (patchListener) {\n          const p = [];\n          const ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n        return result;\n      } else\n        die(1, base);\n    };\n    this.produceWithPatches = (base, recipe) => {\n      if (typeof base === \"function\") {\n        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));\n      }\n      let patches, inversePatches;\n      const result = this.produce(base, recipe, (p, ip) => {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n    if (typeof config?.autoFreeze === \"boolean\")\n      this.setAutoFreeze(config.autoFreeze);\n    if (typeof config?.useStrictShallowCopy === \"boolean\")\n      this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n  createDraft(base) {\n    if (!isDraftable(base))\n      die(8);\n    if (isDraft(base))\n      base = current(base);\n    const scope = enterScope(this);\n    const proxy = createProxy(base, void 0);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  }\n  finishDraft(draft, patchListener) {\n    const state = draft && draft[DRAFT_STATE];\n    if (!state || !state.isManual_)\n      die(9);\n    const { scope_: scope } = state;\n    usePatchesInScope(scope, patchListener);\n    return processResult(void 0, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n  setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n  setUseStrictShallowCopy(value) {\n    this.useStrictShallowCopy_ = value;\n  }\n  applyPatches(base, patches) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i--) {\n      const patch = patches[i];\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n    const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n    if (isDraft(base)) {\n      return applyPatchesImpl(base, patches);\n    }\n    return this.produce(\n      base,\n      (draft) => applyPatchesImpl(draft, patches)\n    );\n  }\n};\nfunction createProxy(value, parent) {\n  const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  const scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\n// src/core/current.ts\nfunction current(value) {\n  if (!isDraft(value))\n    die(10, value);\n  return currentImpl(value);\n}\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  let copy;\n  if (state) {\n    if (!state.modified_)\n      return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n  each(copy, (key, childValue) => {\n    set(copy, key, currentImpl(childValue));\n  });\n  if (state) {\n    state.finalized_ = false;\n  }\n  return copy;\n}\n\n// src/plugins/patches.ts\nfunction enablePatches() {\n  const errorOffset = 16;\n  if (true) {\n    errors.push(\n      'Sets cannot have \"replace\" patches.',\n      function(op) {\n        return \"Unsupported patch operation: \" + op;\n      },\n      function(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n      },\n      \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n    );\n  }\n  const REPLACE = \"replace\";\n  const ADD = \"add\";\n  const REMOVE = \"remove\";\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0 /* Object */:\n      case 2 /* Map */:\n        return generatePatchesFromAssigned(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n      case 1 /* Array */:\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n      case 3 /* Set */:\n        return generateSetPatches(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n    }\n  }\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    let { base_, assigned_ } = state;\n    let copy_ = state.copy_;\n    if (copy_.length < base_.length) {\n      ;\n      [base_, copy_] = [copy_, base_];\n      [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n    for (let i = base_.length; i < copy_.length; i++) {\n      const path = basePath.concat([i]);\n      patches.push({\n        op: ADD,\n        path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[i])\n      });\n    }\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\n      const path = basePath.concat([i]);\n      inversePatches.push({\n        op: REMOVE,\n        path\n      });\n    }\n  }\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    const { base_, copy_ } = state;\n    each(state.assigned_, (key, assignedValue) => {\n      const origValue = get(base_, key);\n      const value = get(copy_, key);\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE)\n        return;\n      const path = basePath.concat(key);\n      patches.push(op === REMOVE ? { op, path } : { op, path, value });\n      inversePatches.push(\n        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }\n      );\n    });\n  }\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    let { base_, copy_ } = state;\n    let i = 0;\n    base_.forEach((value) => {\n      if (!copy_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n    i = 0;\n    copy_.forEach((value) => {\n      if (!base_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n  }\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n  function applyPatches_(draft, patches) {\n    patches.forEach((patch) => {\n      const { path, op } = patch;\n      let base = draft;\n      for (let i = 0; i < path.length - 1; i++) {\n        const parentType = getArchtype(base);\n        let p = path[i];\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === \"__proto__\" || p === \"constructor\"))\n          die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\")\n          die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\")\n          die(errorOffset + 2, path.join(\"/\"));\n      }\n      const type = getArchtype(base);\n      const value = deepClonePatchValue(patch.value);\n      const key = path[path.length - 1];\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              die(errorOffset);\n            default:\n              return base[key] = value;\n          }\n        case ADD:\n          switch (type) {\n            case 1 /* Array */:\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              return base.add(value);\n            default:\n              return base[key] = value;\n          }\n        case REMOVE:\n          switch (type) {\n            case 1 /* Array */:\n              return base.splice(key, 1);\n            case 2 /* Map */:\n              return base.delete(key);\n            case 3 /* Set */:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj))\n      return obj;\n    if (Array.isArray(obj))\n      return obj.map(deepClonePatchValue);\n    if (isMap(obj))\n      return new Map(\n        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n      );\n    if (isSet(obj))\n      return new Set(Array.from(obj).map(deepClonePatchValue));\n    const cloned = Object.create(getPrototypeOf(obj));\n    for (const key in obj)\n      cloned[key] = deepClonePatchValue(obj[key]);\n    if (has(obj, DRAFTABLE))\n      cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else\n      return obj;\n  }\n  loadPlugin(\"Patches\", {\n    applyPatches_,\n    generatePatches_,\n    generateReplacementPatches_\n  });\n}\n\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n  class DraftMap extends Map {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 2 /* Map */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    }\n    set(key, value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n      return this;\n    }\n    delete(key) {\n      if (!this.has(key)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n      state.copy_.delete(key);\n      return true;\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = /* @__PURE__ */ new Map();\n        each(state.base_, (key) => {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    }\n    forEach(cb, thisArg) {\n      const state = this[DRAFT_STATE];\n      latest(state).forEach((_value, key, _map) => {\n        cb.call(thisArg, this.get(key), key, this);\n      });\n    }\n    get(key) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      const value = latest(state).get(key);\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n      if (value !== state.base_.get(key)) {\n        return value;\n      }\n      const draft = createProxy(value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    }\n    keys() {\n      return latest(this[DRAFT_STATE]).keys();\n    }\n    values() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.values(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n    }\n    entries() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.entries(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }\n      };\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.entries();\n    }\n  }\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */ new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n  class DraftSet extends Set {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 3 /* Set */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: this,\n        drafts_: /* @__PURE__ */ new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n      if (state.copy_.has(value))\n        return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n        return true;\n      return false;\n    }\n    add(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n      return this;\n    }\n    delete(value) {\n      if (!this.has(value)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (\n        /* istanbul ignore next */\n        false\n      ));\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    }\n    values() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    }\n    entries() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    }\n    keys() {\n      return this.values();\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.values();\n    }\n    forEach(cb, thisArg) {\n      const iterator = this.values();\n      let result = iterator.next();\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    }\n  }\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */ new Set();\n      state.base_.forEach((value) => {\n        if (isDraftable(value)) {\n          const draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n  function assertUnrevoked(state) {\n    if (state.revoked_)\n      die(3, JSON.stringify(latest(state)));\n  }\n  loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\n}\n\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(\n  immer\n);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n  return value;\n}\nfunction castImmutable(value) {\n  return value;\n}\n\n//# sourceMappingURL=immer.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0EsOEJBQThCLE9BQU8sa0ZBQWtGLE9BQU87QUFDOUgsR0FBRztBQUNIO0FBQ0EsaUtBQWlLLE1BQU07QUFDdkssR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNO0FBQ3BELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxDQUFFO0FBQ047QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLElBQUksaUJBQWlCO0FBQ3JFO0FBQ0EsdUJBQXVCLG1CQUFtQixvQkFBb0IsMkRBQTJELElBQUk7QUFDN0g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxQkU7QUFDRiIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxpbW1lclxcZGlzdFxcaW1tZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9lbnYudHNcbnZhciBOT1RISU5HID0gU3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik7XG52YXIgRFJBRlRBQkxFID0gU3ltYm9sLmZvcihcImltbWVyLWRyYWZ0YWJsZVwiKTtcbnZhciBEUkFGVF9TVEFURSA9IFN5bWJvbC5mb3IoXCJpbW1lci1zdGF0ZVwiKTtcblxuLy8gc3JjL3V0aWxzL2Vycm9ycy50c1xudmFyIGVycm9ycyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFtcbiAgLy8gQWxsIGVycm9yIGNvZGVzLCBzdGFydGluZyBieSAwOlxuICBmdW5jdGlvbihwbHVnaW4pIHtcbiAgICByZXR1cm4gYFRoZSBwbHVnaW4gZm9yICcke3BsdWdpbn0nIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBcXGBlbmFibGUke3BsdWdpbn0oKVxcYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLmA7XG4gIH0sXG4gIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIGBwcm9kdWNlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGluZ3MgdGhhdCBhcmUgZHJhZnRhYmxlOiBwbGFpbiBvYmplY3RzLCBhcnJheXMsIE1hcCwgU2V0IG9yIGNsYXNzZXMgdGhhdCBhcmUgbWFya2VkIHdpdGggJ1tpbW1lcmFibGVdOiB0cnVlJy4gR290ICcke3RoaW5nfSdgO1xuICB9LFxuICBcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIGZyb3plbiBhbmQgc2hvdWxkIG5vdCBiZSBtdXRhdGVkXCIsXG4gIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICsgZGF0YTtcbiAgfSxcbiAgXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiLFxuICBcIkltbWVyIGZvcmJpZHMgY2lyY3VsYXIgcmVmZXJlbmNlc1wiLFxuICBcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLFxuICBcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiLFxuICBcIkZpcnN0IGFyZ3VtZW50IHRvIGBjcmVhdGVEcmFmdGAgbXVzdCBiZSBhIHBsYWluIG9iamVjdCwgYW4gYXJyYXksIG9yIGFuIGltbWVyYWJsZSBvYmplY3RcIixcbiAgXCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsXG4gIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIGAnY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YDtcbiAgfSxcbiAgXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLFxuICBcIk9iamVjdC5zZXRQcm90b3R5cGVPZigpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG4gIFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG4gIFwiSW1tZXIgb25seSBzdXBwb3J0cyBzZXR0aW5nIGFycmF5IGluZGljZXMgYW5kIHRoZSAnbGVuZ3RoJyBwcm9wZXJ0eVwiLFxuICBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBgJ29yaWdpbmFsJyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0aGluZ31gO1xuICB9XG4gIC8vIE5vdGU6IGlmIG1vcmUgZXJyb3JzIGFyZSBhZGRlZCwgdGhlIGVycm9yT2Zmc2V0IGluIFBhdGNoZXMudHMgc2hvdWxkIGJlIGluY3JlYXNlZFxuICAvLyBTZWUgUGF0Y2hlcy50cyBmb3IgYWRkaXRpb25hbCBlcnJvcnNcbl0gOiBbXTtcbmZ1bmN0aW9uIGRpZShlcnJvciwgLi4uYXJncykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgZSA9IGVycm9yc1tlcnJvcl07XG4gICAgY29uc3QgbXNnID0gdHlwZW9mIGUgPT09IFwiZnVuY3Rpb25cIiA/IGUuYXBwbHkobnVsbCwgYXJncykgOiBlO1xuICAgIHRocm93IG5ldyBFcnJvcihgW0ltbWVyXSAke21zZ31gKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYFtJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6ICR7ZXJyb3J9LiBGdWxsIGVycm9yIGF0OiBodHRwczovL2JpdC5seS8zY1hFS1dmYFxuICApO1xufVxuXG4vLyBzcmMvdXRpbHMvY29tbW9uLnRzXG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5mdW5jdGlvbiBpc0RyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmICEhdmFsdWVbRFJBRlRfU1RBVEVdO1xufVxuZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCAhIXZhbHVlW0RSQUZUQUJMRV0gfHwgISF2YWx1ZS5jb25zdHJ1Y3Rvcj8uW0RSQUZUQUJMRV0gfHwgaXNNYXAodmFsdWUpIHx8IGlzU2V0KHZhbHVlKTtcbn1cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci50b1N0cmluZygpO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBDdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIGlmIChDdG9yID09PSBPYmplY3QpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgRnVuY3Rpb24udG9TdHJpbmcuY2FsbChDdG9yKSA9PT0gb2JqZWN0Q3RvclN0cmluZztcbn1cbmZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpXG4gICAgZGllKDE1LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZV87XG59XG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlcikge1xuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA9PT0gMCAvKiBPYmplY3QgKi8pIHtcbiAgICBSZWZsZWN0Lm93bktleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmouZm9yRWFjaCgoZW50cnksIGluZGV4KSA9PiBpdGVyKGluZGV4LCBlbnRyeSwgb2JqKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpbmdbRFJBRlRfU1RBVEVdO1xuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS50eXBlXyA6IEFycmF5LmlzQXJyYXkodGhpbmcpID8gMSAvKiBBcnJheSAqLyA6IGlzTWFwKHRoaW5nKSA/IDIgLyogTWFwICovIDogaXNTZXQodGhpbmcpID8gMyAvKiBTZXQgKi8gOiAwIC8qIE9iamVjdCAqLztcbn1cbmZ1bmN0aW9uIGhhcyh0aGluZywgcHJvcCkge1xuICByZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSAyIC8qIE1hcCAqLyA/IHRoaW5nLmhhcyhwcm9wKSA6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGluZywgcHJvcCk7XG59XG5mdW5jdGlvbiBnZXQodGhpbmcsIHByb3ApIHtcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMiAvKiBNYXAgKi8gPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXTtcbn1cbmZ1bmN0aW9uIHNldCh0aGluZywgcHJvcE9yT2xkVmFsdWUsIHZhbHVlKSB7XG4gIGNvbnN0IHQgPSBnZXRBcmNodHlwZSh0aGluZyk7XG4gIGlmICh0ID09PSAyIC8qIE1hcCAqLylcbiAgICB0aGluZy5zZXQocHJvcE9yT2xkVmFsdWUsIHZhbHVlKTtcbiAgZWxzZSBpZiAodCA9PT0gMyAvKiBTZXQgKi8pIHtcbiAgICB0aGluZy5hZGQodmFsdWUpO1xuICB9IGVsc2VcbiAgICB0aGluZ1twcm9wT3JPbGRWYWx1ZV0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYXAodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBNYXA7XG59XG5mdW5jdGlvbiBpc1NldCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIFNldDtcbn1cbmZ1bmN0aW9uIGxhdGVzdChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuY29weV8gfHwgc3RhdGUuYmFzZV87XG59XG5mdW5jdGlvbiBzaGFsbG93Q29weShiYXNlLCBzdHJpY3QpIHtcbiAgaWYgKGlzTWFwKGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoYmFzZSk7XG4gIH1cbiAgaWYgKGlzU2V0KGJhc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoYmFzZSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYmFzZSkpXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJhc2UpO1xuICBjb25zdCBpc1BsYWluID0gaXNQbGFpbk9iamVjdChiYXNlKTtcbiAgaWYgKHN0cmljdCA9PT0gdHJ1ZSB8fCBzdHJpY3QgPT09IFwiY2xhc3Nfb25seVwiICYmICFpc1BsYWluKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKTtcbiAgICBkZWxldGUgZGVzY3JpcHRvcnNbRFJBRlRfU1RBVEVdO1xuICAgIGxldCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKGRlc2NyaXB0b3JzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCBkZXNjID0gZGVzY3JpcHRvcnNba2V5XTtcbiAgICAgIGlmIChkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KVxuICAgICAgICBkZXNjcmlwdG9yc1trZXldID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAvLyBjb3VsZCBsaXZlIHdpdGggISFkZXNjLnNldCBhcyB3ZWxsIGhlcmUuLi5cbiAgICAgICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG4gICAgICAgICAgdmFsdWU6IGJhc2Vba2V5XVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShnZXRQcm90b3R5cGVPZihiYXNlKSwgZGVzY3JpcHRvcnMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYmFzZSk7XG4gICAgaWYgKHByb3RvICE9PSBudWxsICYmIGlzUGxhaW4pIHtcbiAgICAgIHJldHVybiB7IC4uLmJhc2UgfTtcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBiYXNlKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJlZXplKG9iaiwgZGVlcCA9IGZhbHNlKSB7XG4gIGlmIChpc0Zyb3plbihvYmopIHx8IGlzRHJhZnQob2JqKSB8fCAhaXNEcmFmdGFibGUob2JqKSlcbiAgICByZXR1cm4gb2JqO1xuICBpZiAoZ2V0QXJjaHR5cGUob2JqKSA+IDEpIHtcbiAgICBvYmouc2V0ID0gb2JqLmFkZCA9IG9iai5jbGVhciA9IG9iai5kZWxldGUgPSBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnM7XG4gIH1cbiAgT2JqZWN0LmZyZWV6ZShvYmopO1xuICBpZiAoZGVlcClcbiAgICBPYmplY3QuZW50cmllcyhvYmopLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4gZnJlZXplKHZhbHVlLCB0cnVlKSk7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMoKSB7XG4gIGRpZSgyKTtcbn1cbmZ1bmN0aW9uIGlzRnJvemVuKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iaik7XG59XG5cbi8vIHNyYy91dGlscy9wbHVnaW5zLnRzXG52YXIgcGx1Z2lucyA9IHt9O1xuZnVuY3Rpb24gZ2V0UGx1Z2luKHBsdWdpbktleSkge1xuICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV07XG4gIGlmICghcGx1Z2luKSB7XG4gICAgZGllKDAsIHBsdWdpbktleSk7XG4gIH1cbiAgcmV0dXJuIHBsdWdpbjtcbn1cbmZ1bmN0aW9uIGxvYWRQbHVnaW4ocGx1Z2luS2V5LCBpbXBsZW1lbnRhdGlvbikge1xuICBpZiAoIXBsdWdpbnNbcGx1Z2luS2V5XSlcbiAgICBwbHVnaW5zW3BsdWdpbktleV0gPSBpbXBsZW1lbnRhdGlvbjtcbn1cblxuLy8gc3JjL2NvcmUvc2NvcGUudHNcbnZhciBjdXJyZW50U2NvcGU7XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gIHJldHVybiBjdXJyZW50U2NvcGU7XG59XG5mdW5jdGlvbiBjcmVhdGVTY29wZShwYXJlbnRfLCBpbW1lcl8pIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFmdHNfOiBbXSxcbiAgICBwYXJlbnRfLFxuICAgIGltbWVyXyxcbiAgICAvLyBXaGVuZXZlciB0aGUgbW9kaWZpZWQgZHJhZnQgY29udGFpbnMgYSBkcmFmdCBmcm9tIGFub3RoZXIgc2NvcGUsIHdlXG4gICAgLy8gbmVlZCB0byBwcmV2ZW50IGF1dG8tZnJlZXppbmcgc28gdGhlIHVub3duZWQgZHJhZnQgY2FuIGJlIGZpbmFsaXplZC5cbiAgICBjYW5BdXRvRnJlZXplXzogdHJ1ZSxcbiAgICB1bmZpbmFsaXplZERyYWZ0c186IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKSB7XG4gIGlmIChwYXRjaExpc3RlbmVyKSB7XG4gICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKTtcbiAgICBzY29wZS5wYXRjaGVzXyA9IFtdO1xuICAgIHNjb3BlLmludmVyc2VQYXRjaGVzXyA9IFtdO1xuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfID0gcGF0Y2hMaXN0ZW5lcjtcbiAgfVxufVxuZnVuY3Rpb24gcmV2b2tlU2NvcGUoc2NvcGUpIHtcbiAgbGVhdmVTY29wZShzY29wZSk7XG4gIHNjb3BlLmRyYWZ0c18uZm9yRWFjaChyZXZva2VEcmFmdCk7XG4gIHNjb3BlLmRyYWZ0c18gPSBudWxsO1xufVxuZnVuY3Rpb24gbGVhdmVTY29wZShzY29wZSkge1xuICBpZiAoc2NvcGUgPT09IGN1cnJlbnRTY29wZSkge1xuICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF87XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXIyKSB7XG4gIHJldHVybiBjdXJyZW50U2NvcGUgPSBjcmVhdGVTY29wZShjdXJyZW50U2NvcGUsIGltbWVyMik7XG59XG5mdW5jdGlvbiByZXZva2VEcmFmdChkcmFmdCkge1xuICBjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgaWYgKHN0YXRlLnR5cGVfID09PSAwIC8qIE9iamVjdCAqLyB8fCBzdGF0ZS50eXBlXyA9PT0gMSAvKiBBcnJheSAqLylcbiAgICBzdGF0ZS5yZXZva2VfKCk7XG4gIGVsc2VcbiAgICBzdGF0ZS5yZXZva2VkXyA9IHRydWU7XG59XG5cbi8vIHNyYy9jb3JlL2ZpbmFsaXplLnRzXG5mdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpIHtcbiAgc2NvcGUudW5maW5hbGl6ZWREcmFmdHNfID0gc2NvcGUuZHJhZnRzXy5sZW5ndGg7XG4gIGNvbnN0IGJhc2VEcmFmdCA9IHNjb3BlLmRyYWZ0c19bMF07XG4gIGNvbnN0IGlzUmVwbGFjZWQgPSByZXN1bHQgIT09IHZvaWQgMCAmJiByZXN1bHQgIT09IGJhc2VEcmFmdDtcbiAgaWYgKGlzUmVwbGFjZWQpIHtcbiAgICBpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZF8pIHtcbiAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgIGRpZSg0KTtcbiAgICB9XG4gICAgaWYgKGlzRHJhZnRhYmxlKHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCByZXN1bHQpO1xuICAgICAgaWYgKCFzY29wZS5wYXJlbnRfKVxuICAgICAgICBtYXliZUZyZWV6ZShzY29wZSwgcmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhcbiAgICAgICAgYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5iYXNlXyxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBzY29wZS5wYXRjaGVzXyxcbiAgICAgICAgc2NvcGUuaW52ZXJzZVBhdGNoZXNfXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgYmFzZURyYWZ0LCBbXSk7XG4gIH1cbiAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyhzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0ICE9PSBOT1RISU5HID8gcmVzdWx0IDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZmluYWxpemUocm9vdFNjb3BlLCB2YWx1ZSwgcGF0aCkge1xuICBpZiAoaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qgc3RhdGUgPSB2YWx1ZVtEUkFGVF9TVEFURV07XG4gIGlmICghc3RhdGUpIHtcbiAgICBlYWNoKFxuICAgICAgdmFsdWUsXG4gICAgICAoa2V5LCBjaGlsZFZhbHVlKSA9PiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHZhbHVlLCBrZXksIGNoaWxkVmFsdWUsIHBhdGgpXG4gICAgKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHN0YXRlLnNjb3BlXyAhPT0gcm9vdFNjb3BlKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHN0YXRlLmJhc2VfLCB0cnVlKTtcbiAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gIH1cbiAgaWYgKCFzdGF0ZS5maW5hbGl6ZWRfKSB7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gICAgc3RhdGUuc2NvcGVfLnVuZmluYWxpemVkRHJhZnRzXy0tO1xuICAgIGNvbnN0IHJlc3VsdCA9IHN0YXRlLmNvcHlfO1xuICAgIGxldCByZXN1bHRFYWNoID0gcmVzdWx0O1xuICAgIGxldCBpc1NldDIgPSBmYWxzZTtcbiAgICBpZiAoc3RhdGUudHlwZV8gPT09IDMgLyogU2V0ICovKSB7XG4gICAgICByZXN1bHRFYWNoID0gbmV3IFNldChyZXN1bHQpO1xuICAgICAgcmVzdWx0LmNsZWFyKCk7XG4gICAgICBpc1NldDIgPSB0cnVlO1xuICAgIH1cbiAgICBlYWNoKFxuICAgICAgcmVzdWx0RWFjaCxcbiAgICAgIChrZXksIGNoaWxkVmFsdWUpID0+IGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgcmVzdWx0LCBrZXksIGNoaWxkVmFsdWUsIHBhdGgsIGlzU2V0MilcbiAgICApO1xuICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgcmVzdWx0LCBmYWxzZSk7XG4gICAgaWYgKHBhdGggJiYgcm9vdFNjb3BlLnBhdGNoZXNfKSB7XG4gICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUGF0Y2hlc18oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwYXRoLFxuICAgICAgICByb290U2NvcGUucGF0Y2hlc18sXG4gICAgICAgIHJvb3RTY29wZS5pbnZlcnNlUGF0Y2hlc19cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZS5jb3B5Xztcbn1cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBwYXJlbnRTdGF0ZSwgdGFyZ2V0T2JqZWN0LCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCwgdGFyZ2V0SXNTZXQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjaGlsZFZhbHVlID09PSB0YXJnZXRPYmplY3QpXG4gICAgZGllKDUpO1xuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuICAgIGNvbnN0IHBhdGggPSByb290UGF0aCAmJiBwYXJlbnRTdGF0ZSAmJiBwYXJlbnRTdGF0ZS50eXBlXyAhPT0gMyAvKiBTZXQgKi8gJiYgLy8gU2V0IG9iamVjdHMgYXJlIGF0b21pYyBzaW5jZSB0aGV5IGhhdmUgbm8ga2V5cy5cbiAgICAhaGFzKHBhcmVudFN0YXRlLmFzc2lnbmVkXywgcHJvcCkgPyByb290UGF0aC5jb25jYXQocHJvcCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKTtcbiAgICBzZXQodGFyZ2V0T2JqZWN0LCBwcm9wLCByZXMpO1xuICAgIGlmIChpc0RyYWZ0KHJlcykpIHtcbiAgICAgIHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHRhcmdldElzU2V0KSB7XG4gICAgdGFyZ2V0T2JqZWN0LmFkZChjaGlsZFZhbHVlKTtcbiAgfVxuICBpZiAoaXNEcmFmdGFibGUoY2hpbGRWYWx1ZSkgJiYgIWlzRnJvemVuKGNoaWxkVmFsdWUpKSB7XG4gICAgaWYgKCFyb290U2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHJvb3RTY29wZS51bmZpbmFsaXplZERyYWZ0c18gPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7XG4gICAgaWYgKCghcGFyZW50U3RhdGUgfHwgIXBhcmVudFN0YXRlLnNjb3BlXy5wYXJlbnRfKSAmJiB0eXBlb2YgcHJvcCAhPT0gXCJzeW1ib2xcIiAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0T2JqZWN0LCBwcm9wKSlcbiAgICAgIG1heWJlRnJlZXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlLCB2YWx1ZSwgZGVlcCA9IGZhbHNlKSB7XG4gIGlmICghc2NvcGUucGFyZW50XyAmJiBzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcbiAgICBmcmVlemUodmFsdWUsIGRlZXApO1xuICB9XG59XG5cbi8vIHNyYy9jb3JlL3Byb3h5LnRzXG5mdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5KGJhc2UsIHBhcmVudCkge1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgdHlwZV86IGlzQXJyYXkgPyAxIC8qIEFycmF5ICovIDogMCAvKiBPYmplY3QgKi8sXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvZHVjZSBjYWxsIHRoaXMgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgIC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgIC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG4gICAgYXNzaWduZWRfOiB7fSxcbiAgICAvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cbiAgICBiYXNlXzogYmFzZSxcbiAgICAvLyBUaGUgYmFzZSBwcm94eS5cbiAgICBkcmFmdF86IG51bGwsXG4gICAgLy8gc2V0IGJlbG93XG4gICAgLy8gVGhlIGJhc2UgY29weSB3aXRoIGFueSB1cGRhdGVkIHZhbHVlcy5cbiAgICBjb3B5XzogbnVsbCxcbiAgICAvLyBDYWxsZWQgYnkgdGhlIGBwcm9kdWNlYCBmdW5jdGlvbi5cbiAgICByZXZva2VfOiBudWxsLFxuICAgIGlzTWFudWFsXzogZmFsc2VcbiAgfTtcbiAgbGV0IHRhcmdldCA9IHN0YXRlO1xuICBsZXQgdHJhcHMgPSBvYmplY3RUcmFwcztcbiAgaWYgKGlzQXJyYXkpIHtcbiAgICB0YXJnZXQgPSBbc3RhdGVdO1xuICAgIHRyYXBzID0gYXJyYXlUcmFwcztcbiAgfVxuICBjb25zdCB7IHJldm9rZSwgcHJveHkgfSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKTtcbiAgc3RhdGUuZHJhZnRfID0gcHJveHk7XG4gIHN0YXRlLnJldm9rZV8gPSByZXZva2U7XG4gIHJldHVybiBwcm94eTtcbn1cbnZhciBvYmplY3RUcmFwcyA9IHtcbiAgZ2V0KHN0YXRlLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IERSQUZUX1NUQVRFKVxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IHNvdXJjZSA9IGxhdGVzdChzdGF0ZSk7XG4gICAgaWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuICAgICAgcmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcbiAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gcGVlayhzdGF0ZS5iYXNlXywgcHJvcCkpIHtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5X1twcm9wXSA9IGNyZWF0ZVByb3h5KHZhbHVlLCBzdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgaGFzKHN0YXRlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKTtcbiAgfSxcbiAgb3duS2V5cyhzdGF0ZSkge1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMobGF0ZXN0KHN0YXRlKSk7XG4gIH0sXG4gIHNldChzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcbiAgICBpZiAoZGVzYz8uc2V0KSB7XG4gICAgICBkZXNjLnNldC5jYWxsKHN0YXRlLmRyYWZ0XywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgICBjb25zdCBjdXJyZW50MiA9IHBlZWsobGF0ZXN0KHN0YXRlKSwgcHJvcCk7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBjdXJyZW50Mj8uW0RSQUZUX1NUQVRFXTtcbiAgICAgIGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLmJhc2VfID09PSB2YWx1ZSkge1xuICAgICAgICBzdGF0ZS5jb3B5X1twcm9wXSA9IHZhbHVlO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXModmFsdWUsIGN1cnJlbnQyKSAmJiAodmFsdWUgIT09IHZvaWQgMCB8fCBoYXMoc3RhdGUuYmFzZV8sIHByb3ApKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3B5X1twcm9wXSA9PT0gdmFsdWUgJiYgLy8gc3BlY2lhbCBjYXNlOiBoYW5kbGUgbmV3IHByb3BzIHdpdGggdmFsdWUgJ3VuZGVmaW5lZCdcbiAgICAodmFsdWUgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSB8fCAvLyBzcGVjaWFsIGNhc2U6IE5hTlxuICAgIE51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzTmFOKHN0YXRlLmNvcHlfW3Byb3BdKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgc3RhdGUuYXNzaWduZWRfW3Byb3BdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkoc3RhdGUsIHByb3ApIHtcbiAgICBpZiAocGVlayhzdGF0ZS5iYXNlXywgcHJvcCkgIT09IHZvaWQgMCB8fCBwcm9wIGluIHN0YXRlLmJhc2VfKSB7XG4gICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHN0YXRlLmFzc2lnbmVkX1twcm9wXTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcHlfKSB7XG4gICAgICBkZWxldGUgc3RhdGUuY29weV9bcHJvcF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBOb3RlOiBXZSBuZXZlciBjb2VyY2UgYGRlc2MudmFsdWVgIGludG8gYW4gSW1tZXIgZHJhZnQsIGJlY2F1c2Ugd2UgY2FuJ3QgbWFrZVxuICAvLyB0aGUgc2FtZSBndWFyYW50ZWUgaW4gRVM1IG1vZGUuXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdGF0ZSwgcHJvcCkge1xuICAgIGNvbnN0IG93bmVyID0gbGF0ZXN0KHN0YXRlKTtcbiAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApO1xuICAgIGlmICghZGVzYylcbiAgICAgIHJldHVybiBkZXNjO1xuICAgIHJldHVybiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogc3RhdGUudHlwZV8gIT09IDEgLyogQXJyYXkgKi8gfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcbiAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcbiAgICAgIHZhbHVlOiBvd25lcltwcm9wXVxuICAgIH07XG4gIH0sXG4gIGRlZmluZVByb3BlcnR5KCkge1xuICAgIGRpZSgxMSk7XG4gIH0sXG4gIGdldFByb3RvdHlwZU9mKHN0YXRlKSB7XG4gICAgcmV0dXJuIGdldFByb3RvdHlwZU9mKHN0YXRlLmJhc2VfKTtcbiAgfSxcbiAgc2V0UHJvdG90eXBlT2YoKSB7XG4gICAgZGllKDEyKTtcbiAgfVxufTtcbnZhciBhcnJheVRyYXBzID0ge307XG5lYWNoKG9iamVjdFRyYXBzLCAoa2V5LCBmbikgPT4ge1xuICBhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF1bMF07XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KTtcbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGlzTmFOKHBhcnNlSW50KHByb3ApKSlcbiAgICBkaWUoMTMpO1xuICByZXR1cm4gYXJyYXlUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZSwgcHJvcCwgdm9pZCAwKTtcbn07XG5hcnJheVRyYXBzLnNldCA9IGZ1bmN0aW9uKHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKVxuICAgIGRpZSgxNCk7XG4gIHJldHVybiBvYmplY3RUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZVswXSwgcHJvcCwgdmFsdWUsIHN0YXRlWzBdKTtcbn07XG5mdW5jdGlvbiBwZWVrKGRyYWZ0LCBwcm9wKSB7XG4gIGNvbnN0IHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xuICBjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdDtcbiAgcmV0dXJuIHNvdXJjZVtwcm9wXTtcbn1cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApIHtcbiAgY29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKTtcbiAgcmV0dXJuIGRlc2MgPyBgdmFsdWVgIGluIGRlc2MgPyBkZXNjLnZhbHVlIDogKFxuICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZSwgaWYgdGhlIHByb3AgaXMgYSBnZXR0ZXIgZGVmaW5lZCBieSB0aGVcbiAgICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcbiAgICBkZXNjLmdldD8uY2FsbChzdGF0ZS5kcmFmdF8pXG4gICkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yRnJvbVByb3RvKHNvdXJjZSwgcHJvcCkge1xuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgbGV0IHByb3RvID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlKTtcbiAgd2hpbGUgKHByb3RvKSB7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIHByb3ApO1xuICAgIGlmIChkZXNjKVxuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgc3RhdGUubW9kaWZpZWRfID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUucGFyZW50Xykge1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlQ29weShzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShcbiAgICAgIHN0YXRlLmJhc2VfLFxuICAgICAgc3RhdGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV9cbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb3JlL2ltbWVyQ2xhc3MudHNcbnZhciBJbW1lcjIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuYXV0b0ZyZWV6ZV8gPSB0cnVlO1xuICAgIHRoaXMudXNlU3RyaWN0U2hhbGxvd0NvcHlfID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXG4gICAgICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXG4gICAgICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXG4gICAgICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxuICAgICAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXG4gICAgICpcbiAgICAgKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcbiAgICAgKiBjb25zaWRlcmVkIHVuY29weWFibGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNpcGUgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG4gICAgICogQHJldHVybnMge2FueX0gYSBuZXcgc3RhdGUsIG9yIHRoZSBpbml0aWFsIHN0YXRlIGlmIG5vdGhpbmcgd2FzIG1vZGlmaWVkXG4gICAgICovXG4gICAgdGhpcy5wcm9kdWNlID0gKGJhc2UsIHJlY2lwZSwgcGF0Y2hMaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlO1xuICAgICAgICByZWNpcGUgPSBiYXNlO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRQcm9kdWNlKGJhc2UyID0gZGVmYXVsdEJhc2UsIC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5wcm9kdWNlKGJhc2UyLCAoZHJhZnQpID0+IHJlY2lwZS5jYWxsKHRoaXMsIGRyYWZ0LCAuLi5hcmdzKSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlY2lwZSAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBkaWUoNik7XG4gICAgICBpZiAocGF0Y2hMaXN0ZW5lciAhPT0gdm9pZCAwICYmIHR5cGVvZiBwYXRjaExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGRpZSg3KTtcbiAgICAgIGxldCByZXN1bHQ7XG4gICAgICBpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpO1xuICAgICAgICBjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KGJhc2UsIHZvaWQgMCk7XG4gICAgICAgIGxldCBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjaXBlKHByb3h5KTtcbiAgICAgICAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoYXNFcnJvcilcbiAgICAgICAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpO1xuICAgICAgfSBlbHNlIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXN1bHQgPSByZWNpcGUoYmFzZSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMClcbiAgICAgICAgICByZXN1bHQgPSBiYXNlO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBOT1RISU5HKVxuICAgICAgICAgIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0ZyZWV6ZV8pXG4gICAgICAgICAgZnJlZXplKHJlc3VsdCwgdHJ1ZSk7XG4gICAgICAgIGlmIChwYXRjaExpc3RlbmVyKSB7XG4gICAgICAgICAgY29uc3QgcCA9IFtdO1xuICAgICAgICAgIGNvbnN0IGlwID0gW107XG4gICAgICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZSwgcmVzdWx0LCBwLCBpcCk7XG4gICAgICAgICAgcGF0Y2hMaXN0ZW5lcihwLCBpcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkaWUoMSwgYmFzZSk7XG4gICAgfTtcbiAgICB0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyA9IChiYXNlLCByZWNpcGUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAoc3RhdGUsIC4uLmFyZ3MpID0+IHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzKHN0YXRlLCAoZHJhZnQpID0+IGJhc2UoZHJhZnQsIC4uLmFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucHJvZHVjZShiYXNlLCByZWNpcGUsIChwLCBpcCkgPT4ge1xuICAgICAgICBwYXRjaGVzID0gcDtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMgPSBpcDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzXTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgY29uZmlnPy5hdXRvRnJlZXplID09PSBcImJvb2xlYW5cIilcbiAgICAgIHRoaXMuc2V0QXV0b0ZyZWV6ZShjb25maWcuYXV0b0ZyZWV6ZSk7XG4gICAgaWYgKHR5cGVvZiBjb25maWc/LnVzZVN0cmljdFNoYWxsb3dDb3B5ID09PSBcImJvb2xlYW5cIilcbiAgICAgIHRoaXMuc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkoY29uZmlnLnVzZVN0cmljdFNoYWxsb3dDb3B5KTtcbiAgfVxuICBjcmVhdGVEcmFmdChiYXNlKSB7XG4gICAgaWYgKCFpc0RyYWZ0YWJsZShiYXNlKSlcbiAgICAgIGRpZSg4KTtcbiAgICBpZiAoaXNEcmFmdChiYXNlKSlcbiAgICAgIGJhc2UgPSBjdXJyZW50KGJhc2UpO1xuICAgIGNvbnN0IHNjb3BlID0gZW50ZXJTY29wZSh0aGlzKTtcbiAgICBjb25zdCBwcm94eSA9IGNyZWF0ZVByb3h5KGJhc2UsIHZvaWQgMCk7XG4gICAgcHJveHlbRFJBRlRfU1RBVEVdLmlzTWFudWFsXyA9IHRydWU7XG4gICAgbGVhdmVTY29wZShzY29wZSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9XG4gIGZpbmlzaERyYWZ0KGRyYWZ0LCBwYXRjaExpc3RlbmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBkcmFmdCAmJiBkcmFmdFtEUkFGVF9TVEFURV07XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuaXNNYW51YWxfKVxuICAgICAgZGllKDkpO1xuICAgIGNvbnN0IHsgc2NvcGVfOiBzY29wZSB9ID0gc3RhdGU7XG4gICAgdXNlUGF0Y2hlc0luU2NvcGUoc2NvcGUsIHBhdGNoTGlzdGVuZXIpO1xuICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHZvaWQgMCwgc2NvcGUpO1xuICB9XG4gIC8qKlxuICAgKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhdXRvLWZyZWV6aW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBzZXRBdXRvRnJlZXplKHZhbHVlKSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBQYXNzIHRydWUgdG8gZW5hYmxlIHN0cmljdCBzaGFsbG93IGNvcHkuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGltbWVyIGRvZXMgbm90IGNvcHkgdGhlIG9iamVjdCBkZXNjcmlwdG9ycyBzdWNoIGFzIGdldHRlciwgc2V0dGVyIGFuZCBub24tZW51bXJhYmxlIHByb3BlcnRpZXMuXG4gICAqL1xuICBzZXRVc2VTdHJpY3RTaGFsbG93Q29weSh2YWx1ZSkge1xuICAgIHRoaXMudXNlU3RyaWN0U2hhbGxvd0NvcHlfID0gdmFsdWU7XG4gIH1cbiAgYXBwbHlQYXRjaGVzKGJhc2UsIHBhdGNoZXMpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKTtcbiAgICB9XG4gICAgY29uc3QgYXBwbHlQYXRjaGVzSW1wbCA9IGdldFBsdWdpbihcIlBhdGNoZXNcIikuYXBwbHlQYXRjaGVzXztcbiAgICBpZiAoaXNEcmFmdChiYXNlKSkge1xuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2R1Y2UoXG4gICAgICBiYXNlLFxuICAgICAgKGRyYWZ0KSA9PiBhcHBseVBhdGNoZXNJbXBsKGRyYWZ0LCBwYXRjaGVzKVxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVQcm94eSh2YWx1ZSwgcGFyZW50KSB7XG4gIGNvbnN0IGRyYWZ0ID0gaXNNYXAodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5TWFwXyh2YWx1ZSwgcGFyZW50KSA6IGlzU2V0KHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eVNldF8odmFsdWUsIHBhcmVudCkgOiBjcmVhdGVQcm94eVByb3h5KHZhbHVlLCBwYXJlbnQpO1xuICBjb25zdCBzY29wZSA9IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKTtcbiAgc2NvcGUuZHJhZnRzXy5wdXNoKGRyYWZ0KTtcbiAgcmV0dXJuIGRyYWZ0O1xufVxuXG4vLyBzcmMvY29yZS9jdXJyZW50LnRzXG5mdW5jdGlvbiBjdXJyZW50KHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdCh2YWx1ZSkpXG4gICAgZGllKDEwLCB2YWx1ZSk7XG4gIHJldHVybiBjdXJyZW50SW1wbCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjdXJyZW50SW1wbCh2YWx1ZSkge1xuICBpZiAoIWlzRHJhZnRhYmxlKHZhbHVlKSB8fCBpc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBjb25zdCBzdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXTtcbiAgbGV0IGNvcHk7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICghc3RhdGUubW9kaWZpZWRfKVxuICAgICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIGNvcHkgPSBzaGFsbG93Q29weSh2YWx1ZSwgc3RhdGUuc2NvcGVfLmltbWVyXy51c2VTdHJpY3RTaGFsbG93Q29weV8pO1xuICB9IGVsc2Uge1xuICAgIGNvcHkgPSBzaGFsbG93Q29weSh2YWx1ZSwgdHJ1ZSk7XG4gIH1cbiAgZWFjaChjb3B5LCAoa2V5LCBjaGlsZFZhbHVlKSA9PiB7XG4gICAgc2V0KGNvcHksIGtleSwgY3VycmVudEltcGwoY2hpbGRWYWx1ZSkpO1xuICB9KTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG4vLyBzcmMvcGx1Z2lucy9wYXRjaGVzLnRzXG5mdW5jdGlvbiBlbmFibGVQYXRjaGVzKCkge1xuICBjb25zdCBlcnJvck9mZnNldCA9IDE2O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICAnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG4gICAgICBmdW5jdGlvbihvcCkge1xuICAgICAgICByZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3A7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIiArIHBhdGg7XG4gICAgICB9LFxuICAgICAgXCJQYXRjaGluZyByZXNlcnZlZCBhdHRyaWJ1dGVzIGxpa2UgX19wcm90b19fLCBwcm90b3R5cGUgYW5kIGNvbnN0cnVjdG9yIGlzIG5vdCBhbGxvd2VkXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IFJFUExBQ0UgPSBcInJlcGxhY2VcIjtcbiAgY29uc3QgQUREID0gXCJhZGRcIjtcbiAgY29uc3QgUkVNT1ZFID0gXCJyZW1vdmVcIjtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzXyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgc3dpdGNoIChzdGF0ZS50eXBlXykge1xuICAgICAgY2FzZSAwIC8qIE9iamVjdCAqLzpcbiAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgICAgcGF0Y2hlcyxcbiAgICAgICAgICBpbnZlcnNlUGF0Y2hlc1xuICAgICAgICApO1xuICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XG4gICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTZXRQYXRjaGVzKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgIHBhdGNoZXMsXG4gICAgICAgICAgaW52ZXJzZVBhdGNoZXNcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVBcnJheVBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGxldCB7IGJhc2VfLCBhc3NpZ25lZF8gfSA9IHN0YXRlO1xuICAgIGxldCBjb3B5XyA9IHN0YXRlLmNvcHlfO1xuICAgIGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcbiAgICAgIDtcbiAgICAgIFtiYXNlXywgY29weV9dID0gW2NvcHlfLCBiYXNlX107XG4gICAgICBbcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdID0gW2ludmVyc2VQYXRjaGVzLCBwYXRjaGVzXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFzc2lnbmVkX1tpXSAmJiBjb3B5X1tpXSAhPT0gYmFzZV9baV0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW2ldKVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoYmFzZV9baV0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgY29weV8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBBREQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW2ldKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBjb3B5Xy5sZW5ndGggLSAxOyBiYXNlXy5sZW5ndGggPD0gaTsgLS1pKSB7XG4gICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgcGF0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgY29uc3QgeyBiYXNlXywgY29weV8gfSA9IHN0YXRlO1xuICAgIGVhY2goc3RhdGUuYXNzaWduZWRfLCAoa2V5LCBhc3NpZ25lZFZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBvcmlnVmFsdWUgPSBnZXQoYmFzZV8sIGtleSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldChjb3B5Xywga2V5KTtcbiAgICAgIGNvbnN0IG9wID0gIWFzc2lnbmVkVmFsdWUgPyBSRU1PVkUgOiBoYXMoYmFzZV8sIGtleSkgPyBSRVBMQUNFIDogQUREO1xuICAgICAgaWYgKG9yaWdWYWx1ZSA9PT0gdmFsdWUgJiYgb3AgPT09IFJFUExBQ0UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoa2V5KTtcbiAgICAgIHBhdGNoZXMucHVzaChvcCA9PT0gUkVNT1ZFID8geyBvcCwgcGF0aCB9IDogeyBvcCwgcGF0aCwgdmFsdWUgfSk7XG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKFxuICAgICAgICBvcCA9PT0gQUREID8geyBvcDogUkVNT1ZFLCBwYXRoIH0gOiBvcCA9PT0gUkVNT1ZFID8geyBvcDogQURELCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKSB9IDogeyBvcDogUkVQTEFDRSwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSkgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIGxldCB7IGJhc2VfLCBjb3B5XyB9ID0gc3RhdGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGJhc2VfLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIWNvcHlfLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBSRU1PVkUsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgb3A6IEFERCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH0pO1xuICAgIGkgPSAwO1xuICAgIGNvcHlfLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIWJhc2VfLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBBREQsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG4gICAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlVmFsdWUsIHJlcGxhY2VtZW50LCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcykge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogUkVQTEFDRSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgdmFsdWU6IHJlcGxhY2VtZW50ID09PSBOT1RISU5HID8gdm9pZCAwIDogcmVwbGFjZW1lbnRcbiAgICB9KTtcbiAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgcGF0aDogW10sXG4gICAgICB2YWx1ZTogYmFzZVZhbHVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlQYXRjaGVzXyhkcmFmdCwgcGF0Y2hlcykge1xuICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IHsgcGF0aCwgb3AgfSA9IHBhdGNoO1xuICAgICAgbGV0IGJhc2UgPSBkcmFmdDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyZW50VHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpO1xuICAgICAgICBsZXQgcCA9IHBhdGhbaV07XG4gICAgICAgIGlmICh0eXBlb2YgcCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHAgPSBcIlwiICsgcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHBhcmVudFR5cGUgPT09IDAgLyogT2JqZWN0ICovIHx8IHBhcmVudFR5cGUgPT09IDEgLyogQXJyYXkgKi8pICYmIChwID09PSBcIl9fcHJvdG9fX1wiIHx8IHAgPT09IFwiY29uc3RydWN0b3JcIikpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMyk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHAgPT09IFwicHJvdG90eXBlXCIpXG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMyk7XG4gICAgICAgIGJhc2UgPSBnZXQoYmFzZSwgcCk7XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAyLCBwYXRoLmpvaW4oXCIvXCIpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGVlcENsb25lUGF0Y2hWYWx1ZShwYXRjaC52YWx1ZSk7XG4gICAgICBjb25zdCBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgUkVQTEFDRTpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTZXQgKi86XG4gICAgICAgICAgICAgIGRpZShlcnJvck9mZnNldCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEFERDpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBBcnJheSAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gXCItXCIgPyBiYXNlLnB1c2godmFsdWUpIDogYmFzZS5zcGxpY2Uoa2V5LCAwLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBSRU1PVkU6XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNwbGljZShrZXksIDEpO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBjYXNlIDMgLyogU2V0ICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBiYXNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDEsIG9wKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZHJhZnQ7XG4gIH1cbiAgZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmopIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKG9iaikpXG4gICAgICByZXR1cm4gb2JqO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpXG4gICAgICByZXR1cm4gb2JqLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKTtcbiAgICBpZiAoaXNNYXAob2JqKSlcbiAgICAgIHJldHVybiBuZXcgTWFwKFxuICAgICAgICBBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpLm1hcCgoW2ssIHZdKSA9PiBbaywgZGVlcENsb25lUGF0Y2hWYWx1ZSh2KV0pXG4gICAgICApO1xuICAgIGlmIChpc1NldChvYmopKVxuICAgICAgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShvYmopLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKSk7XG4gICAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShnZXRQcm90b3R5cGVPZihvYmopKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopXG4gICAgICBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqW2tleV0pO1xuICAgIGlmIChoYXMob2JqLCBEUkFGVEFCTEUpKVxuICAgICAgY2xvbmVkW0RSQUZUQUJMRV0gPSBvYmpbRFJBRlRBQkxFXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGZ1bmN0aW9uIGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9iaikge1xuICAgIGlmIChpc0RyYWZ0KG9iaikpIHtcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaik7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gb2JqO1xuICB9XG4gIGxvYWRQbHVnaW4oXCJQYXRjaGVzXCIsIHtcbiAgICBhcHBseVBhdGNoZXNfLFxuICAgIGdlbmVyYXRlUGF0Y2hlc18sXG4gICAgZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfXG4gIH0pO1xufVxuXG4vLyBzcmMvcGx1Z2lucy9tYXBzZXQudHNcbmZ1bmN0aW9uIGVuYWJsZU1hcFNldCgpIHtcbiAgY2xhc3MgRHJhZnRNYXAgZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgcGFyZW50KSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpc1tEUkFGVF9TVEFURV0gPSB7XG4gICAgICAgIHR5cGVfOiAyIC8qIE1hcCAqLyxcbiAgICAgICAgcGFyZW50XzogcGFyZW50LFxuICAgICAgICBzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSxcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAgICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgICAgIGNvcHlfOiB2b2lkIDAsXG4gICAgICAgIGFzc2lnbmVkXzogdm9pZCAwLFxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxuICAgICAgICBkcmFmdF86IHRoaXMsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2UsXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5iYXNlXy5oYXMoa2V5KSkge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgc3RhdGUuY29weV8uZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGVhY2goc3RhdGUuYmFzZV8sIChrZXkpID0+IHtcbiAgICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaChjYiwgdGhpc0FyZykge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGxhdGVzdChzdGF0ZSkuZm9yRWFjaCgoX3ZhbHVlLCBrZXksIF9tYXApID0+IHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCB0aGlzLmdldChrZXkpLCBrZXksIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgY29uc3QgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpO1xuICAgICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IHN0YXRlLmJhc2VfLmdldChrZXkpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkodmFsdWUsIHN0YXRlKTtcbiAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcbiAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIGRyYWZ0KTtcbiAgICAgIHJldHVybiBkcmFmdDtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKTtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB0aGlzLnZhbHVlcygpLFxuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoci5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMuZW50cmllcygpLFxuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoci5kb25lKVxuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogW3IudmFsdWUsIHZhbHVlXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIFsoRFJBRlRfU1RBVEUsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm94eU1hcF8odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICByZXR1cm4gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KTtcbiAgfVxuICBmdW5jdGlvbiBwcmVwYXJlTWFwQ29weShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBzdGF0ZS5jb3B5XyA9IG5ldyBNYXAoc3RhdGUuYmFzZV8pO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEcmFmdFNldCBleHRlbmRzIFNldCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDMgLyogU2V0ICovLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHZvaWQgMCxcbiAgICAgICAgYmFzZV86IHRhcmdldCxcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxuICAgICAgICBkcmFmdHNfOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICByZXZva2VkXzogZmFsc2UsXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZTtcbiAgICB9XG4gICAgaGFzKHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuY29weV8pIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmJhc2VfLmhhcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuY29weV8uaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpICYmIHN0YXRlLmNvcHlfLmhhcyhzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XG4gICAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGV0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZGVsZXRlKHZhbHVlKSB8fCAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpID8gc3RhdGUuY29weV8uZGVsZXRlKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkgOiAoXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZhbHNlXG4gICAgICApKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLnZhbHVlcygpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8uZW50cmllcygpO1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfVxuICAgIFsoRFJBRlRfU1RBVEUsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG4gICAgfVxuICAgIGZvckVhY2goY2IsIHRoaXNBcmcpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy52YWx1ZXMoKTtcbiAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xuICAgIHJldHVybiBuZXcgRHJhZnRTZXQodGFyZ2V0LCBwYXJlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuY29weV8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgc3RhdGUuYmFzZV8uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkodmFsdWUsIHN0YXRlKTtcbiAgICAgICAgICBzdGF0ZS5kcmFmdHNfLnNldCh2YWx1ZSwgZHJhZnQpO1xuICAgICAgICAgIHN0YXRlLmNvcHlfLmFkZChkcmFmdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5yZXZva2VkXylcbiAgICAgIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XG4gIH1cbiAgbG9hZFBsdWdpbihcIk1hcFNldFwiLCB7IHByb3h5TWFwXywgcHJveHlTZXRfIH0pO1xufVxuXG4vLyBzcmMvaW1tZXIudHNcbnZhciBpbW1lciA9IG5ldyBJbW1lcjIoKTtcbnZhciBwcm9kdWNlID0gaW1tZXIucHJvZHVjZTtcbnZhciBwcm9kdWNlV2l0aFBhdGNoZXMgPSBpbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChcbiAgaW1tZXJcbik7XG52YXIgc2V0QXV0b0ZyZWV6ZSA9IGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcik7XG52YXIgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHkgPSBpbW1lci5zZXRVc2VTdHJpY3RTaGFsbG93Q29weS5iaW5kKGltbWVyKTtcbnZhciBhcHBseVBhdGNoZXMgPSBpbW1lci5hcHBseVBhdGNoZXMuYmluZChpbW1lcik7XG52YXIgY3JlYXRlRHJhZnQgPSBpbW1lci5jcmVhdGVEcmFmdC5iaW5kKGltbWVyKTtcbnZhciBmaW5pc2hEcmFmdCA9IGltbWVyLmZpbmlzaERyYWZ0LmJpbmQoaW1tZXIpO1xuZnVuY3Rpb24gY2FzdERyYWZ0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNhc3RJbW11dGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IHtcbiAgSW1tZXIyIGFzIEltbWVyLFxuICBhcHBseVBhdGNoZXMsXG4gIGNhc3REcmFmdCxcbiAgY2FzdEltbXV0YWJsZSxcbiAgY3JlYXRlRHJhZnQsXG4gIGN1cnJlbnQsXG4gIGVuYWJsZU1hcFNldCxcbiAgZW5hYmxlUGF0Y2hlcyxcbiAgZmluaXNoRHJhZnQsXG4gIGZyZWV6ZSxcbiAgRFJBRlRBQkxFIGFzIGltbWVyYWJsZSxcbiAgaXNEcmFmdCxcbiAgaXNEcmFmdGFibGUsXG4gIE5PVEhJTkcgYXMgbm90aGluZyxcbiAgb3JpZ2luYWwsXG4gIHByb2R1Y2UsXG4gIHByb2R1Y2VXaXRoUGF0Y2hlcyxcbiAgc2V0QXV0b0ZyZWV6ZSxcbiAgc2V0VXNlU3RyaWN0U2hhbGxvd0NvcHlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/immer/dist/immer.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./src/app/globals.css":
/*!*********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./src/app/globals.css ***!
  \*********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*! tailwindcss v4.0.9 | MIT License | https://tailwindcss.com */\\n@layer utilities {\\n  .visible {\\n    visibility: visible;\\n  }\\n  .absolute {\\n    position: absolute;\\n  }\\n  .relative {\\n    position: relative;\\n  }\\n  .static {\\n    position: static;\\n  }\\n  .sticky {\\n    position: sticky;\\n  }\\n  .container {\\n    width: 100%;\\n  }\\n  .block {\\n    display: block;\\n  }\\n  .contents {\\n    display: contents;\\n  }\\n  .flex {\\n    display: flex;\\n  }\\n  .grid {\\n    display: grid;\\n  }\\n  .hidden {\\n    display: none;\\n  }\\n  .table {\\n    display: table;\\n  }\\n  .transform {\\n    transform: var(--tw-rotate-x) var(--tw-rotate-y) var(--tw-rotate-z) var(--tw-skew-x) var(--tw-skew-y);\\n  }\\n  .border {\\n    border-style: var(--tw-border-style);\\n    border-width: 1px;\\n  }\\n  .filter {\\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\\n  }\\n}\\n:root {\\n  --background: #ffffff;\\n  --foreground: #171717;\\n}\\nbody {\\n  color: var(--foreground);\\n  background: var(--background);\\n  font-family: 'メイリオ',\\r\\n  'Hiragino Kaku Gothic Pro', \\r\\n  -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\\r\\n   Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue,\\r\\n   Arial, Helvetica, sans-serif;\\n}\\n@property --tw-rotate-x {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: rotateX(0);\\n}\\n@property --tw-rotate-y {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: rotateY(0);\\n}\\n@property --tw-rotate-z {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: rotateZ(0);\\n}\\n@property --tw-skew-x {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: skewX(0);\\n}\\n@property --tw-skew-y {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: skewY(0);\\n}\\n@property --tw-border-style {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n  initial-value: solid;\\n}\\n@property --tw-blur {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-brightness {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-contrast {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-grayscale {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-hue-rotate {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-invert {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-opacity {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-saturate {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-sepia {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\n@property --tw-drop-shadow {\\n  syntax: \\\"*\\\";\\n  inherits: false;\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/app/globals.css\"],\"names\":[],\"mappings\":\"AAAA,gEA6BA;AA7BA;EAAA;IAAA,mBA6BA;EAAA;EA7BA;IAAA,kBA6BA;EAAA;EA7BA;IAAA,kBA6BA;EAAA;EA7BA;IAAA,gBA6BA;EAAA;EA7BA;IAAA,gBA6BA;EAAA;EA7BA;IAAA,WA6BA;EAAA;EA7BA;IAAA,cA6BA;EAAA;EA7BA;IAAA,iBA6BA;EAAA;EA7BA;IAAA,aA6BA;EAAA;EA7BA;IAAA,aA6BA;EAAA;EA7BA;IAAA,aA6BA;EAAA;EA7BA;IAAA,cA6BA;EAAA;EA7BA;IAAA,qGA6BA;EAAA;EA7BA;IAAA,oCA6BA;IA7BA,iBA6BA;EAAA;EA7BA;IAAA,0LA6BA;EAAA;AAAA;AA7BA;EAAA,qBA6BA;EA7BA,qBA6BA;AAAA;AA7BA;EAAA,wBA6BA;EA7BA,6BA6BA;EA7BA;;;;+BA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;EA7BA,yBA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;EA7BA,yBA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;EA7BA,yBA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;EA7BA,uBA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;EA7BA,uBA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;EA7BA,oBA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA;AA7BA;EAAA,WA6BA;EA7BA,eA6BA;AAAA\",\"sourcesContent\":[\"/* @tailwind base; */\\r\\n@import 'tailwindcss/utilities' layer(utilities);\\r\\n\\r\\n@theme {\\r\\n  --color-background: var(--background);\\r\\n  --color-foreground: var(--foreground);\\r\\n}\\r\\n\\r\\n:root {\\r\\n  --background: #ffffff;\\r\\n  --foreground: #171717;\\r\\n}\\r\\n/* \\r\\n@media (prefers-color-scheme: dark) {\\r\\n  :root {\\r\\n    --background: #0a0a0a;\\r\\n    --foreground: #ededed;\\r\\n  }\\r\\n} */\\r\\n\\r\\nbody {\\r\\n  color: var(--foreground);\\r\\n  background: var(--background);\\r\\n  font-family:  'メイリオ',\\r\\n  'Hiragino Kaku Gothic Pro', \\r\\n  -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\\r\\n   Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue,\\r\\n   Arial, Helvetica, sans-serif;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxM10ub25lT2ZbMTJdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTNdLm9uZU9mWzEyXS51c2VbMl0hLi9zcmMvYXBwL2dsb2JhbHMuY3NzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ2lJO0FBQ2pJLDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSwrSEFBK0gsY0FBYywwQkFBMEIsS0FBSyxlQUFlLHlCQUF5QixLQUFLLGVBQWUseUJBQXlCLEtBQUssYUFBYSx1QkFBdUIsS0FBSyxhQUFhLHVCQUF1QixLQUFLLGdCQUFnQixrQkFBa0IsS0FBSyxZQUFZLHFCQUFxQixLQUFLLGVBQWUsd0JBQXdCLEtBQUssV0FBVyxvQkFBb0IsS0FBSyxXQUFXLG9CQUFvQixLQUFLLGFBQWEsb0JBQW9CLEtBQUssWUFBWSxxQkFBcUIsS0FBSyxnQkFBZ0IsNEdBQTRHLEtBQUssYUFBYSwyQ0FBMkMsd0JBQXdCLEtBQUssYUFBYSxpTUFBaU0sS0FBSyxHQUFHLFNBQVMsMEJBQTBCLDBCQUEwQixHQUFHLFFBQVEsNkJBQTZCLGtDQUFrQyxnT0FBZ08sR0FBRywyQkFBMkIsa0JBQWtCLG9CQUFvQiw4QkFBOEIsR0FBRywyQkFBMkIsa0JBQWtCLG9CQUFvQiw4QkFBOEIsR0FBRywyQkFBMkIsa0JBQWtCLG9CQUFvQiw4QkFBOEIsR0FBRyx5QkFBeUIsa0JBQWtCLG9CQUFvQiw0QkFBNEIsR0FBRyx5QkFBeUIsa0JBQWtCLG9CQUFvQiw0QkFBNEIsR0FBRywrQkFBK0Isa0JBQWtCLG9CQUFvQix5QkFBeUIsR0FBRyx1QkFBdUIsa0JBQWtCLG9CQUFvQixHQUFHLDZCQUE2QixrQkFBa0Isb0JBQW9CLEdBQUcsMkJBQTJCLGtCQUFrQixvQkFBb0IsR0FBRyw0QkFBNEIsa0JBQWtCLG9CQUFvQixHQUFHLDZCQUE2QixrQkFBa0Isb0JBQW9CLEdBQUcseUJBQXlCLGtCQUFrQixvQkFBb0IsR0FBRywwQkFBMEIsa0JBQWtCLG9CQUFvQixHQUFHLDJCQUEyQixrQkFBa0Isb0JBQW9CLEdBQUcsd0JBQXdCLGtCQUFrQixvQkFBb0IsR0FBRyw4QkFBOEIsa0JBQWtCLG9CQUFvQixHQUFHLFdBQVcsMkZBQTJGLE1BQU0sS0FBSyxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksS0FBSyxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsU0FBUyxPQUFPLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksNENBQTRDLHVEQUF1RCxnQkFBZ0IsNENBQTRDLDRDQUE0QyxLQUFLLGVBQWUsNEJBQTRCLDRCQUE0QixLQUFLLGdEQUFnRCxhQUFhLDhCQUE4Qiw4QkFBOEIsT0FBTyxNQUFNLGdCQUFnQiwrQkFBK0Isb0NBQW9DLG1PQUFtTyxLQUFLLHVCQUF1QjtBQUN6K0k7QUFDQSxpRUFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcYXBwc1xcd2ViXFxzcmNcXGFwcFxcZ2xvYmFscy5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qISB0YWlsd2luZGNzcyB2NC4wLjkgfCBNSVQgTGljZW5zZSB8IGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tICovXFxuQGxheWVyIHV0aWxpdGllcyB7XFxuICAudmlzaWJsZSB7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICB9XFxuICAuYWJzb2x1dGUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB9XFxuICAucmVsYXRpdmUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB9XFxuICAuc3RhdGljIHtcXG4gICAgcG9zaXRpb246IHN0YXRpYztcXG4gIH1cXG4gIC5zdGlja3kge1xcbiAgICBwb3NpdGlvbjogc3RpY2t5O1xcbiAgfVxcbiAgLmNvbnRhaW5lciB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgfVxcbiAgLmJsb2NrIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuICAuY29udGVudHMge1xcbiAgICBkaXNwbGF5OiBjb250ZW50cztcXG4gIH1cXG4gIC5mbGV4IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gIH1cXG4gIC5ncmlkIHtcXG4gICAgZGlzcGxheTogZ3JpZDtcXG4gIH1cXG4gIC5oaWRkZW4ge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcbiAgLnRhYmxlIHtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICB9XFxuICAudHJhbnNmb3JtIHtcXG4gICAgdHJhbnNmb3JtOiB2YXIoLS10dy1yb3RhdGUteCkgdmFyKC0tdHctcm90YXRlLXkpIHZhcigtLXR3LXJvdGF0ZS16KSB2YXIoLS10dy1za2V3LXgpIHZhcigtLXR3LXNrZXcteSk7XFxuICB9XFxuICAuYm9yZGVyIHtcXG4gICAgYm9yZGVyLXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpO1xcbiAgICBib3JkZXItd2lkdGg6IDFweDtcXG4gIH1cXG4gIC5maWx0ZXIge1xcbiAgICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIsKSB2YXIoLS10dy1icmlnaHRuZXNzLCkgdmFyKC0tdHctY29udHJhc3QsKSB2YXIoLS10dy1ncmF5c2NhbGUsKSB2YXIoLS10dy1odWUtcm90YXRlLCkgdmFyKC0tdHctaW52ZXJ0LCkgdmFyKC0tdHctc2F0dXJhdGUsKSB2YXIoLS10dy1zZXBpYSwpIHZhcigtLXR3LWRyb3Atc2hhZG93LCk7XFxuICB9XFxufVxcbjpyb290IHtcXG4gIC0tYmFja2dyb3VuZDogI2ZmZmZmZjtcXG4gIC0tZm9yZWdyb3VuZDogIzE3MTcxNztcXG59XFxuYm9keSB7XFxuICBjb2xvcjogdmFyKC0tZm9yZWdyb3VuZCk7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrZ3JvdW5kKTtcXG4gIGZvbnQtZmFtaWx5OiAn44Oh44Kk44Oq44KqJyxcXHJcXG4gICdIaXJhZ2lubyBLYWt1IEdvdGhpYyBQcm8nLCBcXHJcXG4gIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgU2Vnb2UgVUksIFJvYm90bywgT3h5Z2VuLFxcclxcbiAgIFVidW50dSwgQ2FudGFyZWxsLCBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLFxcclxcbiAgIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXJvdGF0ZS14IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogcm90YXRlWCgwKTtcXG59XFxuQHByb3BlcnR5IC0tdHctcm90YXRlLXkge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiByb3RhdGVZKDApO1xcbn1cXG5AcHJvcGVydHkgLS10dy1yb3RhdGUteiB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IHJvdGF0ZVooMCk7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXNrZXcteCB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG4gIGluaXRpYWwtdmFsdWU6IHNrZXdYKDApO1xcbn1cXG5AcHJvcGVydHkgLS10dy1za2V3LXkge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxuICBpbml0aWFsLXZhbHVlOiBza2V3WSgwKTtcXG59XFxuQHByb3BlcnR5IC0tdHctYm9yZGVyLXN0eWxlIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbiAgaW5pdGlhbC12YWx1ZTogc29saWQ7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWJsdXIge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWJyaWdodG5lc3Mge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWNvbnRyYXN0IHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1ncmF5c2NhbGUge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWh1ZS1yb3RhdGUge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LWludmVydCB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctb3BhY2l0eSB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxuQHByb3BlcnR5IC0tdHctc2F0dXJhdGUge1xcbiAgc3ludGF4OiBcXFwiKlxcXCI7XFxuICBpbmhlcml0czogZmFsc2U7XFxufVxcbkBwcm9wZXJ0eSAtLXR3LXNlcGlhIHtcXG4gIHN5bnRheDogXFxcIipcXFwiO1xcbiAgaW5oZXJpdHM6IGZhbHNlO1xcbn1cXG5AcHJvcGVydHkgLS10dy1kcm9wLXNoYWRvdyB7XFxuICBzeW50YXg6IFxcXCIqXFxcIjtcXG4gIGluaGVyaXRzOiBmYWxzZTtcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3NyYy9hcHAvZ2xvYmFscy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsZ0VBNkJBO0FBN0JBO0VBQUE7SUFBQSxtQkE2QkE7RUFBQTtFQTdCQTtJQUFBLGtCQTZCQTtFQUFBO0VBN0JBO0lBQUEsa0JBNkJBO0VBQUE7RUE3QkE7SUFBQSxnQkE2QkE7RUFBQTtFQTdCQTtJQUFBLGdCQTZCQTtFQUFBO0VBN0JBO0lBQUEsV0E2QkE7RUFBQTtFQTdCQTtJQUFBLGNBNkJBO0VBQUE7RUE3QkE7SUFBQSxpQkE2QkE7RUFBQTtFQTdCQTtJQUFBLGFBNkJBO0VBQUE7RUE3QkE7SUFBQSxhQTZCQTtFQUFBO0VBN0JBO0lBQUEsYUE2QkE7RUFBQTtFQTdCQTtJQUFBLGNBNkJBO0VBQUE7RUE3QkE7SUFBQSxxR0E2QkE7RUFBQTtFQTdCQTtJQUFBLG9DQTZCQTtJQTdCQSxpQkE2QkE7RUFBQTtFQTdCQTtJQUFBLDBMQTZCQTtFQUFBO0FBQUE7QUE3QkE7RUFBQSxxQkE2QkE7RUE3QkEscUJBNkJBO0FBQUE7QUE3QkE7RUFBQSx3QkE2QkE7RUE3QkEsNkJBNkJBO0VBN0JBOzs7OytCQTZCQTtBQUFBO0FBN0JBO0VBQUEsV0E2QkE7RUE3QkEsZUE2QkE7RUE3QkEseUJBNkJBO0FBQUE7QUE3QkE7RUFBQSxXQTZCQTtFQTdCQSxlQTZCQTtFQTdCQSx5QkE2QkE7QUFBQTtBQTdCQTtFQUFBLFdBNkJBO0VBN0JBLGVBNkJBO0VBN0JBLHlCQTZCQTtBQUFBO0FBN0JBO0VBQUEsV0E2QkE7RUE3QkEsZUE2QkE7RUE3QkEsdUJBNkJBO0FBQUE7QUE3QkE7RUFBQSxXQTZCQTtFQTdCQSxlQTZCQTtFQTdCQSx1QkE2QkE7QUFBQTtBQTdCQTtFQUFBLFdBNkJBO0VBN0JBLGVBNkJBO0VBN0JBLG9CQTZCQTtBQUFBO0FBN0JBO0VBQUEsV0E2QkE7RUE3QkEsZUE2QkE7QUFBQTtBQTdCQTtFQUFBLFdBNkJBO0VBN0JBLGVBNkJBO0FBQUE7QUE3QkE7RUFBQSxXQTZCQTtFQTdCQSxlQTZCQTtBQUFBO0FBN0JBO0VBQUEsV0E2QkE7RUE3QkEsZUE2QkE7QUFBQTtBQTdCQTtFQUFBLFdBNkJBO0VBN0JBLGVBNkJBO0FBQUE7QUE3QkE7RUFBQSxXQTZCQTtFQTdCQSxlQTZCQTtBQUFBO0FBN0JBO0VBQUEsV0E2QkE7RUE3QkEsZUE2QkE7QUFBQTtBQTdCQTtFQUFBLFdBNkJBO0VBN0JBLGVBNkJBO0FBQUE7QUE3QkE7RUFBQSxXQTZCQTtFQTdCQSxlQTZCQTtBQUFBO0FBN0JBO0VBQUEsV0E2QkE7RUE3QkEsZUE2QkE7QUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBAdGFpbHdpbmQgYmFzZTsgKi9cXHJcXG5AaW1wb3J0ICd0YWlsd2luZGNzcy91dGlsaXRpZXMnIGxheWVyKHV0aWxpdGllcyk7XFxyXFxuXFxyXFxuQHRoZW1lIHtcXHJcXG4gIC0tY29sb3ItYmFja2dyb3VuZDogdmFyKC0tYmFja2dyb3VuZCk7XFxyXFxuICAtLWNvbG9yLWZvcmVncm91bmQ6IHZhcigtLWZvcmVncm91bmQpO1xcclxcbn1cXHJcXG5cXHJcXG46cm9vdCB7XFxyXFxuICAtLWJhY2tncm91bmQ6ICNmZmZmZmY7XFxyXFxuICAtLWZvcmVncm91bmQ6ICMxNzE3MTc7XFxyXFxufVxcclxcbi8qIFxcclxcbkBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtcXHJcXG4gIDpyb290IHtcXHJcXG4gICAgLS1iYWNrZ3JvdW5kOiAjMGEwYTBhO1xcclxcbiAgICAtLWZvcmVncm91bmQ6ICNlZGVkZWQ7XFxyXFxuICB9XFxyXFxufSAqL1xcclxcblxcclxcbmJvZHkge1xcclxcbiAgY29sb3I6IHZhcigtLWZvcmVncm91bmQpO1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tYmFja2dyb3VuZCk7XFxyXFxuICBmb250LWZhbWlseTogICfjg6HjgqTjg6rjgqonLFxcclxcbiAgJ0hpcmFnaW5vIEtha3UgR290aGljIFBybycsIFxcclxcbiAgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sXFxyXFxuICAgVWJ1bnR1LCBDYW50YXJlbGwsIEZpcmEgU2FucywgRHJvaWQgU2FucywgSGVsdmV0aWNhIE5ldWUsXFxyXFxuICAgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./src/app/globals.css\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return '@media '.concat(item[2], ' {').concat(content, '}');\n            }\n            return content;\n        }).join('');\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === 'string') {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    ''\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = ''.concat(mediaQuery, ' and ').concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || '' // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return '/*# sourceURL='.concat(cssMapping.sourceRoot || '').concat(source, ' */');\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join('\\n');\n    }\n    return [\n        content\n    ].join('\\n');\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(base64);\n    return '/*# '.concat(data, ' */');\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcYnVpbGRcXHdlYnBhY2tcXGxvYWRlcnNcXGNzcy1sb2FkZXJcXHNyY1xccnVudGltZVxcYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuICAgIHZhciBsaXN0ID0gW10gLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICAgIDtcbiAgICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcbiAgICAgICAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdAbWVkaWEgJy5jb25jYXQoaXRlbVsyXSwgJyB7JykuY29uY2F0KGNvbnRlbnQsICd9Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBtb2R1bGVzID0gW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuICAgICAgICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gJycuY29uY2F0KG1lZGlhUXVlcnksICcgYW5kICcpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBsaXN0O1xufTtcbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIDtcbiAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gICAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiAnLyojIHNvdXJjZVVSTD0nLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsICcgKi8nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXG4gICAgICAgIF0pLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBjb250ZW50XG4gICAgXS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICAgIHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuICcvKiMgJy5jb25jYXQoZGF0YSwgJyAqLycpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \***********************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"(pages-dir-browser)/./pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1wcml2YXRlLW5leHQtcGFnZXMlMkZfYXBwJnBhZ2U9JTJGX2FwcCEiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxxRUFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvX2FwcFwiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcInByaXZhdGUtbmV4dC1wYWdlcy9fYXBwXCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9fYXBwXCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === 'undefined') {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === 'undefined') {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + ' ' + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement('style');\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === 'undefined') {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === 'function') {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || 'head');\n        if (!target) {\n            throw Object.defineProperty(new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\"), \"__NEXT_ERROR_CODE\", {\n                value: \"E245\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join('\\n');\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? '' : obj.media ? '@media ' + obj.media + ' {' + obj.css + '}' : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute('media', media);\n    } else {\n        style.removeAttribute('media');\n    }\n    if (sourceMap && typeof btoa !== 'undefined') {\n        css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */';\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== 'boolean') {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== '[object Array]') {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxidWlsZFxcd2VicGFja1xcbG9hZGVyc1xcbmV4dC1zdHlsZS1sb2FkZXJcXHJ1bnRpbWVcXGluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICAgIGxldCBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICAgICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbn0oKTtcbmNvbnN0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICAgIH07XG59KCk7XG5jb25zdCBzdHlsZXNJbkRvbSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIGxldCByZXN1bHQgPSAtMTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlkQ291bnRNYXAgPSB7fTtcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgICAgIGNvbnN0IGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGlkICsgJyAnICsgY291bnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgICAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiRTI0NVwiLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqLyBjb25zdCByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICAgIH07XG59KCk7XG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgICBjb25zdCBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/ICdAbWVkaWEgJyArIG9iai5tZWRpYSArICcgeycgKyBvYmouY3NzICsgJ30nIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgX29wdGlvbnMsIG9iaikge1xuICAgIGxldCBjc3MgPSBvYmouY3NzO1xuICAgIGNvbnN0IG1lZGlhID0gb2JqLm1lZGlhO1xuICAgIGNvbnN0IHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICAgIH1cbiAgICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJztcbiAgICB9XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgfVxufVxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5sZXQgc2luZ2xldG9uQ291bnRlciA9IDA7XG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgICBsZXQgc3R5bGU7XG4gICAgbGV0IHVwZGF0ZTtcbiAgICBsZXQgcmVtb3ZlO1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgICAgICBjb25zdCBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgICAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlKG9iaik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgICAgICBpZiAobmV3T2JqKSB7XG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG4gICAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgICB9XG4gICAgbGlzdCA9IGxpc3QgfHwgW107XG4gICAgbGV0IGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICAgICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/react-redux/dist/react-redux.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/react-redux/dist/react-redux.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/../../node_modules/react/index.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(pages-dir-browser)/../../node_modules/use-sync-external-store/with-selector.js\");\n// src/utils/react.ts\n\n\n// src/utils/react-is.ts\nvar IS_REACT_19 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.version.startsWith(\"19\");\nvar REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for(\n  IS_REACT_19 ? \"react.transitional.element\" : \"react.element\"\n);\nvar REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for(\"react.profiler\");\nvar REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for(\"react.consumer\");\nvar REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for(\"react.context\");\nvar REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for(\n  \"react.suspense_list\"\n);\nvar REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = /* @__PURE__ */ Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for(\n  \"react.client.reference\"\n);\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n  return typeof type === \"string\" || typeof type === \"function\" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) ? true : false;\n}\nfunction typeOf(object) {\n  if (typeof object === \"object\" && object !== null) {\n    const { $$typeof } = object;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        switch (object = object.type, object) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return object;\n          default:\n            switch (object = object && object.$$typeof, object) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n                return object;\n              case REACT_CONSUMER_TYPE:\n                return object;\n              default:\n                return $$typeof;\n            }\n        }\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n}\nfunction isContextConsumer(object) {\n  return IS_REACT_19 ? typeOf(object) === REACT_CONSUMER_TYPE : typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {\n  }\n}\n\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\n  } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n    if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n      warning(\n        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`\n      );\n    }\n  }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, \"mapStateToProps\");\n  verify(mapDispatchToProps, \"mapDispatchToProps\");\n  verify(mergeProps, \"mergeProps\");\n}\n\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\n  areStatesEqual,\n  areOwnPropsEqual,\n  areStatePropsEqual\n}) {\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps)\n      stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps)\n      dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged)\n      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(\n      nextState,\n      state,\n      nextOwnProps,\n      ownProps\n    );\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\nfunction finalPropsSelectorFactory(dispatch, {\n  initMapStateToProps,\n  initMapDispatchToProps,\n  initMergeProps,\n  ...options\n}) {\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n  if (true) {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n  const boundActionCreators = {};\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));\n    }\n  }\n  return boundActionCreators;\n}\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null) return false;\n  const proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  let baseProto = proto;\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n  return proto === baseProto;\n}\n\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(\n      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`\n    );\n  }\n}\n\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n    function constantSelector() {\n      return constant;\n    }\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, { displayName }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n    };\n    proxy.dependsOnOwnProps = true;\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n      if (typeof props === \"function\") {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n      if (true)\n        verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n    return proxy;\n  };\n}\n\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n  return (dispatch, options) => {\n    throw new Error(\n      `Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`\n    );\n  };\n}\n\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant(\n    (dispatch) => (\n      // @ts-ignore\n      bindActionCreators(mapDispatchToProps, dispatch)\n    )\n  ) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch) => ({\n    dispatch\n  })) : typeof mapDispatchToProps === \"function\" ? (\n    // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\")\n  ) : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === \"function\" ? (\n    // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\")\n  ) : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  return { ...ownProps, ...stateProps, ...dispatchProps };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps))\n          mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (true)\n          verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n      }\n      return mergedProps;\n    };\n  };\n}\nfunction mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n    notify() {\n      defaultNoopBatch(() => {\n        let listener = first;\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n    get() {\n      const listeners = [];\n      let listener = first;\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n      return listeners;\n    },\n    subscribe(callback) {\n      let isSubscribed = true;\n      const listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n  };\n}\nvar nullListeners = {\n  notify() {\n  },\n  get: () => []\n};\nfunction createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners;\n  let subscriptionsAmount = 0;\n  let selfSubscribed = false;\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener);\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n  function trySubscribe() {\n    subscriptionsAmount++;\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = void 0;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n}\n\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = () => !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nvar isDOM = /* @__PURE__ */ canUseDOM();\nvar isRunningInReactNative = () => typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\";\nvar isReactNative = /* @__PURE__ */ isRunningInReactNative();\nvar getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();\n\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextType: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromError: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar FORWARD_REF_STATICS = {\n  $$typeof: true,\n  render: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true\n};\nvar MEMO_STATICS = {\n  $$typeof: true,\n  compare: true,\n  defaultProps: true,\n  displayName: true,\n  propTypes: true,\n  type: true\n};\nvar TYPE_STATICS = {\n  [ForwardRef]: FORWARD_REF_STATICS,\n  [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n  if (isMemo(component)) {\n    return MEMO_STATICS;\n  }\n  return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n  if (typeof sourceComponent !== \"string\") {\n    if (objectPrototype) {\n      const inheritedComponent = getPrototypeOf(sourceComponent);\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent);\n      }\n    }\n    let keys = getOwnPropertyNames(sourceComponent);\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n    const targetStatics = getStatics(targetComponent);\n    const sourceStatics = getStatics(sourceComponent);\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n        const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n        try {\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {\n        }\n      }\n    }\n  }\n  return targetComponent;\n}\n\n// src/components/Context.ts\nvar ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : (\n  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n  {}\n);\nfunction getContext() {\n  if (!react__WEBPACK_IMPORTED_MODULE_0__.createContext) return {};\n  const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();\n  let realContext = contextMap.get(react__WEBPACK_IMPORTED_MODULE_0__.createContext);\n  if (!realContext) {\n    realContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(\n      null\n    );\n    if (true) {\n      realContext.displayName = \"ReactRedux\";\n    }\n    contextMap.set(react__WEBPACK_IMPORTED_MODULE_0__.createContext, realContext);\n  }\n  return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n\n// src/components/connect.tsx\nvar NO_SUBSCRIPTION_ARRAY = [null, null];\nvar stringifyComponent = (Comp) => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false;\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n  if (!shouldHandleStateChanges) return () => {\n  };\n  let didUnsubscribe = false;\n  let lastThrownError = null;\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      return;\n    }\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n    try {\n      newChildProps = childPropsSelector(\n        latestStoreState,\n        lastWrapperProps.current\n      );\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n    if (!error) {\n      lastThrownError = null;\n    }\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true;\n      additionalSubscribeListener();\n    }\n  };\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe();\n  checkForUpdates();\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n    if (lastThrownError) {\n      throw lastThrownError;\n    }\n  };\n  return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n  return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\n  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n  // @ts-ignore\n  pure,\n  areStatesEqual = strictEqual,\n  areOwnPropsEqual = shallowEqual,\n  areStatePropsEqual = shallowEqual,\n  areMergedPropsEqual = shallowEqual,\n  // use React's forwardRef to expose a ref of the wrapped component\n  forwardRef = false,\n  // the context consumer to use\n  context = ReactReduxContext\n} = {}) {\n  if (true) {\n    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning(\n        'The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component'\n      );\n    }\n  }\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n  const wrapWithConnect = (WrappedComponent) => {\n    if (true) {\n      const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n      if (!isValid)\n        throw new Error(\n          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(\n            WrappedComponent\n          )}`\n        );\n    }\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n        return [props.context, reactReduxForwardedRef2, wrapperProps2];\n      }, [props]);\n      const ContextToUse = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        let ResultContext = Context;\n        if (propsContext?.Consumer) {\n          if (true) {\n            const isValid = /* @__PURE__ */ isContextConsumer(\n              // @ts-ignore\n              /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(propsContext.Consumer, null)\n            );\n            if (!isValid) {\n              throw new Error(\n                \"You must pass a valid React context consumer as `props.context`\"\n              );\n            }\n            ResultContext = propsContext;\n          }\n        }\n        return ResultContext;\n      }, [propsContext, Context]);\n      const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ContextToUse);\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(\n          `Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`\n        );\n      }\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n        const subscription2 = createSubscription(\n          store,\n          didStoreComeFromProps ? void 0 : contextValue.subscription\n        );\n        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n        return [subscription2, notifyNestedSubs2];\n      }, [store, didStoreComeFromProps, contextValue]);\n      const overriddenContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (didStoreComeFromProps) {\n          return contextValue;\n        }\n        return {\n          ...contextValue,\n          subscription\n        };\n      }, [didStoreComeFromProps, contextValue, subscription]);\n      const lastChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n      const lastWrapperProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(wrapperProps);\n      const childPropsFromStoreUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n      const renderIsScheduled = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n      const isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n      const latestSubscriptionCallbackError = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\n        void 0\n      );\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        const selector = () => {\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          }\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n        return selector;\n      }, [store, wrapperProps]);\n      const subscribeForReact = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        const subscribe = (reactListener) => {\n          if (!subscription) {\n            return () => {\n            };\n          }\n          return subscribeUpdates(\n            shouldHandleStateChanges,\n            store,\n            subscription,\n            // @ts-ignore\n            childPropsSelector,\n            lastWrapperProps,\n            lastChildProps,\n            renderIsScheduled,\n            isMounted,\n            childPropsFromStoreUpdate,\n            notifyNestedSubs,\n            reactListener\n          );\n        };\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n        lastWrapperProps,\n        lastChildProps,\n        renderIsScheduled,\n        wrapperProps,\n        childPropsFromStoreUpdate,\n        notifyNestedSubs\n      ]);\n      let actualChildProps;\n      try {\n        actualChildProps = react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore(\n          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n          subscribeForReact,\n          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n          actualChildPropsSelector,\n          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector\n        );\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n        }\n        throw err;\n      }\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = void 0;\n        childPropsFromStoreUpdate.current = void 0;\n        lastChildProps.current = actualChildProps;\n      });\n      const renderedWrappedComponent = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return (\n          // @ts-ignore\n          /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n            WrappedComponent,\n            {\n              ...actualChildProps,\n              ref: reactReduxForwardedRef\n            }\n          )\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);\n      const renderedChild = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);\n        }\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n    const _Connect = react__WEBPACK_IMPORTED_MODULE_0__.memo(ConnectFunction);\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n    if (forwardRef) {\n      const _forwarded = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n        function forwardConnectRef(props, ref) {\n          return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Connect, { ...props, reactReduxForwardedRef: ref });\n        }\n      );\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n    }\n    return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n  };\n  return wrapWithConnect;\n}\nvar connect_default = connect;\n\n// src/components/Provider.tsx\nfunction Provider(providerProps) {\n  const { children, context, serverState, store } = providerProps;\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const subscription = createSubscription(store);\n    const baseContextValue = {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : void 0\n    };\n    if (false) {} else {\n      const { identityFunctionCheck = \"once\", stabilityCheck = \"once\" } = providerProps;\n      return /* @__PURE__ */ Object.assign(baseContextValue, {\n        stabilityCheck,\n        identityFunctionCheck\n      });\n    }\n  }, [store, serverState]);\n  const previousState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect(() => {\n    const { subscription } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = void 0;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || ReactReduxContext;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, { value: contextValue }, children);\n}\nvar Provider_default = Provider;\n\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext2() {\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if ( true && !contextValue) {\n      throw new Error(\n        \"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\"\n      );\n    }\n    return contextValue;\n  };\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (\n    // @ts-ignore\n    createReduxContextHook(context)\n  );\n  const useStore2 = () => {\n    const { store } = useReduxContext2();\n    return store;\n  };\n  Object.assign(useStore2, {\n    withTypes: () => useStore2\n  });\n  return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n  const useDispatch2 = () => {\n    const store = useStore2();\n    return store.dispatch;\n  };\n  Object.assign(useDispatch2, {\n    withTypes: () => useDispatch2\n  });\n  return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n\n// src/hooks/useSelector.ts\n\nvar refEquality = (a, b) => a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n  const useSelector2 = (selector, equalityFnOrOptions = {}) => {\n    const { equalityFn = refEquality } = typeof equalityFnOrOptions === \"function\" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;\n    if (true) {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`);\n      }\n      if (typeof selector !== \"function\") {\n        throw new Error(`You must pass a function as a selector to useSelector`);\n      }\n      if (typeof equalityFn !== \"function\") {\n        throw new Error(\n          `You must pass a function as an equality function to useSelector`\n        );\n      }\n    }\n    const reduxContext = useReduxContext2();\n    const { store, subscription, getServerState } = reduxContext;\n    const firstRun = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const wrappedSelector = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(\n      {\n        [selector.name](state) {\n          const selected = selector(state);\n          if (true) {\n            const { devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {} : equalityFnOrOptions;\n            const { identityFunctionCheck, stabilityCheck } = reduxContext;\n            const {\n              identityFunctionCheck: finalIdentityFunctionCheck,\n              stabilityCheck: finalStabilityCheck\n            } = {\n              stabilityCheck,\n              identityFunctionCheck,\n              ...devModeChecks\n            };\n            if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n              const toCompare = selector(state);\n              if (!equalityFn(selected, toCompare)) {\n                let stack = void 0;\n                try {\n                  throw new Error();\n                } catch (e) {\n                  ;\n                  ({ stack } = e);\n                }\n                console.warn(\n                  \"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\",\n                  {\n                    state,\n                    selected,\n                    selected2: toCompare,\n                    stack\n                  }\n                );\n              }\n            }\n            if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n              if (selected === state) {\n                let stack = void 0;\n                try {\n                  throw new Error();\n                } catch (e) {\n                  ;\n                  ({ stack } = e);\n                }\n                console.warn(\n                  \"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\",\n                  { stack }\n                );\n              }\n            }\n            if (firstRun.current) firstRun.current = false;\n          }\n          return selected;\n        }\n      }[selector.name],\n      [selector]\n    );\n    const selectedState = (0,use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector)(\n      subscription.addNestedSub,\n      store.getState,\n      getServerState || store.getState,\n      wrappedSelector,\n      equalityFn\n    );\n    react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue(selectedState);\n    return selectedState;\n  };\n  Object.assign(useSelector2, {\n    withTypes: () => useSelector2\n  });\n  return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n\n// src/exports.ts\nvar batch = defaultNoopBatch;\n\n//# sourceMappingURL=react-redux.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQytCOztBQUUvQjtBQUNBLGtDQUFrQywwQ0FBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXLFFBQVEsYUFBYSwrQ0FBK0MsTUFBTTtBQUM5RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZLE1BQU0sTUFBTSxxQ0FBcUMsNkJBQTZCO0FBQ3pIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxrREFBa0Qsa0NBQWtDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGtEQUFxQixHQUFHLDRDQUFlO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0RBQW1CO0FBQzFCO0FBQ0EsbUNBQW1DLGdEQUFtQjtBQUN0RDtBQUNBLGtCQUFrQixnREFBbUI7QUFDckM7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBLG1CQUFtQixnREFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSwwQ0FBYTtBQUNoRixnQkFBZ0Isb0VBQW9FO0FBQ3BGO0FBQ0EsT0FBTztBQUNQLDJCQUEyQiwwQ0FBYTtBQUN4QztBQUNBO0FBQ0EsY0FBYyxJQUFxQztBQUNuRDtBQUNBO0FBQ0EsOEJBQThCLGdEQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQkFBMkIsNkNBQWdCO0FBQzNDO0FBQ0E7QUFDQSxVQUFVLEtBQXFDO0FBQy9DO0FBQ0EsdURBQXVELFlBQVksMkpBQTJKLGFBQWE7QUFDM087QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQWE7QUFDOUM7QUFDQSxPQUFPO0FBQ1AsK0NBQStDLDBDQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHFDQUFxQywwQ0FBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw2QkFBNkIseUNBQVk7QUFDekMsK0JBQStCLHlDQUFZO0FBQzNDLHdDQUF3Qyx5Q0FBWTtBQUNwRCxnQ0FBZ0MseUNBQVk7QUFDNUMsd0JBQXdCLHlDQUFZO0FBQ3BDLDhDQUE4Qyx5Q0FBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1Q0FBdUMsMENBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDLDBDQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUNBQXVDLDBDQUFhO0FBQ3BEO0FBQ0E7QUFDQSwwQkFBMEIsZ0RBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDRCQUE0QiwwQ0FBYTtBQUN6QztBQUNBLGlDQUFpQyxnREFBbUIsMEJBQTBCLCtCQUErQjtBQUM3RztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUIsdUNBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQWdCO0FBQ3pDO0FBQ0EsaUNBQWlDLGdEQUFtQixZQUFZLHVDQUF1QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xELHVCQUF1QiwwQ0FBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNOLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCx3QkFBd0IsMENBQWE7QUFDckM7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUJBQXlCLGdEQUFtQixxQkFBcUIscUJBQXFCO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZDQUFnQjtBQUN6QyxRQUFRLEtBQXFDO0FBQzdDO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUM0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsWUFBWSwyQkFBMkIsZ0RBQWdELGtDQUFrQztBQUN6SCxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQscUJBQXFCLHlDQUFZO0FBQ2pDLDRCQUE0Qiw4Q0FBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFxQztBQUNuRCxvQkFBb0IscUJBQXFCLGlEQUFpRDtBQUMxRixvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUEwQiwwR0FBZ0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFhRTtBQUNGIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXHJlYWN0LXJlZHV4XFxkaXN0XFxyZWFjdC1yZWR1eC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzL3JlYWN0LnRzXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3V0aWxzL3JlYWN0LWlzLnRzXG52YXIgSVNfUkVBQ1RfMTkgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKFwiMTlcIik7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXG4gIElTX1JFQUNUXzE5ID8gXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiIDogXCJyZWFjdC5lbGVtZW50XCJcbik7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbnZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXG4gIFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiXG4pO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXG4gIFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiXG4pO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApID8gdHJ1ZSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCB7ICQkdHlwZW9mIH0gPSBvYmplY3Q7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHN3aXRjaCAob2JqZWN0ID0gb2JqZWN0LnR5cGUsIG9iamVjdCkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0ID0gb2JqZWN0ICYmIG9iamVjdC4kJHR5cGVvZiwgb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gSVNfUkVBQ1RfMTkgPyB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSA6IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuXG4vLyBzcmMvdXRpbHMvd2FybmluZy50c1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICB0cnkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy50c1xuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lKSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFsdWUgZm9yICR7bWV0aG9kTmFtZX0gaW4gY29ubmVjdC5gKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSBcIm1hcFN0YXRlVG9Qcm9wc1wiIHx8IG1ldGhvZE5hbWUgPT09IFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxlY3RvciwgXCJkZXBlbmRzT25Pd25Qcm9wc1wiKSkge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYFRoZSBzZWxlY3RvciBmb3IgJHttZXRob2ROYW1lfSBvZiBjb25uZWN0IGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZlcmlmeShtYXBTdGF0ZVRvUHJvcHMsIFwibWFwU3RhdGVUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWFwRGlzcGF0Y2hUb1Byb3BzLCBcIm1hcERpc3BhdGNoVG9Qcm9wc1wiKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsIFwibWVyZ2VQcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LnRzXG5mdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIHtcbiAgYXJlU3RhdGVzRXF1YWwsXG4gIGFyZU93blByb3BzRXF1YWwsXG4gIGFyZVN0YXRlUHJvcHNFcXVhbFxufSkge1xuICBsZXQgaGFzUnVuQXRMZWFzdE9uY2UgPSBmYWxzZTtcbiAgbGV0IHN0YXRlO1xuICBsZXQgb3duUHJvcHM7XG4gIGxldCBzdGF0ZVByb3BzO1xuICBsZXQgZGlzcGF0Y2hQcm9wcztcbiAgbGV0IG1lcmdlZFByb3BzO1xuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wcygpIHtcbiAgICBpZiAobWFwU3RhdGVUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3U3RhdGUoKSB7XG4gICAgY29uc3QgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpXG4gICAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSAhYXJlT3duUHJvcHNFcXVhbChuZXh0T3duUHJvcHMsIG93blByb3BzKTtcbiAgICBjb25zdCBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwoXG4gICAgICBuZXh0U3RhdGUsXG4gICAgICBzdGF0ZSxcbiAgICAgIG5leHRPd25Qcm9wcyxcbiAgICAgIG93blByb3BzXG4gICAgKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcbiAgICBpZiAocHJvcHNDaGFuZ2VkICYmIHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHMoKTtcbiAgICBpZiAoc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3U3RhdGUoKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIHtcbiAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgaW5pdE1lcmdlUHJvcHMsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgY29uc3QgbWFwU3RhdGVUb1Byb3BzID0gaW5pdE1hcFN0YXRlVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBjb25zdCBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKTtcbiAgfVxuICByZXR1cm4gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL3V0aWxzL2JpbmRBY3Rpb25DcmVhdG9ycy50c1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9ICguLi5hcmdzKSA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cbi8vIHNyYy91dGlscy9pc1BsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgbGV0IGJhc2VQcm90byA9IHByb3RvO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcbn1cblxuLy8gc3JjL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBgJHttZXRob2ROYW1lfSgpIGluICR7ZGlzcGxheU5hbWV9IG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7dmFsdWV9LmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLnRzXG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCkge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gpO1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59XG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUgfSkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvaW52YWxpZEFyZ0ZhY3RvcnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KGFyZywgbmFtZSkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhcmd9IGZvciAke25hbWV9IGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJHtvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lfS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwib2JqZWN0XCIgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KFxuICAgIChkaXNwYXRjaCkgPT4gKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpXG4gICAgKVxuICApIDogIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKGRpc3BhdGNoKSA9PiAoe1xuICAgIGRpc3BhdGNoXG4gIH0pKSA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KCgpID0+ICh7fSkpIDogdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWVyZ2VQcm9wcy50c1xuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIHsgLi4ub3duUHJvcHMsIC4uLnN0YXRlUHJvcHMsIC4uLmRpc3BhdGNoUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lLCBhcmVNZXJnZWRQcm9wc0VxdWFsIH0pIHtcbiAgICBsZXQgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIGxldCBtZXJnZWRQcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICBjb25zdCBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSlcbiAgICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsIFwibWVyZ2VQcm9wc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wcyA6IHR5cGVvZiBtZXJnZVByb3BzID09PSBcImZ1bmN0aW9uXCIgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy91dGlscy9iYXRjaC50c1xuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG4vLyBzcmMvdXRpbHMvU3Vic2NyaXB0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGxldCBmaXJzdCA9IG51bGw7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgIGxhc3QgPSBudWxsO1xuICAgIH0sXG4gICAgbm90aWZ5KCkge1xuICAgICAgZGVmYXVsdE5vb3BCYXRjaCgoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpO1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9LFxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxudmFyIG51bGxMaXN0ZW5lcnMgPSB7XG4gIG5vdGlmeSgpIHtcbiAgfSxcbiAgZ2V0OiAoKSA9PiBbXVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViKSB7XG4gIGxldCB1bnN1YnNjcmliZTtcbiAgbGV0IGxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gIGxldCBzdWJzY3JpcHRpb25zQW1vdW50ID0gMDtcbiAgbGV0IHNlbGZTdWJzY3JpYmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGFkZE5lc3RlZFN1YihsaXN0ZW5lcikge1xuICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIGNvbnN0IGNsZWFudXBMaXN0ZW5lciA9IGxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcmVtb3ZlZCkge1xuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyKCk7XG4gICAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzKCkge1xuICAgIGxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmIChzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBzZWxmU3Vic2NyaWJlZDtcbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgc3Vic2NyaXB0aW9uc0Ftb3VudCsrO1xuICAgIGlmICghdW5zdWJzY3JpYmUpIHtcbiAgICAgIHVuc3Vic2NyaWJlID0gcGFyZW50U3ViID8gcGFyZW50U3ViLmFkZE5lc3RlZFN1YihoYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHN0b3JlLnN1YnNjcmliZShoYW5kbGVDaGFuZ2VXcmFwcGVyKTtcbiAgICAgIGxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50LS07XG4gICAgaWYgKHVuc3Vic2NyaWJlICYmIHN1YnNjcmlwdGlvbnNBbW91bnQgPT09IDApIHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB1bnN1YnNjcmliZSA9IHZvaWQgMDtcbiAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5U3Vic2NyaWJlU2VsZigpIHtcbiAgICBpZiAoIXNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICB0cnlTdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmIChzZWxmU3Vic2NyaWJlZCkge1xuICAgICAgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIHRyeVVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICBhZGROZXN0ZWRTdWIsXG4gICAgbm90aWZ5TmVzdGVkU3VicyxcbiAgICBoYW5kbGVDaGFuZ2VXcmFwcGVyLFxuICAgIGlzU3Vic2NyaWJlZCxcbiAgICB0cnlTdWJzY3JpYmU6IHRyeVN1YnNjcmliZVNlbGYsXG4gICAgdHJ5VW5zdWJzY3JpYmU6IHRyeVVuc3Vic2NyaWJlU2VsZixcbiAgICBnZXRMaXN0ZW5lcnM6ICgpID0+IGxpc3RlbmVyc1xuICB9O1xuICByZXR1cm4gc3Vic2NyaXB0aW9uO1xufVxuXG4vLyBzcmMvdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdC50c1xudmFyIGNhblVzZURPTSA9ICgpID0+ICEhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIpO1xudmFyIGlzRE9NID0gLyogQF9fUFVSRV9fICovIGNhblVzZURPTSgpO1xudmFyIGlzUnVubmluZ0luUmVhY3ROYXRpdmUgPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCI7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBpc1J1bm5pbmdJblJlYWN0TmF0aXZlKCk7XG52YXIgZ2V0VXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9ICgpID0+IGlzRE9NIHx8IGlzUmVhY3ROYXRpdmUgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IC8qIEBfX1BVUkVfXyAqLyBnZXRVc2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCk7XG5cbi8vIHNyYy91dGlscy9zaGFsbG93RXF1YWwudHNcbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iakEgIT09IFwib2JqZWN0XCIgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvdXRpbHMvaG9pc3RTdGF0aWNzLnRzXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHtcbiAgW0ZvcndhcmRSZWZdOiBGT1JXQVJEX1JFRl9TVEFUSUNTLFxuICBbTWVtb106IE1FTU9fU1RBVElDU1xufTtcbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIGlmIChpc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH1cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbXCIkJHR5cGVvZlwiXV0gfHwgUkVBQ1RfU1RBVElDUztcbn1cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIGNvbnN0IGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICBjb25zdCBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL0NvbnRleHQudHNcbnZhciBDb250ZXh0S2V5ID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoYHJlYWN0LXJlZHV4LWNvbnRleHRgKTtcbnZhciBnVCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IChcbiAgLyogZmFsbCBiYWNrIHRvIGEgcGVyLW1vZHVsZSBzY29wZSAocHJlLTguMSBiZWhhdmlvdXIpIGlmIGBnbG9iYWxUaGlzYCBpcyBub3QgYXZhaWxhYmxlICovXG4gIHt9XG4pO1xuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgaWYgKCFSZWFjdC5jcmVhdGVDb250ZXh0KSByZXR1cm4ge307XG4gIGNvbnN0IGNvbnRleHRNYXAgPSBnVFtDb250ZXh0S2V5XSA/Pz0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dCk7XG4gIGlmICghcmVhbENvbnRleHQpIHtcbiAgICByZWFsQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWFsQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUmVhY3RSZWR1eFwiO1xuICAgIH1cbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIHJlYWxDb250ZXh0O1xufVxudmFyIFJlYWN0UmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGdldENvbnRleHQoKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvY29ubmVjdC50c3hcbnZhciBOT19TVUJTQ1JJUFRJT05fQVJSQVkgPSBbbnVsbCwgbnVsbF07XG52YXIgc3RyaW5naWZ5Q29tcG9uZW50ID0gKENvbXApID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoQ29tcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcoQ29tcCk7XG4gIH1cbn07XG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoZWZmZWN0RnVuYywgZWZmZWN0QXJncywgZGVwZW5kZW5jaWVzKSB7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gZWZmZWN0RnVuYyguLi5lZmZlY3RBcmdzKSwgZGVwZW5kZW5jaWVzKTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVXcmFwcGVyUHJvcHMobGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMpIHtcbiAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50ID0gd3JhcHBlclByb3BzO1xuICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gZmFsc2U7XG4gIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQpIHtcbiAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBudWxsO1xuICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlVXBkYXRlcyhzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3RvciwgbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCBpc01vdW50ZWQsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMsIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcikge1xuICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuICgpID0+IHtcbiAgfTtcbiAgbGV0IGRpZFVuc3Vic2NyaWJlID0gZmFsc2U7XG4gIGxldCBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICBjb25zdCBjaGVja0ZvclVwZGF0ZXMgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFVuc3Vic2NyaWJlIHx8ICFpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXRlc3RTdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBsZXQgbmV3Q2hpbGRQcm9wcywgZXJyb3I7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NoaWxkUHJvcHMgPSBjaGlsZFByb3BzU2VsZWN0b3IoXG4gICAgICAgIGxhdGVzdFN0b3JlU3RhdGUsXG4gICAgICAgIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobmV3Q2hpbGRQcm9wcyA9PT0gbGFzdENoaWxkUHJvcHMuY3VycmVudCkge1xuICAgICAgaWYgKCFyZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50KSB7XG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IHRydWU7XG4gICAgICBhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIoKTtcbiAgICB9XG4gIH07XG4gIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzO1xuICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuICBjb25zdCB1bnN1YnNjcmliZVdyYXBwZXIgPSAoKSA9PiB7XG4gICAgZGlkVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3I7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdW5zdWJzY3JpYmVXcmFwcGVyO1xufVxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCB7XG4gIC8vIFRoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQsIHNvIFRTIGRvZXNuJ3QgbGlrZSB1cyBkZXN0cnVjdHVyaW5nIHRoaXMgdG8gY2hlY2sgaXRzIGV4aXN0ZW5jZS5cbiAgLy8gQHRzLWlnbm9yZVxuICBwdXJlLFxuICBhcmVTdGF0ZXNFcXVhbCA9IHN0cmljdEVxdWFsLFxuICBhcmVPd25Qcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBzaGFsbG93RXF1YWwsXG4gIC8vIHVzZSBSZWFjdCdzIGZvcndhcmRSZWYgdG8gZXhwb3NlIGEgcmVmIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudFxuICBmb3J3YXJkUmVmID0gZmFsc2UsXG4gIC8vIHRoZSBjb250ZXh0IGNvbnN1bWVyIHRvIHVzZVxuICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHRcbn0gPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHB1cmUgIT09IHZvaWQgMCAmJiAhaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbikge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IHRydWU7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAnVGhlIGBwdXJlYCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gYGNvbm5lY3RgIGlzIG5vdyBhbHdheXMgYSBcInB1cmUvbWVtb2l6ZWRcIiBjb21wb25lbnQnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBDb250ZXh0ID0gY29udGV4dDtcbiAgY29uc3QgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcnkobWFwRGlzcGF0Y2hUb1Byb3BzKTtcbiAgY29uc3QgaW5pdE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzRmFjdG9yeShtZXJnZVByb3BzKTtcbiAgY29uc3Qgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICBjb25zdCB3cmFwV2l0aENvbm5lY3QgPSAoV3JhcHBlZENvbXBvbmVudCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGNvbm5lY3QuIEluc3RlYWQgcmVjZWl2ZWQgJHtzdHJpbmdpZnlDb21wb25lbnQoXG4gICAgICAgICAgICBXcmFwcGVkQ29tcG9uZW50XG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnROYW1lID0gV3JhcHBlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBXcmFwcGVkQ29tcG9uZW50Lm5hbWUgfHwgXCJDb21wb25lbnRcIjtcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IGBDb25uZWN0KCR7d3JhcHBlZENvbXBvbmVudE5hbWV9KWA7XG4gICAgY29uc3Qgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IHtcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIENvbm5lY3RGdW5jdGlvbihwcm9wcykge1xuICAgICAgY29uc3QgW3Byb3BzQ29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZiwgd3JhcHBlclByb3BzXSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYyLCAuLi53cmFwcGVyUHJvcHMyIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIFtwcm9wcy5jb250ZXh0LCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgd3JhcHBlclByb3BzMl07XG4gICAgICB9LCBbcHJvcHNdKTtcbiAgICAgIGNvbnN0IENvbnRleHRUb1VzZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgUmVzdWx0Q29udGV4dCA9IENvbnRleHQ7XG4gICAgICAgIGlmIChwcm9wc0NvbnRleHQ/LkNvbnN1bWVyKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC8qIEBfX1BVUkVfXyAqLyBpc0NvbnRleHRDb25zdW1lcihcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wc0NvbnRleHQuQ29uc3VtZXIsIG51bGwpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIllvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIGFzIGBwcm9wcy5jb250ZXh0YFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZXN1bHRDb250ZXh0ID0gcHJvcHNDb250ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVzdWx0Q29udGV4dDtcbiAgICAgIH0sIFtwcm9wc0NvbnRleHQsIENvbnRleHRdKTtcbiAgICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dFRvVXNlKTtcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9IEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZ2V0U3RhdGUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgY29uc3QgZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPSBCb29sZWFuKGNvbnRleHRWYWx1ZSkgJiYgQm9vbGVhbihjb250ZXh0VmFsdWUuc3RvcmUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhZGlkU3RvcmVDb21lRnJvbVByb3BzICYmICFkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENvdWxkIG5vdCBmaW5kIFwic3RvcmVcIiBpbiB0aGUgY29udGV4dCBvZiBcIiR7ZGlzcGxheU5hbWV9XCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sIG9yIHBhc3MgYSBjdXN0b20gUmVhY3QgY29udGV4dCBwcm92aWRlciB0byA8UHJvdmlkZXI+IGFuZCB0aGUgY29ycmVzcG9uZGluZyBSZWFjdCBjb250ZXh0IGNvbnN1bWVyIHRvICR7ZGlzcGxheU5hbWV9IGluIGNvbm5lY3Qgb3B0aW9ucy5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yZSA9IGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IHByb3BzLnN0b3JlIDogY29udGV4dFZhbHVlLnN0b3JlO1xuICAgICAgY29uc3QgZ2V0U2VydmVyU3RhdGUgPSBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA/IGNvbnRleHRWYWx1ZS5nZXRTZXJ2ZXJTdGF0ZSA6IHN0b3JlLmdldFN0YXRlO1xuICAgICAgY29uc3QgY2hpbGRQcm9wc1NlbGVjdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KHN0b3JlLmRpc3BhdGNoLCBzZWxlY3RvckZhY3RvcnlPcHRpb25zKTtcbiAgICAgIH0sIFtzdG9yZV0pO1xuICAgICAgY29uc3QgW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiBOT19TVUJTQ1JJUFRJT05fQVJSQVk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbjIgPSBjcmVhdGVTdWJzY3JpcHRpb24oXG4gICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgZGlkU3RvcmVDb21lRnJvbVByb3BzID8gdm9pZCAwIDogY29udGV4dFZhbHVlLnN1YnNjcmlwdGlvblxuICAgICAgICApO1xuICAgICAgICBjb25zdCBub3RpZnlOZXN0ZWRTdWJzMiA9IHN1YnNjcmlwdGlvbjIubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHN1YnNjcmlwdGlvbjIpO1xuICAgICAgICByZXR1cm4gW3N1YnNjcmlwdGlvbjIsIG5vdGlmeU5lc3RlZFN1YnMyXTtcbiAgICAgIH0sIFtzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWVdKTtcbiAgICAgIGNvbnN0IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRpZFN0b3JlQ29tZUZyb21Qcm9wcykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jb250ZXh0VmFsdWUsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICB9LCBbZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWUsIHN1YnNjcmlwdGlvbl0pO1xuICAgICAgY29uc3QgbGFzdENoaWxkUHJvcHMgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcbiAgICAgIGNvbnN0IGxhc3RXcmFwcGVyUHJvcHMgPSBSZWFjdC51c2VSZWYod3JhcHBlclByb3BzKTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUgPSBSZWFjdC51c2VSZWYodm9pZCAwKTtcbiAgICAgIGNvbnN0IHJlbmRlcklzU2NoZWR1bGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gUmVhY3QudXNlUmVmKFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9LCBbXSk7XG4gICAgICBjb25zdCBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCAmJiB3cmFwcGVyUHJvcHMgPT09IGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9LCBbc3RvcmUsIHdyYXBwZXJQcm9wc10pO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlRm9yUmVhY3QgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gKHJlYWN0TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVVcGRhdGVzKFxuICAgICAgICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcbiAgICAgICAgICAgIGlzTW91bnRlZCxcbiAgICAgICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgICAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgICAgICAgICAgcmVhY3RMaXN0ZW5lclxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmU7XG4gICAgICB9LCBbc3Vic2NyaXB0aW9uXSk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoY2FwdHVyZVdyYXBwZXJQcm9wcywgW1xuICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgIHdyYXBwZXJQcm9wcyxcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgbm90aWZ5TmVzdGVkU3Vic1xuICAgICAgXSk7XG4gICAgICBsZXQgYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdHVhbENoaWxkUHJvcHMgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICAvLyBUT0RPIFdlJ3JlIHBhc3NpbmcgdGhyb3VnaCBhIGJpZyB3cmFwcGVyIHRoYXQgZG9lcyBhIGJ1bmNoIG9mIGV4dHJhIHNpZGUgZWZmZWN0cyBiZXNpZGVzIHN1YnNjcmliaW5nXG4gICAgICAgICAgc3Vic2NyaWJlRm9yUmVhY3QsXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIGluY3JlZGlibHkgaGFja3kuIFdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZSBzdG9yZSB1cGRhdGUgYW5kIGNhbGN1bGF0ZWQgbmV3IGNoaWxkIHByb3BzLFxuICAgICAgICAgIC8vIFRPRE8gYW5kIHdlJ3JlIGp1c3QgcGFzc2luZyB0aGF0IHRocm91Z2ggc28gaXQgdHJpZ2dlcnMgYSByZS1yZW5kZXIgZm9yIHVzIHJhdGhlciB0aGFuIHJlbHlpbmcgb24gYHVTRVNgLlxuICAgICAgICAgIGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICBnZXRTZXJ2ZXJTdGF0ZSA/ICgpID0+IGNoaWxkUHJvcHNTZWxlY3RvcihnZXRTZXJ2ZXJTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpIDogYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBlcnIubWVzc2FnZSArPSBgXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxuJHtsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2t9XG5cbmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uYWN0dWFsQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgICAgcmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0VG9Vc2UuUHJvdmlkZXIsIHsgdmFsdWU6IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgfSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgfSwgW0NvbnRleHRUb1VzZSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50LCBvdmVycmlkZGVuQ29udGV4dFZhbHVlXSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZDtcbiAgICB9XG4gICAgY29uc3QgX0Nvbm5lY3QgPSBSZWFjdC5tZW1vKENvbm5lY3RGdW5jdGlvbik7XG4gICAgY29uc3QgQ29ubmVjdCA9IF9Db25uZWN0O1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IENvbm5lY3RGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZENvbm5lY3RSZWYocHJvcHMsIHJlZikge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0LCB7IC4uLnByb3BzLCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWYgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBmb3J3YXJkZWQgPSBfZm9yd2FyZGVkO1xuICAgICAgZm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICBmb3J3YXJkZWQuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKGZvcndhcmRlZCwgV3JhcHBlZENvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaG9pc3ROb25SZWFjdFN0YXRpY3MoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG4gIHJldHVybiB3cmFwV2l0aENvbm5lY3Q7XG59XG52YXIgY29ubmVjdF9kZWZhdWx0ID0gY29ubmVjdDtcblxuLy8gc3JjL2NvbXBvbmVudHMvUHJvdmlkZXIudHN4XG5mdW5jdGlvbiBQcm92aWRlcihwcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRleHQsIHNlcnZlclN0YXRlLCBzdG9yZSB9ID0gcHJvdmlkZXJQcm9wcztcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICBjb25zdCBiYXNlQ29udGV4dFZhbHVlID0ge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZTogc2VydmVyU3RhdGUgPyAoKSA9PiBzZXJ2ZXJTdGF0ZSA6IHZvaWQgMFxuICAgIH07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmV0dXJuIGJhc2VDb250ZXh0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gXCJvbmNlXCIsIHN0YWJpbGl0eUNoZWNrID0gXCJvbmNlXCIgfSA9IHByb3ZpZGVyUHJvcHM7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oYmFzZUNvbnRleHRWYWx1ZSwge1xuICAgICAgICBzdGFiaWxpdHlDaGVjayxcbiAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtzdG9yZSwgc2VydmVyU3RhdGVdKTtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKSwgW3N0b3JlXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gPSBjb250ZXh0VmFsdWU7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicztcbiAgICBzdWJzY3JpcHRpb24udHJ5U3Vic2NyaWJlKCk7XG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHN0b3JlLmdldFN0YXRlKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gdm9pZCAwO1xuICAgIH07XG4gIH0sIFtjb250ZXh0VmFsdWUsIHByZXZpb3VzU3RhdGVdKTtcbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQgfHwgUmVhY3RSZWR1eENvbnRleHQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUgfSwgY2hpbGRyZW4pO1xufVxudmFyIFByb3ZpZGVyX2RlZmF1bHQgPSBQcm92aWRlcjtcblxuLy8gc3JjL2hvb2tzL3VzZVJlZHV4Q29udGV4dC50c1xuZnVuY3Rpb24gY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZVJlZHV4Q29udGV4dDIoKSB7XG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFjb250ZXh0VmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJjb3VsZCBub3QgZmluZCByZWFjdC1yZWR1eCBjb250ZXh0IHZhbHVlOyBwbGVhc2UgZW5zdXJlIHRoZSBjb21wb25lbnQgaXMgd3JhcHBlZCBpbiBhIDxQcm92aWRlcj5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcbiAgfTtcbn1cbnZhciB1c2VSZWR1eENvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlUmVkdXhDb250ZXh0SG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlU3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpXG4gICk7XG4gIGNvbnN0IHVzZVN0b3JlMiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZVN0b3JlMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU3RvcmUyXG4gIH0pO1xuICByZXR1cm4gdXNlU3RvcmUyO1xufVxudmFyIHVzZVN0b3JlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVN0b3JlSG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlRGlzcGF0Y2gudHNcbmZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlU3RvcmUyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VTdG9yZSA6IGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlRGlzcGF0Y2gyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUyKCk7XG4gICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZURpc3BhdGNoMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlRGlzcGF0Y2gyXG4gIH0pO1xuICByZXR1cm4gdXNlRGlzcGF0Y2gyO1xufVxudmFyIHVzZURpc3BhdGNoID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURpc3BhdGNoSG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlU2VsZWN0b3IudHNcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gZnJvbSBcInVzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3dpdGgtc2VsZWN0b3IuanNcIjtcbnZhciByZWZFcXVhbGl0eSA9IChhLCBiKSA9PiBhID09PSBiO1xuZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JIb29rKGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dCkge1xuICBjb25zdCB1c2VSZWR1eENvbnRleHQyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VSZWR1eENvbnRleHQgOiBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpO1xuICBjb25zdCB1c2VTZWxlY3RvcjIgPSAoc2VsZWN0b3IsIGVxdWFsaXR5Rm5Pck9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHsgZXF1YWxpdHlGbiA9IHJlZkVxdWFsaXR5IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH0gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVxdWFsaXR5Rm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVkdXhDb250ZXh0ID0gdXNlUmVkdXhDb250ZXh0MigpO1xuICAgIGNvbnN0IHsgc3RvcmUsIHN1YnNjcmlwdGlvbiwgZ2V0U2VydmVyU3RhdGUgfSA9IHJlZHV4Q29udGV4dDtcbiAgICBjb25zdCBmaXJzdFJ1biA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIHtcbiAgICAgICAgW3NlbGVjdG9yLm5hbWVdKHN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgeyBkZXZNb2RlQ2hlY2tzID0ge30gfSA9IHR5cGVvZiBlcXVhbGl0eUZuT3JPcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IGVxdWFsaXR5Rm5Pck9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB7IGlkZW50aXR5RnVuY3Rpb25DaGVjaywgc3RhYmlsaXR5Q2hlY2sgfSA9IHJlZHV4Q29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBmaW5hbElkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2s6IGZpbmFsU3RhYmlsaXR5Q2hlY2tcbiAgICAgICAgICAgIH0gPSB7XG4gICAgICAgICAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2ssXG4gICAgICAgICAgICAgIC4uLmRldk1vZGVDaGVja3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZmluYWxTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvQ29tcGFyZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKCFlcXVhbGl0eUZuKHNlbGVjdGVkLCB0b0NvbXBhcmUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YWNrID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAoeyBzdGFjayB9ID0gZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiU2VsZWN0b3IgXCIgKyAoc2VsZWN0b3IubmFtZSB8fCBcInVua25vd25cIikgKyBcIiByZXR1cm5lZCBhIGRpZmZlcmVudCByZXN1bHQgd2hlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gYSBuZXcgcmVmZXJlbmNlIChzdWNoIGFzIGFuIG9iamVjdCBvciBhbiBhcnJheSkgc2hvdWxkIGJlIG1lbW9pemVkOiBodHRwczovL3JlZHV4LmpzLm9yZy91c2FnZS9kZXJpdmluZy1kYXRhLXNlbGVjdG9ycyNvcHRpbWl6aW5nLXNlbGVjdG9ycy13aXRoLW1lbW9pemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQyOiB0b0NvbXBhcmUsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIHRoZSByb290IHN0YXRlIHdoZW4gY2FsbGVkLiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHJlcmVuZGVycy5cXG5TZWxlY3RvcnMgdGhhdCByZXR1cm4gdGhlIGVudGlyZSBzdGF0ZSBhcmUgYWxtb3N0IGNlcnRhaW5seSBhIG1pc3Rha2UsIGFzIHRoZXkgd2lsbCBjYXVzZSBhIHJlcmVuZGVyIHdoZW5ldmVyICphbnl0aGluZyogaW4gc3RhdGUgY2hhbmdlcy5cIixcbiAgICAgICAgICAgICAgICAgIHsgc3RhY2sgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFJ1bi5jdXJyZW50KSBmaXJzdFJ1bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfVtzZWxlY3Rvci5uYW1lXSxcbiAgICAgIFtzZWxlY3Rvcl1cbiAgICApO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmlwdGlvbi5hZGROZXN0ZWRTdWIsXG4gICAgICBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgZXF1YWxpdHlGblxuICAgICk7XG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIHVzZVNlbGVjdG9yMjtcbn1cbnZhciB1c2VTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3Rvckhvb2soKTtcblxuLy8gc3JjL2V4cG9ydHMudHNcbnZhciBiYXRjaCA9IGRlZmF1bHROb29wQmF0Y2g7XG5leHBvcnQge1xuICBQcm92aWRlcl9kZWZhdWx0IGFzIFByb3ZpZGVyLFxuICBSZWFjdFJlZHV4Q29udGV4dCxcbiAgYmF0Y2gsXG4gIGNvbm5lY3RfZGVmYXVsdCBhcyBjb25uZWN0LFxuICBjcmVhdGVEaXNwYXRjaEhvb2ssXG4gIGNyZWF0ZVNlbGVjdG9ySG9vayxcbiAgY3JlYXRlU3RvcmVIb29rLFxuICBzaGFsbG93RXF1YWwsXG4gIHVzZURpc3BhdGNoLFxuICB1c2VTZWxlY3RvcixcbiAgdXNlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yZWR1eC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/react-redux/dist/react-redux.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! react */ \"(pages-dir-browser)/../../node_modules/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXHJlYWN0XFxjanNcXHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuICAgICAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLFxuICAgICAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG4gICAgICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgICAgIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLFxuICAgICAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSxcbiAgICAgIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG4gICAgICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksXG4gICAgICBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3IsXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fSxcbiAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZik7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/react/jsx-dev-runtime.js":
/*!***************************************************!*\
  !*** ../../node_modules/react/jsx-dev-runtime.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(pages-dir-browser)/../../node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSwrS0FBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xccmVhY3RcXGpzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/redux-thunk/dist/redux-thunk.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/redux-thunk/dist/redux-thunk.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thunk: () => (/* binding */ thunk),\n/* harmony export */   withExtraArgument: () => (/* binding */ withExtraArgument)\n/* harmony export */ });\n// src/index.ts\nfunction createThunkMiddleware(extraArgument) {\n  const middleware = ({ dispatch, getState }) => (next) => (action) => {\n    if (typeof action === \"function\") {\n      return action(dispatch, getState, extraArgument);\n    }\n    return next(action);\n  };\n  return middleware;\n}\nvar thunk = createThunkMiddleware();\nvar withExtraArgument = createThunkMiddleware;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZGlzdC9yZWR1eC10aHVuay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxyZWR1eC10aHVua1xcZGlzdFxccmVkdXgtdGh1bmsubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgY29uc3QgbWlkZGxld2FyZSA9ICh7IGRpc3BhdGNoLCBnZXRTdGF0ZSB9KSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbiAgcmV0dXJuIG1pZGRsZXdhcmU7XG59XG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcbnZhciB3aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcbmV4cG9ydCB7XG4gIHRodW5rLFxuICB3aXRoRXh0cmFBcmd1bWVudFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/redux-thunk/dist/redux-thunk.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/redux/dist/redux.mjs":
/*!***********************************************!*\
  !*** ../../node_modules/redux/dist/redux.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* binding */ actionTypes_default),\n/* harmony export */   applyMiddleware: () => (/* binding */ applyMiddleware),\n/* harmony export */   bindActionCreators: () => (/* binding */ bindActionCreators),\n/* harmony export */   combineReducers: () => (/* binding */ combineReducers),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   isAction: () => (/* binding */ isAction),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   legacy_createStore: () => (/* binding */ legacy_createStore)\n/* harmony export */ });\n// src/utils/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n  return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n\n// src/utils/symbol-observable.ts\nvar $$observable = /* @__PURE__ */ (() => typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nvar symbol_observable_default = $$observable;\n\n// src/utils/actionTypes.ts\nvar randomString = () => Math.random().toString(36).substring(7).split(\"\").join(\".\");\nvar ActionTypes = {\n  INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,\n  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,\n  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n};\nvar actionTypes_default = ActionTypes;\n\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n  if (typeof obj !== \"object\" || obj === null)\n    return false;\n  let proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;\n}\n\n// src/utils/kindOf.ts\nfunction miniKindOf(val) {\n  if (val === void 0)\n    return \"undefined\";\n  if (val === null)\n    return \"null\";\n  const type = typeof val;\n  switch (type) {\n    case \"boolean\":\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"function\": {\n      return type;\n    }\n  }\n  if (Array.isArray(val))\n    return \"array\";\n  if (isDate(val))\n    return \"date\";\n  if (isError(val))\n    return \"error\";\n  const constructorName = ctorName(val);\n  switch (constructorName) {\n    case \"Symbol\":\n    case \"Promise\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n    case \"Map\":\n    case \"Set\":\n      return constructorName;\n  }\n  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n}\nfunction ctorName(val) {\n  return typeof val.constructor === \"function\" ? val.constructor.name : null;\n}\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n}\nfunction isDate(val) {\n  if (val instanceof Date)\n    return true;\n  return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n}\nfunction kindOf(val) {\n  let typeOfVal = typeof val;\n  if (true) {\n    typeOfVal = miniKindOf(val);\n  }\n  return typeOfVal;\n}\n\n// src/createStore.ts\nfunction createStore(reducer, preloadedState, enhancer) {\n  if (typeof reducer !== \"function\") {\n    throw new Error( false ? 0 : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);\n  }\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n    throw new Error( false ? 0 : \"It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.\");\n  }\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n    enhancer = preloadedState;\n    preloadedState = void 0;\n  }\n  if (typeof enhancer !== \"undefined\") {\n    if (typeof enhancer !== \"function\") {\n      throw new Error( false ? 0 : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);\n    }\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n  let currentReducer = reducer;\n  let currentState = preloadedState;\n  let currentListeners = /* @__PURE__ */ new Map();\n  let nextListeners = currentListeners;\n  let listenerIdCounter = 0;\n  let isDispatching = false;\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = /* @__PURE__ */ new Map();\n      currentListeners.forEach((listener, key) => {\n        nextListeners.set(key, listener);\n      });\n    }\n  }\n  function getState() {\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.\");\n    }\n    return currentState;\n  }\n  function subscribe(listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error( false ? 0 : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);\n    }\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.\");\n    }\n    let isSubscribed = true;\n    ensureCanMutateNextListeners();\n    const listenerId = listenerIdCounter++;\n    nextListeners.set(listenerId, listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n      if (isDispatching) {\n        throw new Error( false ? 0 : \"You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.\");\n      }\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      nextListeners.delete(listenerId);\n      currentListeners = null;\n    };\n  }\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error( false ? 0 : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);\n    }\n    if (typeof action.type === \"undefined\") {\n      throw new Error( false ? 0 : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n    if (typeof action.type !== \"string\") {\n      throw new Error( false ? 0 : `Action \"type\" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);\n    }\n    if (isDispatching) {\n      throw new Error( false ? 0 : \"Reducers may not dispatch actions.\");\n    }\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n    const listeners = currentListeners = nextListeners;\n    listeners.forEach((listener) => {\n      listener();\n    });\n    return action;\n  }\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \"function\") {\n      throw new Error( false ? 0 : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);\n    }\n    currentReducer = nextReducer;\n    dispatch({\n      type: actionTypes_default.REPLACE\n    });\n  }\n  function observable() {\n    const outerSubscribe = subscribe;\n    return {\n      /**\n       * The minimal observable subscription method.\n       * @param observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe(observer) {\n        if (typeof observer !== \"object\" || observer === null) {\n          throw new Error( false ? 0 : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);\n        }\n        function observeState() {\n          const observerAsObserver = observer;\n          if (observerAsObserver.next) {\n            observerAsObserver.next(getState());\n          }\n        }\n        observeState();\n        const unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe\n        };\n      },\n      [symbol_observable_default]() {\n        return this;\n      }\n    };\n  }\n  dispatch({\n    type: actionTypes_default.INIT\n  });\n  const store = {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [symbol_observable_default]: observable\n  };\n  return store;\n}\nfunction legacy_createStore(reducer, preloadedState, enhancer) {\n  return createStore(reducer, preloadedState, enhancer);\n}\n\n// src/utils/warning.ts\nfunction warning(message) {\n  if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n    console.error(message);\n  }\n  try {\n    throw new Error(message);\n  } catch (e) {\n  }\n}\n\n// src/combineReducers.ts\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  const reducerKeys = Object.keys(reducers);\n  const argumentName = action && action.type === actionTypes_default.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n  if (reducerKeys.length === 0) {\n    return \"Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.\";\n  }\n  if (!isPlainObject(inputState)) {\n    return `The ${argumentName} has unexpected type of \"${kindOf(inputState)}\". Expected argument to be an object with the following keys: \"${reducerKeys.join('\", \"')}\"`;\n  }\n  const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);\n  unexpectedKeys.forEach((key) => {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === actionTypes_default.REPLACE)\n    return;\n  if (unexpectedKeys.length > 0) {\n    return `Unexpected ${unexpectedKeys.length > 1 ? \"keys\" : \"key\"} \"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. Expected to find one of the known reducer keys instead: \"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.`;\n  }\n}\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach((key) => {\n    const reducer = reducers[key];\n    const initialState = reducer(void 0, {\n      type: actionTypes_default.INIT\n    });\n    if (typeof initialState === \"undefined\") {\n      throw new Error( false ? 0 : `The slice reducer for key \"${key}\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n    }\n    if (typeof reducer(void 0, {\n      type: actionTypes_default.PROBE_UNKNOWN_ACTION()\n    }) === \"undefined\") {\n      throw new Error( false ? 0 : `The slice reducer for key \"${key}\" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in \"redux/*\" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);\n    }\n  });\n}\nfunction combineReducers(reducers) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (true) {\n      if (typeof reducers[key] === \"undefined\") {\n        warning(`No reducer provided for key \"${key}\"`);\n      }\n    }\n    if (typeof reducers[key] === \"function\") {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  let unexpectedKeyCache;\n  if (true) {\n    unexpectedKeyCache = {};\n  }\n  let shapeAssertionError;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n  return function combination(state = {}, action) {\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n    if (true) {\n      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === \"undefined\") {\n        const actionType = action && action.type;\n        throw new Error( false ? 0 : `When called with an action of type ${actionType ? `\"${String(actionType)}\"` : \"(unknown type)\"}, the slice reducer for key \"${key}\" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\n// src/bindActionCreators.ts\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function(...args) {\n    return dispatch(actionCreator.apply(this, args));\n  };\n}\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === \"function\") {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n  if (typeof actionCreators !== \"object\" || actionCreators === null) {\n    throw new Error( false ? 0 : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`);\n  }\n  const boundActionCreators = {};\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n    if (typeof actionCreator === \"function\") {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n// src/compose.ts\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return (arg) => arg;\n  }\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\n// src/applyMiddleware.ts\nfunction applyMiddleware(...middlewares) {\n  return (createStore2) => (reducer, preloadedState) => {\n    const store = createStore2(reducer, preloadedState);\n    let dispatch = () => {\n      throw new Error( false ? 0 : \"Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.\");\n    };\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action, ...args) => dispatch(action, ...args)\n    };\n    const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch\n    };\n  };\n}\n\n// src/utils/isAction.ts\nfunction isAction(action) {\n  return isPlainObject(action) && \"type\" in action && typeof action.type === \"string\";\n}\n\n//# sourceMappingURL=redux.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVkdXgvZGlzdC9yZWR1eC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPLHlDQUF5QyxNQUFNO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3RELDZCQUE2QiwrQkFBK0I7QUFDNUQsNkRBQTZELGVBQWU7QUFDNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBcUMsR0FBRyxDQUF5QixzRUFBc0UsZ0JBQWdCO0FBQzNLO0FBQ0E7QUFDQSxvQkFBb0IsTUFBcUMsR0FBRyxDQUF5QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCLGtFQUFrRSxpQkFBaUI7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBcUMsR0FBRyxDQUF5QixrRUFBa0UsaUJBQWlCO0FBQzFLO0FBQ0E7QUFDQSxzQkFBc0IsTUFBcUMsR0FBRyxDQUF5QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFxQyxHQUFHLENBQXlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQXlCLG9FQUFvRSxlQUFlO0FBQzFLO0FBQ0E7QUFDQSxzQkFBc0IsTUFBcUMsR0FBRyxDQUF5QjtBQUN2RjtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBMEIsOEVBQThFLG9CQUFvQixpQkFBaUIsWUFBWTtBQUN2TjtBQUNBO0FBQ0Esc0JBQXNCLE1BQXFDLEdBQUcsQ0FBeUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQTBCLHFFQUFxRSxvQkFBb0I7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFxQyxHQUFHLENBQTBCLGlFQUFpRSxpQkFBaUI7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYywwQkFBMEIsbUJBQW1CLGlFQUFpRSx5QkFBeUI7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QyxHQUFHLDRCQUE0QixhQUFhLGFBQWEsNkRBQTZELHlCQUF5QjtBQUNwTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQTBCLGlDQUFpQyxJQUFJO0FBQzdIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsTUFBcUMsR0FBRyxDQUEwQixpQ0FBaUMsSUFBSSw0RUFBNEUseUJBQXlCO0FBQ2xPO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLEdBQUcsQ0FBMEIseUNBQXlDLGlCQUFpQixtQkFBbUIsc0JBQXNCLCtCQUErQixJQUFJO0FBQ2hPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFxQyxHQUFHLENBQTBCLGtGQUFrRix1QkFBdUI7QUFDL0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFxQyxHQUFHLENBQTBCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBV0U7QUFDRiIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcbm9kZV9tb2R1bGVzXFxyZWR1eFxcZGlzdFxccmVkdXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBlcnJvciAjJHtjb2RlfTsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuXG4vLyBzcmMvdXRpbHMvc3ltYm9sLW9ic2VydmFibGUudHNcbnZhciAkJG9ic2VydmFibGUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCBcIkBAb2JzZXJ2YWJsZVwiKSgpO1xudmFyIHN5bWJvbF9vYnNlcnZhYmxlX2RlZmF1bHQgPSAkJG9ic2VydmFibGU7XG5cbi8vIHNyYy91dGlscy9hY3Rpb25UeXBlcy50c1xudmFyIHJhbmRvbVN0cmluZyA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdChcIlwiKS5qb2luKFwiLlwiKTtcbnZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogYEBAcmVkdXgvSU5JVCR7LyogQF9fUFVSRV9fICovIHJhbmRvbVN0cmluZygpfWAsXG4gIFJFUExBQ0U6IGBAQHJlZHV4L1JFUExBQ0Ukey8qIEBfX1BVUkVfXyAqLyByYW5kb21TdHJpbmcoKX1gLFxuICBQUk9CRV9VTktOT1dOX0FDVElPTjogKCkgPT4gYEBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT04ke3JhbmRvbVN0cmluZygpfWBcbn07XG52YXIgYWN0aW9uVHlwZXNfZGVmYXVsdCA9IEFjdGlvblR5cGVzO1xuXG4vLyBzcmMvdXRpbHMvaXNQbGFpbk9iamVjdC50c1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgbGV0IHByb3RvID0gb2JqO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IHByb3RvIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBudWxsO1xufVxuXG4vLyBzcmMvdXRpbHMva2luZE9mLnRzXG5mdW5jdGlvbiBtaW5pS2luZE9mKHZhbCkge1xuICBpZiAodmFsID09PSB2b2lkIDApXG4gICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gIGlmICh2YWwgPT09IG51bGwpXG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjoge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgaWYgKGlzRGF0ZSh2YWwpKVxuICAgIHJldHVybiBcImRhdGVcIjtcbiAgaWYgKGlzRXJyb3IodmFsKSlcbiAgICByZXR1cm4gXCJlcnJvclwiO1xuICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSBjdG9yTmFtZSh2YWwpO1xuICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZSkge1xuICAgIGNhc2UgXCJTeW1ib2xcIjpcbiAgICBjYXNlIFwiUHJvbWlzZVwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csIFwiXCIpO1xufVxuZnVuY3Rpb24gY3Rvck5hbWUodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0Vycm9yKHZhbCkge1xuICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHZhbC5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0eXBlb2YgdmFsLnRvRGF0ZVN0cmluZyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWwuZ2V0RGF0ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICBsZXQgdHlwZU9mVmFsID0gdHlwZW9mIHZhbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHR5cGVPZlZhbCA9IG1pbmlLaW5kT2YodmFsKTtcbiAgfVxuICByZXR1cm4gdHlwZU9mVmFsO1xufVxuXG4vLyBzcmMvY3JlYXRlU3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogYEV4cGVjdGVkIHRoZSByb290IHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihyZWR1Y2VyKX0nYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBlbmhhbmNlciA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBhcmd1bWVudHNbM10gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJJdCBsb29rcyBsaWtlIHlvdSBhcmUgcGFzc2luZyBzZXZlcmFsIHN0b3JlIGVuaGFuY2VycyB0byBjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSB0b2dldGhlciB0byBhIHNpbmdsZSBmdW5jdGlvbi4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI2NyZWF0aW5nLWEtc3RvcmUtd2l0aC1lbmhhbmNlcnMgZm9yIGFuIGV4YW1wbGUuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW5oYW5jZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBlbmhhbmNlciA9IHByZWxvYWRlZFN0YXRlO1xuICAgIHByZWxvYWRlZFN0YXRlID0gdm9pZCAwO1xuICB9XG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogYEV4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKGVuaGFuY2VyKX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICB9XG4gIGxldCBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIGxldCBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgbGV0IGN1cnJlbnRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIGxldCBsaXN0ZW5lcklkQ291bnRlciA9IDA7XG4gIGxldCBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY3VycmVudExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lciwga2V5KSA9PiB7XG4gICAgICAgIG5leHRMaXN0ZW5lcnMuc2V0KGtleSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6IFwiWW91IG1heSBub3QgY2FsbCBzdG9yZS5nZXRTdGF0ZSgpIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiBQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogYEV4cGVjdGVkIHRoZSBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKGxpc3RlbmVyKX0nYCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IFwiWW91IG1heSBub3QgY2FsbCBzdG9yZS5zdWJzY3JpYmUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuIElmIHlvdSB3b3VsZCBsaWtlIHRvIGJlIG5vdGlmaWVkIGFmdGVyIHRoZSBzdG9yZSBoYXMgYmVlbiB1cGRhdGVkLCBzdWJzY3JpYmUgZnJvbSBhIGNvbXBvbmVudCBhbmQgaW52b2tlIHN0b3JlLmdldFN0YXRlKCkgaW4gdGhlIGNhbGxiYWNrIHRvIGFjY2VzcyB0aGUgbGF0ZXN0IHN0YXRlLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuXCIpO1xuICAgIH1cbiAgICBsZXQgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgY29uc3QgbGlzdGVuZXJJZCA9IGxpc3RlbmVySWRDb3VudGVyKys7XG4gICAgbmV4dExpc3RlbmVycy5zZXQobGlzdGVuZXJJZCwgbGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYpIDogXCJZb3UgbWF5IG5vdCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgbGlzdGVuZXIgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiBTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuXCIpO1xuICAgICAgfVxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICBuZXh0TGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcklkKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDcpIDogYEFjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBJbnN0ZWFkLCB0aGUgYWN0dWFsIHR5cGUgd2FzOiAnJHtraW5kT2YoYWN0aW9uKX0nLiBZb3UgbWF5IG5lZWQgdG8gYWRkIG1pZGRsZXdhcmUgdG8geW91ciBzdG9yZSBzZXR1cCB0byBoYW5kbGUgZGlzcGF0Y2hpbmcgb3RoZXIgdmFsdWVzLCBzdWNoIGFzICdyZWR1eC10aHVuaycgdG8gaGFuZGxlIGRpc3BhdGNoaW5nIGZ1bmN0aW9ucy4gU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC00LXN0b3JlI21pZGRsZXdhcmUgYW5kIGh0dHBzOi8vcmVkdXguanMub3JnL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcGFydC02LWFzeW5jLWxvZ2ljI3VzaW5nLXRoZS1yZWR1eC10aHVuay1taWRkbGV3YXJlIGZvciBleGFtcGxlcy5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOCkgOiAnQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiBZb3UgbWF5IGhhdmUgbWlzc3BlbGxlZCBhbiBhY3Rpb24gdHlwZSBzdHJpbmcgY29uc3RhbnQuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IGBBY3Rpb24gXCJ0eXBlXCIgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZy4gSW5zdGVhZCwgdGhlIGFjdHVhbCB0eXBlIHdhczogJyR7a2luZE9mKGFjdGlvbi50eXBlKX0nLiBWYWx1ZSB3YXM6ICcke2FjdGlvbi50eXBlfScgKHN0cmluZ2lmaWVkKWApO1xuICAgIH1cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOSkgOiBcIlJlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy5cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTApIDogYEV4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkLCByZWNlaXZlZDogJyR7a2luZE9mKG5leHRSZWR1Y2VyKX1gKTtcbiAgICB9XG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBhY3Rpb25UeXBlc19kZWZhdWx0LlJFUExBQ0VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIGNvbnN0IG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09IFwib2JqZWN0XCIgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBgRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4gSW5zdGVhZCwgcmVjZWl2ZWQ6ICcke2tpbmRPZihvYnNlcnZlcil9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBjb25zdCBvYnNlcnZlckFzT2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXJBc09ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyQXNPYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW3N5bWJvbF9vYnNlcnZhYmxlX2RlZmF1bHRdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGRpc3BhdGNoKHtcbiAgICB0eXBlOiBhY3Rpb25UeXBlc19kZWZhdWx0LklOSVRcbiAgfSk7XG4gIGNvbnN0IHN0b3JlID0ge1xuICAgIGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcixcbiAgICBbc3ltYm9sX29ic2VydmFibGVfZGVmYXVsdF06IG9ic2VydmFibGVcbiAgfTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gbGVnYWN5X2NyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICByZXR1cm4gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKTtcbn1cblxuLy8gc3JjL3V0aWxzL3dhcm5pbmcudHNcbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG4vLyBzcmMvY29tYmluZVJlZHVjZXJzLnRzXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICBjb25zdCByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgY29uc3QgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBhY3Rpb25UeXBlc19kZWZhdWx0LklOSVQgPyBcInByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZVwiIDogXCJwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlclwiO1xuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFwiU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy5cIjtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gYFRoZSAke2FyZ3VtZW50TmFtZX0gaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIiR7a2luZE9mKGlucHV0U3RhdGUpfVwiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGtleXM6IFwiJHtyZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKX1cImA7XG4gIH1cbiAgY29uc3QgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoKGtleSkgPT4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldKTtcbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcbiAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gYWN0aW9uVHlwZXNfZGVmYXVsdC5SRVBMQUNFKVxuICAgIHJldHVybjtcbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gYFVuZXhwZWN0ZWQgJHt1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gXCJrZXlzXCIgOiBcImtleVwifSBcIiR7dW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJyl9XCIgZm91bmQgaW4gJHthcmd1bWVudE5hbWV9LiBFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6IFwiJHtyZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKX1cIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5gO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2hhcGUocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodm9pZCAwLCB7XG4gICAgICB0eXBlOiBhY3Rpb25UeXBlc19kZWZhdWx0LklOSVRcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTIpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke2tleX1cIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLiBJZiB5b3UgZG9uJ3Qgd2FudCB0byBzZXQgYSB2YWx1ZSBmb3IgdGhpcyByZWR1Y2VyLCB5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodm9pZCAwLCB7XG4gICAgICB0eXBlOiBhY3Rpb25UeXBlc19kZWZhdWx0LlBST0JFX1VOS05PV05fQUNUSU9OKClcbiAgICB9KSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMpIDogYFRoZSBzbGljZSByZWR1Y2VyIGZvciBrZXkgXCIke2tleX1cIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiBEb24ndCB0cnkgdG8gaGFuZGxlICcke2FjdGlvblR5cGVzX2RlZmF1bHQuSU5JVH0nIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlIGFjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZCwgYnV0IGNhbiBiZSBudWxsLmApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgY29uc3QgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIGNvbnN0IGZpbmFsUmVkdWNlcnMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB3YXJuaW5nKGBObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCIke2tleX1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuICBsZXQgdW5leHBlY3RlZEtleUNhY2hlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlID0ge307XG4gIH1cbiAgbGV0IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKHN0YXRlID0ge30sIGFjdGlvbikge1xuICAgIGlmIChzaGFwZUFzc2VydGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBzaGFwZUFzc2VydGlvbkVycm9yO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICBjb25zdCByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1trZXldO1xuICAgICAgY29uc3QgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICBjb25zdCBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNCkgOiBgV2hlbiBjYWxsZWQgd2l0aCBhbiBhY3Rpb24gb2YgdHlwZSAke2FjdGlvblR5cGUgPyBgXCIke1N0cmluZyhhY3Rpb25UeXBlKX1cImAgOiBcIih1bmtub3duIHR5cGUpXCJ9LCB0aGUgc2xpY2UgcmVkdWNlciBmb3Iga2V5IFwiJHtrZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkLiBUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuIElmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLmApO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoO1xuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cbi8vIHNyYy9iaW5kQWN0aW9uQ3JlYXRvcnMudHNcbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJncykpO1xuICB9O1xufVxuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSBcIm9iamVjdFwiIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYpIDogYGJpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgYnV0IGluc3RlYWQgcmVjZWl2ZWQ6ICcke2tpbmRPZihhY3Rpb25DcmVhdG9ycyl9Jy4gRGlkIHlvdSB3cml0ZSBcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXCIgaW5zdGVhZCBvZiBcImltcG9ydCAqIGFzIEFjdGlvbkNyZWF0b3JzIGZyb21cIj9gKTtcbiAgfVxuICBjb25zdCBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGFjdGlvbkNyZWF0b3JzKSB7XG4gICAgY29uc3QgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG4gICAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cbi8vIHNyYy9jb21wb3NlLnRzXG5mdW5jdGlvbiBjb21wb3NlKC4uLmZ1bmNzKSB7XG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFyZykgPT4gYXJnO1xuICB9XG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZSgoYSwgYikgPT4gKC4uLmFyZ3MpID0+IGEoYiguLi5hcmdzKSkpO1xufVxuXG4vLyBzcmMvYXBwbHlNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpIHtcbiAgcmV0dXJuIChjcmVhdGVTdG9yZTIpID0+IChyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlU3RvcmUyKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgICBsZXQgZGlzcGF0Y2ggPSAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiBcIkRpc3BhdGNoaW5nIHdoaWxlIGNvbnN0cnVjdGluZyB5b3VyIG1pZGRsZXdhcmUgaXMgbm90IGFsbG93ZWQuIE90aGVyIG1pZGRsZXdhcmUgd291bGQgbm90IGJlIGFwcGxpZWQgdG8gdGhpcyBkaXNwYXRjaC5cIik7XG4gICAgfTtcbiAgICBjb25zdCBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgZGlzcGF0Y2g6IChhY3Rpb24sIC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbiwgLi4uYXJncylcbiAgICB9O1xuICAgIGNvbnN0IGNoYWluID0gbWlkZGxld2FyZXMubWFwKChtaWRkbGV3YXJlKSA9PiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpKTtcbiAgICBkaXNwYXRjaCA9IGNvbXBvc2UoLi4uY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RvcmUsXG4gICAgICBkaXNwYXRjaFxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9pc0FjdGlvbi50c1xuZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGFjdGlvbikgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydCB7XG4gIGFjdGlvblR5cGVzX2RlZmF1bHQgYXMgX19ET19OT1RfVVNFX19BY3Rpb25UeXBlcyxcbiAgYXBwbHlNaWRkbGV3YXJlLFxuICBiaW5kQWN0aW9uQ3JlYXRvcnMsXG4gIGNvbWJpbmVSZWR1Y2VycyxcbiAgY29tcG9zZSxcbiAgY3JlYXRlU3RvcmUsXG4gIGlzQWN0aW9uLFxuICBpc1BsYWluT2JqZWN0LFxuICBsZWdhY3lfY3JlYXRlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/redux/dist/redux.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/reselect/dist/reselect.mjs":
/*!*****************************************************!*\
  !*** ../../node_modules/reselect/dist/reselect.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSelector: () => (/* binding */ createSelector),\n/* harmony export */   createSelectorCreator: () => (/* binding */ createSelectorCreator),\n/* harmony export */   createStructuredSelector: () => (/* binding */ createStructuredSelector),\n/* harmony export */   lruMemoize: () => (/* binding */ lruMemoize),\n/* harmony export */   referenceEqualityCheck: () => (/* binding */ referenceEqualityCheck),\n/* harmony export */   setGlobalDevModeChecks: () => (/* binding */ setGlobalDevModeChecks),\n/* harmony export */   unstable_autotrackMemoize: () => (/* binding */ autotrackMemoize),\n/* harmony export */   weakMapMemoize: () => (/* binding */ weakMapMemoize)\n/* harmony export */ });\n// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {\n  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {\n    let isInputSameAsOutput = false;\n    try {\n      const emptyObject = {};\n      if (resultFunc(emptyObject) === emptyObject)\n        isInputSameAsOutput = true;\n    } catch {\n    }\n    if (isInputSameAsOutput) {\n      let stack = void 0;\n      try {\n        throw new Error();\n      } catch (e) {\n        ;\n        ({ stack } = e);\n      }\n      console.warn(\n        \"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\",\n        { stack }\n      );\n    }\n  }\n};\n\n// src/devModeChecks/inputStabilityCheck.ts\nvar runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {\n  const { memoize, memoizeOptions } = options;\n  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;\n  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);\n  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\n  if (!areInputSelectorResultsEqual) {\n    let stack = void 0;\n    try {\n      throw new Error();\n    } catch (e) {\n      ;\n      ({ stack } = e);\n    }\n    console.warn(\n      \"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\",\n      {\n        arguments: inputSelectorArgs,\n        firstInputs: inputSelectorResults,\n        secondInputs: inputSelectorResultsCopy,\n        stack\n      }\n    );\n  }\n};\n\n// src/devModeChecks/setGlobalDevModeChecks.ts\nvar globalDevModeChecks = {\n  inputStabilityCheck: \"once\",\n  identityFunctionCheck: \"once\"\n};\nvar setGlobalDevModeChecks = (devModeChecks) => {\n  Object.assign(globalDevModeChecks, devModeChecks);\n};\n\n// src/utils.ts\nvar NOT_FOUND = /* @__PURE__ */ Symbol(\"NOT_FOUND\");\nfunction assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {\n  if (typeof func !== \"function\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {\n  if (typeof object !== \"object\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {\n  if (!array.every((item) => typeof item === \"function\")) {\n    const itemTypes = array.map(\n      (item) => typeof item === \"function\" ? `function ${item.name || \"unnamed\"}()` : typeof item\n    ).join(\", \");\n    throw new TypeError(`${errorMessage}[${itemTypes}]`);\n  }\n}\nvar ensureIsArray = (item) => {\n  return Array.isArray(item) ? item : [item];\n};\nfunction getDependencies(createSelectorArgs) {\n  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n  assertIsArrayOfFunctions(\n    dependencies,\n    `createSelector expects all input-selectors to be functions, but received the following types: `\n  );\n  return dependencies;\n}\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\n  const inputSelectorResults = [];\n  const { length } = dependencies;\n  for (let i = 0; i < length; i++) {\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n  }\n  return inputSelectorResults;\n}\nvar getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {\n  const { identityFunctionCheck, inputStabilityCheck } = {\n    ...globalDevModeChecks,\n    ...devModeChecks\n  };\n  return {\n    identityFunctionCheck: {\n      shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\n      run: runInputStabilityCheck\n    }\n  };\n};\n\n// src/autotrackMemoize/autotracking.ts\nvar $REVISION = 0;\nvar CURRENT_TRACKER = null;\nvar Cell = class {\n  revision = $REVISION;\n  _value;\n  _lastValue;\n  _isEqual = tripleEq;\n  constructor(initialValue, isEqual = tripleEq) {\n    this._value = this._lastValue = initialValue;\n    this._isEqual = isEqual;\n  }\n  // Whenever a storage value is read, it'll add itself to the current tracker if\n  // one exists, entangling its state with that cache.\n  get value() {\n    CURRENT_TRACKER?.add(this);\n    return this._value;\n  }\n  // Whenever a storage value is updated, we bump the global revision clock,\n  // assign the revision for this storage to the new value, _and_ we schedule a\n  // rerender. This is important, and it's what makes autotracking  _pull_\n  // based. We don't actively tell the caches which depend on the storage that\n  // anything has happened. Instead, we recompute the caches when needed.\n  set value(newValue) {\n    if (this.value === newValue)\n      return;\n    this._value = newValue;\n    this.revision = ++$REVISION;\n  }\n};\nfunction tripleEq(a, b) {\n  return a === b;\n}\nvar TrackingCache = class {\n  _cachedValue;\n  _cachedRevision = -1;\n  _deps = [];\n  hits = 0;\n  fn;\n  constructor(fn) {\n    this.fn = fn;\n  }\n  clear() {\n    this._cachedValue = void 0;\n    this._cachedRevision = -1;\n    this._deps = [];\n    this.hits = 0;\n  }\n  get value() {\n    if (this.revision > this._cachedRevision) {\n      const { fn } = this;\n      const currentTracker = /* @__PURE__ */ new Set();\n      const prevTracker = CURRENT_TRACKER;\n      CURRENT_TRACKER = currentTracker;\n      this._cachedValue = fn();\n      CURRENT_TRACKER = prevTracker;\n      this.hits++;\n      this._deps = Array.from(currentTracker);\n      this._cachedRevision = this.revision;\n    }\n    CURRENT_TRACKER?.add(this);\n    return this._cachedValue;\n  }\n  get revision() {\n    return Math.max(...this._deps.map((d) => d.revision), 0);\n  }\n};\nfunction getValue(cell) {\n  if (!(cell instanceof Cell)) {\n    console.warn(\"Not a valid cell! \", cell);\n  }\n  return cell.value;\n}\nfunction setValue(storage, value) {\n  if (!(storage instanceof Cell)) {\n    throw new TypeError(\n      \"setValue must be passed a tracked store created with `createStorage`.\"\n    );\n  }\n  storage.value = storage._lastValue = value;\n}\nfunction createCell(initialValue, isEqual = tripleEq) {\n  return new Cell(initialValue, isEqual);\n}\nfunction createCache(fn) {\n  assertIsFunction(\n    fn,\n    \"the first parameter to `createCache` must be a function\"\n  );\n  return new TrackingCache(fn);\n}\n\n// src/autotrackMemoize/tracking.ts\nvar neverEq = (a, b) => false;\nfunction createTag() {\n  return createCell(null, neverEq);\n}\nfunction dirtyTag(tag, value) {\n  setValue(tag, value);\n}\nvar consumeCollection = (node) => {\n  let tag = node.collectionTag;\n  if (tag === null) {\n    tag = node.collectionTag = createTag();\n  }\n  getValue(tag);\n};\nvar dirtyCollection = (node) => {\n  const tag = node.collectionTag;\n  if (tag !== null) {\n    dirtyTag(tag, null);\n  }\n};\n\n// src/autotrackMemoize/proxy.ts\nvar REDUX_PROXY_LABEL = Symbol();\nvar nextId = 0;\nvar proto = Object.getPrototypeOf({});\nvar ObjectTreeNode = class {\n  constructor(value) {\n    this.value = value;\n    this.value = value;\n    this.tag.value = value;\n  }\n  proxy = new Proxy(this, objectProxyHandler);\n  tag = createTag();\n  tags = {};\n  children = {};\n  collectionTag = null;\n  id = nextId++;\n};\nvar objectProxyHandler = {\n  get(node, key) {\n    function calculateResult() {\n      const { value } = node;\n      const childValue = Reflect.get(value, key);\n      if (typeof key === \"symbol\") {\n        return childValue;\n      }\n      if (key in proto) {\n        return childValue;\n      }\n      if (typeof childValue === \"object\" && childValue !== null) {\n        let childNode = node.children[key];\n        if (childNode === void 0) {\n          childNode = node.children[key] = createNode(childValue);\n        }\n        if (childNode.tag) {\n          getValue(childNode.tag);\n        }\n        return childNode.proxy;\n      } else {\n        let tag = node.tags[key];\n        if (tag === void 0) {\n          tag = node.tags[key] = createTag();\n          tag.value = childValue;\n        }\n        getValue(tag);\n        return childValue;\n      }\n    }\n    const res = calculateResult();\n    return res;\n  },\n  ownKeys(node) {\n    consumeCollection(node);\n    return Reflect.ownKeys(node.value);\n  },\n  getOwnPropertyDescriptor(node, prop) {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop);\n  },\n  has(node, prop) {\n    return Reflect.has(node.value, prop);\n  }\n};\nvar ArrayTreeNode = class {\n  constructor(value) {\n    this.value = value;\n    this.value = value;\n    this.tag.value = value;\n  }\n  proxy = new Proxy([this], arrayProxyHandler);\n  tag = createTag();\n  tags = {};\n  children = {};\n  collectionTag = null;\n  id = nextId++;\n};\nvar arrayProxyHandler = {\n  get([node], key) {\n    if (key === \"length\") {\n      consumeCollection(node);\n    }\n    return objectProxyHandler.get(node, key);\n  },\n  ownKeys([node]) {\n    return objectProxyHandler.ownKeys(node);\n  },\n  getOwnPropertyDescriptor([node], prop) {\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n  },\n  has([node], prop) {\n    return objectProxyHandler.has(node, prop);\n  }\n};\nfunction createNode(value) {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value);\n  }\n  return new ObjectTreeNode(value);\n}\nfunction updateNode(node, newValue) {\n  const { value, tags, children } = node;\n  node.value = newValue;\n  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n    dirtyCollection(node);\n  } else {\n    if (value !== newValue) {\n      let oldKeysSize = 0;\n      let newKeysSize = 0;\n      let anyKeysAdded = false;\n      for (const _key in value) {\n        oldKeysSize++;\n      }\n      for (const key in newValue) {\n        newKeysSize++;\n        if (!(key in value)) {\n          anyKeysAdded = true;\n          break;\n        }\n      }\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n      if (isDifferent) {\n        dirtyCollection(node);\n      }\n    }\n  }\n  for (const key in tags) {\n    const childValue = value[key];\n    const newChildValue = newValue[key];\n    if (childValue !== newChildValue) {\n      dirtyCollection(node);\n      dirtyTag(tags[key], newChildValue);\n    }\n    if (typeof newChildValue === \"object\" && newChildValue !== null) {\n      delete tags[key];\n    }\n  }\n  for (const key in children) {\n    const childNode = children[key];\n    const newChildValue = newValue[key];\n    const childValue = childNode.value;\n    if (childValue === newChildValue) {\n      continue;\n    } else if (typeof newChildValue === \"object\" && newChildValue !== null) {\n      updateNode(childNode, newChildValue);\n    } else {\n      deleteNode(childNode);\n      delete children[key];\n    }\n  }\n}\nfunction deleteNode(node) {\n  if (node.tag) {\n    dirtyTag(node.tag, null);\n  }\n  dirtyCollection(node);\n  for (const key in node.tags) {\n    dirtyTag(node.tags[key], null);\n  }\n  for (const key in node.children) {\n    deleteNode(node.children[key]);\n  }\n}\n\n// src/lruMemoize.ts\nfunction createSingletonCache(equals) {\n  let entry;\n  return {\n    get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n      return NOT_FOUND;\n    },\n    put(key, value) {\n      entry = { key, value };\n    },\n    getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear() {\n      entry = void 0;\n    }\n  };\n}\nfunction createLruCache(maxSize, equals) {\n  let entries = [];\n  function get(key) {\n    const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));\n    if (cacheIndex > -1) {\n      const entry = entries[cacheIndex];\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n      return entry.value;\n    }\n    return NOT_FOUND;\n  }\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      entries.unshift({ key, value });\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n  function getEntries() {\n    return entries;\n  }\n  function clear() {\n    entries = [];\n  }\n  return { get, put, getEntries, clear };\n}\nvar referenceEqualityCheck = (a, b) => a === b;\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    }\n    const { length } = prev;\n    for (let i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\nfunction lruMemoize(func, equalityCheckOrOptions) {\n  const providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : { equalityCheck: equalityCheckOrOptions };\n  const {\n    equalityCheck = referenceEqualityCheck,\n    maxSize = 1,\n    resultEqualityCheck\n  } = providedOptions;\n  const comparator = createCacheKeyComparator(equalityCheck);\n  let resultsCount = 0;\n  const cache = maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n  function memoized() {\n    let value = cache.get(arguments);\n    if (value === NOT_FOUND) {\n      value = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        const entries = cache.getEntries();\n        const matchingEntry = entries.find(\n          (entry) => resultEqualityCheck(entry.value, value)\n        );\n        if (matchingEntry) {\n          value = matchingEntry.value;\n          resultsCount !== 0 && resultsCount--;\n        }\n      }\n      cache.put(arguments, value);\n    }\n    return value;\n  }\n  memoized.clearCache = () => {\n    cache.clear();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = () => resultsCount;\n  memoized.resetResultsCount = () => {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/autotrackMemoize/autotrackMemoize.ts\nfunction autotrackMemoize(func) {\n  const node = createNode(\n    []\n  );\n  let lastArgs = null;\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n  const cache = createCache(() => {\n    const res = func.apply(null, node.proxy);\n    return res;\n  });\n  function memoized() {\n    if (!shallowEqual(lastArgs, arguments)) {\n      updateNode(node, arguments);\n      lastArgs = arguments;\n    }\n    return cache.value;\n  }\n  memoized.clearCache = () => {\n    return cache.clear();\n  };\n  return memoized;\n}\n\n// src/weakMapMemoize.ts\nvar StrongRef = class {\n  constructor(value) {\n    this.value = value;\n  }\n  deref() {\n    return this.value;\n  }\n};\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\nvar UNTERMINATED = 0;\nvar TERMINATED = 1;\nfunction createCacheNode() {\n  return {\n    s: UNTERMINATED,\n    v: void 0,\n    o: null,\n    p: null\n  };\n}\nfunction weakMapMemoize(func, options = {}) {\n  let fnNode = createCacheNode();\n  const { resultEqualityCheck } = options;\n  let lastResult;\n  let resultsCount = 0;\n  function memoized() {\n    let cacheNode = fnNode;\n    const { length } = arguments;\n    for (let i = 0, l = length; i < l; i++) {\n      const arg = arguments[i];\n      if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n        let objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();\n        }\n        const objectNode = objectCache.get(arg);\n        if (objectNode === void 0) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        let primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();\n        }\n        const primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === void 0) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    const terminatedNode = cacheNode;\n    let result;\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v;\n    } else {\n      result = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        const lastResultValue = lastResult?.deref?.() ?? lastResult;\n        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n          result = lastResultValue;\n          resultsCount !== 0 && resultsCount--;\n        }\n        const needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\n        lastResult = needsWeakRef ? new Ref(result) : result;\n      }\n    }\n    terminatedNode.s = TERMINATED;\n    terminatedNode.v = result;\n    return result;\n  }\n  memoized.clearCache = () => {\n    fnNode = createCacheNode();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = () => resultsCount;\n  memoized.resetResultsCount = () => {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/createSelectorCreator.ts\nfunction createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {\n  const createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n    memoize: memoizeOrOptions,\n    memoizeOptions: memoizeOptionsFromArgs\n  } : memoizeOrOptions;\n  const createSelector2 = (...createSelectorArgs) => {\n    let recomputations = 0;\n    let dependencyRecomputations = 0;\n    let lastResult;\n    let directlyPassedOptions = {};\n    let resultFunc = createSelectorArgs.pop();\n    if (typeof resultFunc === \"object\") {\n      directlyPassedOptions = resultFunc;\n      resultFunc = createSelectorArgs.pop();\n    }\n    assertIsFunction(\n      resultFunc,\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\n    );\n    const combinedOptions = {\n      ...createSelectorCreatorOptions,\n      ...directlyPassedOptions\n    };\n    const {\n      memoize,\n      memoizeOptions = [],\n      argsMemoize = weakMapMemoize,\n      argsMemoizeOptions = [],\n      devModeChecks = {}\n    } = combinedOptions;\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions);\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n    const dependencies = getDependencies(createSelectorArgs);\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\n      recomputations++;\n      return resultFunc.apply(\n        null,\n        arguments\n      );\n    }, ...finalMemoizeOptions);\n    let firstRun = true;\n    const selector = argsMemoize(function dependenciesChecker() {\n      dependencyRecomputations++;\n      const inputSelectorResults = collectInputSelectorResults(\n        dependencies,\n        arguments\n      );\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);\n      if (true) {\n        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(\n            resultFunc,\n            inputSelectorResults,\n            lastResult\n          );\n        }\n        if (inputStabilityCheck.shouldRun) {\n          const inputSelectorResultsCopy = collectInputSelectorResults(\n            dependencies,\n            arguments\n          );\n          inputStabilityCheck.run(\n            { inputSelectorResults, inputSelectorResultsCopy },\n            { memoize, memoizeOptions: finalMemoizeOptions },\n            arguments\n          );\n        }\n        if (firstRun)\n          firstRun = false;\n      }\n      return lastResult;\n    }, ...finalArgsMemoizeOptions);\n    return Object.assign(selector, {\n      resultFunc,\n      memoizedResultFunc,\n      dependencies,\n      dependencyRecomputations: () => dependencyRecomputations,\n      resetDependencyRecomputations: () => {\n        dependencyRecomputations = 0;\n      },\n      lastResult: () => lastResult,\n      recomputations: () => recomputations,\n      resetRecomputations: () => {\n        recomputations = 0;\n      },\n      memoize,\n      argsMemoize\n    });\n  };\n  Object.assign(createSelector2, {\n    withTypes: () => createSelector2\n  });\n  return createSelector2;\n}\nvar createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);\n\n// src/createStructuredSelector.ts\nvar createStructuredSelector = Object.assign(\n  (inputSelectorsObject, selectorCreator = createSelector) => {\n    assertIsObject(\n      inputSelectorsObject,\n      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`\n    );\n    const inputSelectorKeys = Object.keys(inputSelectorsObject);\n    const dependencies = inputSelectorKeys.map(\n      (key) => inputSelectorsObject[key]\n    );\n    const structuredSelector = selectorCreator(\n      dependencies,\n      (...inputSelectorResults) => {\n        return inputSelectorResults.reduce((composition, value, index) => {\n          composition[inputSelectorKeys[index]] = value;\n          return composition;\n        }, {});\n      }\n    );\n    return structuredSelector;\n  },\n  { withTypes: () => createStructuredSelector }\n);\n\n//# sourceMappingURL=reselect.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZGlzdC9yZXNlbGVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQyxVQUFVLGlEQUFpRDtBQUMzRCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0ZBQXdGLFlBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsY0FBYztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx1QkFBdUI7QUFDaEY7QUFDQSwyQkFBMkIsYUFBYSxHQUFHLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Ysa0JBQWtCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DLGdCQUFnQiw2Q0FBNkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdEQUFnRDtBQUM5RCxjQUFjLDhDQUE4QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCw0QkFBNEI7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJO0FBQ0o7QUFVRTtBQUNGIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXHJlc2VsZWN0XFxkaXN0XFxyZXNlbGVjdC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2Rldk1vZGVDaGVja3MvaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnRzXG52YXIgcnVuSWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gKHJlc3VsdEZ1bmMsIGlucHV0U2VsZWN0b3JzUmVzdWx0cywgb3V0cHV0U2VsZWN0b3JSZXN1bHQpID0+IHtcbiAgaWYgKGlucHV0U2VsZWN0b3JzUmVzdWx0cy5sZW5ndGggPT09IDEgJiYgaW5wdXRTZWxlY3RvcnNSZXN1bHRzWzBdID09PSBvdXRwdXRTZWxlY3RvclJlc3VsdCkge1xuICAgIGxldCBpc0lucHV0U2FtZUFzT3V0cHV0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVtcHR5T2JqZWN0ID0ge307XG4gICAgICBpZiAocmVzdWx0RnVuYyhlbXB0eU9iamVjdCkgPT09IGVtcHR5T2JqZWN0KVxuICAgICAgICBpc0lucHV0U2FtZUFzT3V0cHV0ID0gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgaWYgKGlzSW5wdXRTYW1lQXNPdXRwdXQpIHtcbiAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICA7XG4gICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJUaGUgcmVzdWx0IGZ1bmN0aW9uIHJldHVybmVkIGl0cyBvd24gaW5wdXRzIHdpdGhvdXQgbW9kaWZpY2F0aW9uLiBlLmdcXG5gY3JlYXRlU2VsZWN0b3IoW3N0YXRlID0+IHN0YXRlLnRvZG9zXSwgdG9kb3MgPT4gdG9kb3MpYFxcblRoaXMgY291bGQgbGVhZCB0byBpbmVmZmljaWVudCBtZW1vaXphdGlvbiBhbmQgdW5uZWNlc3NhcnkgcmUtcmVuZGVycy5cXG5FbnN1cmUgdHJhbnNmb3JtYXRpb24gbG9naWMgaXMgaW4gdGhlIHJlc3VsdCBmdW5jdGlvbiwgYW5kIGV4dHJhY3Rpb24gbG9naWMgaXMgaW4gdGhlIGlucHV0IHNlbGVjdG9ycy5cIixcbiAgICAgICAgeyBzdGFjayB9XG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Rldk1vZGVDaGVja3MvaW5wdXRTdGFiaWxpdHlDaGVjay50c1xudmFyIHJ1bklucHV0U3RhYmlsaXR5Q2hlY2sgPSAoaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3QsIG9wdGlvbnMsIGlucHV0U2VsZWN0b3JBcmdzKSA9PiB7XG4gIGNvbnN0IHsgbWVtb2l6ZSwgbWVtb2l6ZU9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgaW5wdXRTZWxlY3RvclJlc3VsdHMsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSB9ID0gaW5wdXRTZWxlY3RvclJlc3VsdHNPYmplY3Q7XG4gIGNvbnN0IGNyZWF0ZUFuRW1wdHlPYmplY3QgPSBtZW1vaXplKCgpID0+ICh7fSksIC4uLm1lbW9pemVPcHRpb25zKTtcbiAgY29uc3QgYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCA9IGNyZWF0ZUFuRW1wdHlPYmplY3QuYXBwbHkobnVsbCwgaW5wdXRTZWxlY3RvclJlc3VsdHMpID09PSBjcmVhdGVBbkVtcHR5T2JqZWN0LmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSk7XG4gIGlmICghYXJlSW5wdXRTZWxlY3RvclJlc3VsdHNFcXVhbCkge1xuICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgO1xuICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkFuIGlucHV0IHNlbGVjdG9yIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIHBhc3NlZCBzYW1lIGFyZ3VtZW50cy5cXG5UaGlzIG1lYW5zIHlvdXIgb3V0cHV0IHNlbGVjdG9yIHdpbGwgbGlrZWx5IHJ1biBtb3JlIGZyZXF1ZW50bHkgdGhhbiBpbnRlbmRlZC5cXG5Bdm9pZCByZXR1cm5pbmcgYSBuZXcgcmVmZXJlbmNlIGluc2lkZSB5b3VyIGlucHV0IHNlbGVjdG9yLCBlLmcuXFxuYGNyZWF0ZVNlbGVjdG9yKFtzdGF0ZSA9PiBzdGF0ZS50b2Rvcy5tYXAodG9kbyA9PiB0b2RvLmlkKV0sIHRvZG9JZHMgPT4gdG9kb0lkcy5sZW5ndGgpYFwiLFxuICAgICAge1xuICAgICAgICBhcmd1bWVudHM6IGlucHV0U2VsZWN0b3JBcmdzLFxuICAgICAgICBmaXJzdElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHMsXG4gICAgICAgIHNlY29uZElucHV0czogaW5wdXRTZWxlY3RvclJlc3VsdHNDb3B5LFxuICAgICAgICBzdGFja1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9kZXZNb2RlQ2hlY2tzL3NldEdsb2JhbERldk1vZGVDaGVja3MudHNcbnZhciBnbG9iYWxEZXZNb2RlQ2hlY2tzID0ge1xuICBpbnB1dFN0YWJpbGl0eUNoZWNrOiBcIm9uY2VcIixcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBcIm9uY2VcIlxufTtcbnZhciBzZXRHbG9iYWxEZXZNb2RlQ2hlY2tzID0gKGRldk1vZGVDaGVja3MpID0+IHtcbiAgT2JqZWN0LmFzc2lnbihnbG9iYWxEZXZNb2RlQ2hlY2tzLCBkZXZNb2RlQ2hlY2tzKTtcbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIE5PVF9GT1VORCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2woXCJOT1RfRk9VTkRcIik7XG5mdW5jdGlvbiBhc3NlcnRJc0Z1bmN0aW9uKGZ1bmMsIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIGZ1bmN9YCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0SXNPYmplY3Qob2JqZWN0LCBlcnJvck1lc3NhZ2UgPSBgZXhwZWN0ZWQgYW4gb2JqZWN0LCBpbnN0ZWFkIHJlY2VpdmVkICR7dHlwZW9mIG9iamVjdH1gKSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihlcnJvck1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoYXJyYXksIGVycm9yTWVzc2FnZSA9IGBleHBlY3RlZCBhbGwgaXRlbXMgdG8gYmUgZnVuY3Rpb25zLCBpbnN0ZWFkIHJlY2VpdmVkIHRoZSBmb2xsb3dpbmcgdHlwZXM6IGApIHtcbiAgaWYgKCFhcnJheS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBhcnJheS5tYXAoXG4gICAgICAoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiA/IGBmdW5jdGlvbiAke2l0ZW0ubmFtZSB8fCBcInVubmFtZWRcIn0oKWAgOiB0eXBlb2YgaXRlbVxuICAgICkuam9pbihcIiwgXCIpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfVske2l0ZW1UeXBlc31dYCk7XG4gIH1cbn1cbnZhciBlbnN1cmVJc0FycmF5ID0gKGl0ZW0pID0+IHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtIDogW2l0ZW1dO1xufTtcbmZ1bmN0aW9uIGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3MpIHtcbiAgY29uc3QgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShjcmVhdGVTZWxlY3RvckFyZ3NbMF0pID8gY3JlYXRlU2VsZWN0b3JBcmdzWzBdIDogY3JlYXRlU2VsZWN0b3JBcmdzO1xuICBhc3NlcnRJc0FycmF5T2ZGdW5jdGlvbnMoXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFsbCBpbnB1dC1zZWxlY3RvcnMgdG8gYmUgZnVuY3Rpb25zLCBidXQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogYFxuICApO1xuICByZXR1cm4gZGVwZW5kZW5jaWVzO1xufVxuZnVuY3Rpb24gY29sbGVjdElucHV0U2VsZWN0b3JSZXN1bHRzKGRlcGVuZGVuY2llcywgaW5wdXRTZWxlY3RvckFyZ3MpIHtcbiAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBbXTtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGRlcGVuZGVuY2llcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlucHV0U2VsZWN0b3JSZXN1bHRzLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGlucHV0U2VsZWN0b3JBcmdzKSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0U2VsZWN0b3JSZXN1bHRzO1xufVxudmFyIGdldERldk1vZGVDaGVja3NFeGVjdXRpb25JbmZvID0gKGZpcnN0UnVuLCBkZXZNb2RlQ2hlY2tzKSA9PiB7XG4gIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPSB7XG4gICAgLi4uZ2xvYmFsRGV2TW9kZUNoZWNrcyxcbiAgICAuLi5kZXZNb2RlQ2hlY2tzXG4gIH07XG4gIHJldHVybiB7XG4gICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiB7XG4gICAgICBzaG91bGRSdW46IGlkZW50aXR5RnVuY3Rpb25DaGVjayA9PT0gXCJhbHdheXNcIiB8fCBpZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLFxuICAgICAgcnVuOiBydW5JZGVudGl0eUZ1bmN0aW9uQ2hlY2tcbiAgICB9LFxuICAgIGlucHV0U3RhYmlsaXR5Q2hlY2s6IHtcbiAgICAgIHNob3VsZFJ1bjogaW5wdXRTdGFiaWxpdHlDaGVjayA9PT0gXCJhbHdheXNcIiB8fCBpbnB1dFN0YWJpbGl0eUNoZWNrID09PSBcIm9uY2VcIiAmJiBmaXJzdFJ1bixcbiAgICAgIHJ1bjogcnVuSW5wdXRTdGFiaWxpdHlDaGVja1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9hdXRvdHJhY2tNZW1vaXplL2F1dG90cmFja2luZy50c1xudmFyICRSRVZJU0lPTiA9IDA7XG52YXIgQ1VSUkVOVF9UUkFDS0VSID0gbnVsbDtcbnZhciBDZWxsID0gY2xhc3Mge1xuICByZXZpc2lvbiA9ICRSRVZJU0lPTjtcbiAgX3ZhbHVlO1xuICBfbGFzdFZhbHVlO1xuICBfaXNFcXVhbCA9IHRyaXBsZUVxO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmFsdWUsIGlzRXF1YWwgPSB0cmlwbGVFcSkge1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fbGFzdFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIHRoaXMuX2lzRXF1YWwgPSBpc0VxdWFsO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyByZWFkLCBpdCdsbCBhZGQgaXRzZWxmIHRvIHRoZSBjdXJyZW50IHRyYWNrZXIgaWZcbiAgLy8gb25lIGV4aXN0cywgZW50YW5nbGluZyBpdHMgc3RhdGUgd2l0aCB0aGF0IGNhY2hlLlxuICBnZXQgdmFsdWUoKSB7XG4gICAgQ1VSUkVOVF9UUkFDS0VSPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIC8vIFdoZW5ldmVyIGEgc3RvcmFnZSB2YWx1ZSBpcyB1cGRhdGVkLCB3ZSBidW1wIHRoZSBnbG9iYWwgcmV2aXNpb24gY2xvY2ssXG4gIC8vIGFzc2lnbiB0aGUgcmV2aXNpb24gZm9yIHRoaXMgc3RvcmFnZSB0byB0aGUgbmV3IHZhbHVlLCBfYW5kXyB3ZSBzY2hlZHVsZSBhXG4gIC8vIHJlcmVuZGVyLiBUaGlzIGlzIGltcG9ydGFudCwgYW5kIGl0J3Mgd2hhdCBtYWtlcyBhdXRvdHJhY2tpbmcgIF9wdWxsX1xuICAvLyBiYXNlZC4gV2UgZG9uJ3QgYWN0aXZlbHkgdGVsbCB0aGUgY2FjaGVzIHdoaWNoIGRlcGVuZCBvbiB0aGUgc3RvcmFnZSB0aGF0XG4gIC8vIGFueXRoaW5nIGhhcyBoYXBwZW5lZC4gSW5zdGVhZCwgd2UgcmVjb21wdXRlIHRoZSBjYWNoZXMgd2hlbiBuZWVkZWQuXG4gIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLnZhbHVlID09PSBuZXdWYWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucmV2aXNpb24gPSArKyRSRVZJU0lPTjtcbiAgfVxufTtcbmZ1bmN0aW9uIHRyaXBsZUVxKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG52YXIgVHJhY2tpbmdDYWNoZSA9IGNsYXNzIHtcbiAgX2NhY2hlZFZhbHVlO1xuICBfY2FjaGVkUmV2aXNpb24gPSAtMTtcbiAgX2RlcHMgPSBbXTtcbiAgaGl0cyA9IDA7XG4gIGZuO1xuICBjb25zdHJ1Y3Rvcihmbikge1xuICAgIHRoaXMuZm4gPSBmbjtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9jYWNoZWRWYWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IC0xO1xuICAgIHRoaXMuX2RlcHMgPSBbXTtcbiAgICB0aGlzLmhpdHMgPSAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5yZXZpc2lvbiA+IHRoaXMuX2NhY2hlZFJldmlzaW9uKSB7XG4gICAgICBjb25zdCB7IGZuIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY3VycmVudFRyYWNrZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgY29uc3QgcHJldlRyYWNrZXIgPSBDVVJSRU5UX1RSQUNLRVI7XG4gICAgICBDVVJSRU5UX1RSQUNLRVIgPSBjdXJyZW50VHJhY2tlcjtcbiAgICAgIHRoaXMuX2NhY2hlZFZhbHVlID0gZm4oKTtcbiAgICAgIENVUlJFTlRfVFJBQ0tFUiA9IHByZXZUcmFja2VyO1xuICAgICAgdGhpcy5oaXRzKys7XG4gICAgICB0aGlzLl9kZXBzID0gQXJyYXkuZnJvbShjdXJyZW50VHJhY2tlcik7XG4gICAgICB0aGlzLl9jYWNoZWRSZXZpc2lvbiA9IHRoaXMucmV2aXNpb247XG4gICAgfVxuICAgIENVUlJFTlRfVFJBQ0tFUj8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRWYWx1ZTtcbiAgfVxuICBnZXQgcmV2aXNpb24oKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuX2RlcHMubWFwKChkKSA9PiBkLnJldmlzaW9uKSwgMCk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRWYWx1ZShjZWxsKSB7XG4gIGlmICghKGNlbGwgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIGNvbnNvbGUud2FybihcIk5vdCBhIHZhbGlkIGNlbGwhIFwiLCBjZWxsKTtcbiAgfVxuICByZXR1cm4gY2VsbC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlKHN0b3JhZ2UsIHZhbHVlKSB7XG4gIGlmICghKHN0b3JhZ2UgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcInNldFZhbHVlIG11c3QgYmUgcGFzc2VkIGEgdHJhY2tlZCBzdG9yZSBjcmVhdGVkIHdpdGggYGNyZWF0ZVN0b3JhZ2VgLlwiXG4gICAgKTtcbiAgfVxuICBzdG9yYWdlLnZhbHVlID0gc3RvcmFnZS5fbGFzdFZhbHVlID0gdmFsdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxsKGluaXRpYWxWYWx1ZSwgaXNFcXVhbCA9IHRyaXBsZUVxKSB7XG4gIHJldHVybiBuZXcgQ2VsbChpbml0aWFsVmFsdWUsIGlzRXF1YWwpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoZm4pIHtcbiAgYXNzZXJ0SXNGdW5jdGlvbihcbiAgICBmbixcbiAgICBcInRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gYGNyZWF0ZUNhY2hlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIlxuICApO1xuICByZXR1cm4gbmV3IFRyYWNraW5nQ2FjaGUoZm4pO1xufVxuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS90cmFja2luZy50c1xudmFyIG5ldmVyRXEgPSAoYSwgYikgPT4gZmFsc2U7XG5mdW5jdGlvbiBjcmVhdGVUYWcoKSB7XG4gIHJldHVybiBjcmVhdGVDZWxsKG51bGwsIG5ldmVyRXEpO1xufVxuZnVuY3Rpb24gZGlydHlUYWcodGFnLCB2YWx1ZSkge1xuICBzZXRWYWx1ZSh0YWcsIHZhbHVlKTtcbn1cbnZhciBjb25zdW1lQ29sbGVjdGlvbiA9IChub2RlKSA9PiB7XG4gIGxldCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWc7XG4gIGlmICh0YWcgPT09IG51bGwpIHtcbiAgICB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWcgPSBjcmVhdGVUYWcoKTtcbiAgfVxuICBnZXRWYWx1ZSh0YWcpO1xufTtcbnZhciBkaXJ0eUNvbGxlY3Rpb24gPSAobm9kZSkgPT4ge1xuICBjb25zdCB0YWcgPSBub2RlLmNvbGxlY3Rpb25UYWc7XG4gIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICBkaXJ0eVRhZyh0YWcsIG51bGwpO1xuICB9XG59O1xuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS9wcm94eS50c1xudmFyIFJFRFVYX1BST1hZX0xBQkVMID0gU3ltYm9sKCk7XG52YXIgbmV4dElkID0gMDtcbnZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG52YXIgT2JqZWN0VHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHByb3h5ID0gbmV3IFByb3h5KHRoaXMsIG9iamVjdFByb3h5SGFuZGxlcik7XG4gIHRhZyA9IGNyZWF0ZVRhZygpO1xuICB0YWdzID0ge307XG4gIGNoaWxkcmVuID0ge307XG4gIGNvbGxlY3Rpb25UYWcgPSBudWxsO1xuICBpZCA9IG5leHRJZCsrO1xufTtcbnZhciBvYmplY3RQcm94eUhhbmRsZXIgPSB7XG4gIGdldChub2RlLCBrZXkpIHtcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVSZXN1bHQoKSB7XG4gICAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgICAgY29uc3QgY2hpbGRWYWx1ZSA9IFJlZmxlY3QuZ2V0KHZhbHVlLCBrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5IGluIHByb3RvKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIGNoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUuY2hpbGRyZW5ba2V5XTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltrZXldID0gY3JlYXRlTm9kZShjaGlsZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2RlLnRhZykge1xuICAgICAgICAgIGdldFZhbHVlKGNoaWxkTm9kZS50YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUucHJveHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGFnID0gbm9kZS50YWdzW2tleV07XG4gICAgICAgIGlmICh0YWcgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRhZyA9IG5vZGUudGFnc1trZXldID0gY3JlYXRlVGFnKCk7XG4gICAgICAgICAgdGFnLnZhbHVlID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRWYWx1ZSh0YWcpO1xuICAgICAgICByZXR1cm4gY2hpbGRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gY2FsY3VsYXRlUmVzdWx0KCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgb3duS2V5cyhub2RlKSB7XG4gICAgY29uc3VtZUNvbGxlY3Rpb24obm9kZSk7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhub2RlLnZhbHVlKTtcbiAgfSxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApIHtcbiAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS52YWx1ZSwgcHJvcCk7XG4gIH0sXG4gIGhhcyhub2RlLCBwcm9wKSB7XG4gICAgcmV0dXJuIFJlZmxlY3QuaGFzKG5vZGUudmFsdWUsIHByb3ApO1xuICB9XG59O1xudmFyIEFycmF5VHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnRhZy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHByb3h5ID0gbmV3IFByb3h5KFt0aGlzXSwgYXJyYXlQcm94eUhhbmRsZXIpO1xuICB0YWcgPSBjcmVhdGVUYWcoKTtcbiAgdGFncyA9IHt9O1xuICBjaGlsZHJlbiA9IHt9O1xuICBjb2xsZWN0aW9uVGFnID0gbnVsbDtcbiAgaWQgPSBuZXh0SWQrKztcbn07XG52YXIgYXJyYXlQcm94eUhhbmRsZXIgPSB7XG4gIGdldChbbm9kZV0sIGtleSkge1xuICAgIGlmIChrZXkgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgIGNvbnN1bWVDb2xsZWN0aW9uKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0UHJveHlIYW5kbGVyLmdldChub2RlLCBrZXkpO1xuICB9LFxuICBvd25LZXlzKFtub2RlXSkge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIub3duS2V5cyhub2RlKTtcbiAgfSxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFtub2RlXSwgcHJvcCkge1xuICAgIHJldHVybiBvYmplY3RQcm94eUhhbmRsZXIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUsIHByb3ApO1xuICB9LFxuICBoYXMoW25vZGVdLCBwcm9wKSB7XG4gICAgcmV0dXJuIG9iamVjdFByb3h5SGFuZGxlci5oYXMobm9kZSwgcHJvcCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgQXJyYXlUcmVlTm9kZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPYmplY3RUcmVlTm9kZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUsIG5ld1ZhbHVlKSB7XG4gIGNvbnN0IHsgdmFsdWUsIHRhZ3MsIGNoaWxkcmVuIH0gPSBub2RlO1xuICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KG5ld1ZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggIT09IG5ld1ZhbHVlLmxlbmd0aCkge1xuICAgIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBsZXQgb2xkS2V5c1NpemUgPSAwO1xuICAgICAgbGV0IG5ld0tleXNTaXplID0gMDtcbiAgICAgIGxldCBhbnlLZXlzQWRkZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgX2tleSBpbiB2YWx1ZSkge1xuICAgICAgICBvbGRLZXlzU2l6ZSsrO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgbmV3S2V5c1NpemUrKztcbiAgICAgICAgaWYgKCEoa2V5IGluIHZhbHVlKSkge1xuICAgICAgICAgIGFueUtleXNBZGRlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRGlmZmVyZW50ID0gYW55S2V5c0FkZGVkIHx8IG9sZEtleXNTaXplICE9PSBuZXdLZXlzU2l6ZTtcbiAgICAgIGlmIChpc0RpZmZlcmVudCkge1xuICAgICAgICBkaXJ0eUNvbGxlY3Rpb24obm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHRhZ3MpIHtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gdmFsdWVba2V5XTtcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcbiAgICBpZiAoY2hpbGRWYWx1ZSAhPT0gbmV3Q2hpbGRWYWx1ZSkge1xuICAgICAgZGlydHlDb2xsZWN0aW9uKG5vZGUpO1xuICAgICAgZGlydHlUYWcodGFnc1trZXldLCBuZXdDaGlsZFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSB0YWdzW2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5ba2V5XTtcbiAgICBjb25zdCBuZXdDaGlsZFZhbHVlID0gbmV3VmFsdWVba2V5XTtcbiAgICBjb25zdCBjaGlsZFZhbHVlID0gY2hpbGROb2RlLnZhbHVlO1xuICAgIGlmIChjaGlsZFZhbHVlID09PSBuZXdDaGlsZFZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDaGlsZFZhbHVlID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZU5vZGUoY2hpbGROb2RlLCBuZXdDaGlsZFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlTm9kZShjaGlsZE5vZGUpO1xuICAgICAgZGVsZXRlIGNoaWxkcmVuW2tleV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWxldGVOb2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUudGFnKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWcsIG51bGwpO1xuICB9XG4gIGRpcnR5Q29sbGVjdGlvbihub2RlKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9kZS50YWdzKSB7XG4gICAgZGlydHlUYWcobm9kZS50YWdzW2tleV0sIG51bGwpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUuY2hpbGRyZW4pIHtcbiAgICBkZWxldGVOb2RlKG5vZGUuY2hpbGRyZW5ba2V5XSk7XG4gIH1cbn1cblxuLy8gc3JjL2xydU1lbW9pemUudHNcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbkNhY2hlKGVxdWFscykge1xuICBsZXQgZW50cnk7XG4gIHJldHVybiB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgaWYgKGVudHJ5ICYmIGVxdWFscyhlbnRyeS5rZXksIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5PVF9GT1VORDtcbiAgICB9LFxuICAgIHB1dChrZXksIHZhbHVlKSB7XG4gICAgICBlbnRyeSA9IHsga2V5LCB2YWx1ZSB9O1xuICAgIH0sXG4gICAgZ2V0RW50cmllcygpIHtcbiAgICAgIHJldHVybiBlbnRyeSA/IFtlbnRyeV0gOiBbXTtcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgZW50cnkgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTHJ1Q2FjaGUobWF4U2l6ZSwgZXF1YWxzKSB7XG4gIGxldCBlbnRyaWVzID0gW107XG4gIGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBjb25zdCBjYWNoZUluZGV4ID0gZW50cmllcy5maW5kSW5kZXgoKGVudHJ5KSA9PiBlcXVhbHMoa2V5LCBlbnRyeS5rZXkpKTtcbiAgICBpZiAoY2FjaGVJbmRleCA+IC0xKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbY2FjaGVJbmRleF07XG4gICAgICBpZiAoY2FjaGVJbmRleCA+IDApIHtcbiAgICAgICAgZW50cmllcy5zcGxpY2UoY2FjaGVJbmRleCwgMSk7XG4gICAgICAgIGVudHJpZXMudW5zaGlmdChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT1RfRk9VTkQ7XG4gIH1cbiAgZnVuY3Rpb24gcHV0KGtleSwgdmFsdWUpIHtcbiAgICBpZiAoZ2V0KGtleSkgPT09IE5PVF9GT1VORCkge1xuICAgICAgZW50cmllcy51bnNoaWZ0KHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IG1heFNpemUpIHtcbiAgICAgICAgZW50cmllcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RW50cmllcygpIHtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBlbnRyaWVzID0gW107XG4gIH1cbiAgcmV0dXJuIHsgZ2V0LCBwdXQsIGdldEVudHJpZXMsIGNsZWFyIH07XG59XG52YXIgcmVmZXJlbmNlRXF1YWxpdHlDaGVjayA9IChhLCBiKSA9PiBhID09PSBiO1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKGVxdWFsaXR5Q2hlY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKHByZXYsIG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gcHJldjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWVxdWFsaXR5Q2hlY2socHJldltpXSwgbmV4dFtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGxydU1lbW9pemUoZnVuYywgZXF1YWxpdHlDaGVja09yT3B0aW9ucykge1xuICBjb25zdCBwcm92aWRlZE9wdGlvbnMgPSB0eXBlb2YgZXF1YWxpdHlDaGVja09yT3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgOiB7IGVxdWFsaXR5Q2hlY2s6IGVxdWFsaXR5Q2hlY2tPck9wdGlvbnMgfTtcbiAgY29uc3Qge1xuICAgIGVxdWFsaXR5Q2hlY2sgPSByZWZlcmVuY2VFcXVhbGl0eUNoZWNrLFxuICAgIG1heFNpemUgPSAxLFxuICAgIHJlc3VsdEVxdWFsaXR5Q2hlY2tcbiAgfSA9IHByb3ZpZGVkT3B0aW9ucztcbiAgY29uc3QgY29tcGFyYXRvciA9IGNyZWF0ZUNhY2hlS2V5Q29tcGFyYXRvcihlcXVhbGl0eUNoZWNrKTtcbiAgbGV0IHJlc3VsdHNDb3VudCA9IDA7XG4gIGNvbnN0IGNhY2hlID0gbWF4U2l6ZSA8PSAxID8gY3JlYXRlU2luZ2xldG9uQ2FjaGUoY29tcGFyYXRvcikgOiBjcmVhdGVMcnVDYWNoZShtYXhTaXplLCBjb21wYXJhdG9yKTtcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgbGV0IHZhbHVlID0gY2FjaGUuZ2V0KGFyZ3VtZW50cyk7XG4gICAgaWYgKHZhbHVlID09PSBOT1RfRk9VTkQpIHtcbiAgICAgIHZhbHVlID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgcmVzdWx0c0NvdW50Kys7XG4gICAgICBpZiAocmVzdWx0RXF1YWxpdHlDaGVjaykge1xuICAgICAgICBjb25zdCBlbnRyaWVzID0gY2FjaGUuZ2V0RW50cmllcygpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ0VudHJ5ID0gZW50cmllcy5maW5kKFxuICAgICAgICAgIChlbnRyeSkgPT4gcmVzdWx0RXF1YWxpdHlDaGVjayhlbnRyeS52YWx1ZSwgdmFsdWUpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXRjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgdmFsdWUgPSBtYXRjaGluZ0VudHJ5LnZhbHVlO1xuICAgICAgICAgIHJlc3VsdHNDb3VudCAhPT0gMCAmJiByZXN1bHRzQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FjaGUucHV0KGFyZ3VtZW50cywgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbWVtb2l6ZWQuY2xlYXJDYWNoZSA9ICgpID0+IHtcbiAgICBjYWNoZS5jbGVhcigpO1xuICAgIG1lbW9pemVkLnJlc2V0UmVzdWx0c0NvdW50KCk7XG4gIH07XG4gIG1lbW9pemVkLnJlc3VsdHNDb3VudCA9ICgpID0+IHJlc3VsdHNDb3VudDtcbiAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQgPSAoKSA9PiB7XG4gICAgcmVzdWx0c0NvdW50ID0gMDtcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBzcmMvYXV0b3RyYWNrTWVtb2l6ZS9hdXRvdHJhY2tNZW1vaXplLnRzXG5mdW5jdGlvbiBhdXRvdHJhY2tNZW1vaXplKGZ1bmMpIHtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZU5vZGUoXG4gICAgW11cbiAgKTtcbiAgbGV0IGxhc3RBcmdzID0gbnVsbDtcbiAgY29uc3Qgc2hhbGxvd0VxdWFsID0gY3JlYXRlQ2FjaGVLZXlDb21wYXJhdG9yKHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2spO1xuICBjb25zdCBjYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IHtcbiAgICBjb25zdCByZXMgPSBmdW5jLmFwcGx5KG51bGwsIG5vZGUucHJveHkpO1xuICAgIHJldHVybiByZXM7XG4gIH0pO1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICBpZiAoIXNoYWxsb3dFcXVhbChsYXN0QXJncywgYXJndW1lbnRzKSkge1xuICAgICAgdXBkYXRlTm9kZShub2RlLCBhcmd1bWVudHMpO1xuICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgfVxuICBtZW1vaXplZC5jbGVhckNhY2hlID0gKCkgPT4ge1xuICAgIHJldHVybiBjYWNoZS5jbGVhcigpO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIHNyYy93ZWFrTWFwTWVtb2l6ZS50c1xudmFyIFN0cm9uZ1JlZiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgZGVyZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn07XG52YXIgUmVmID0gdHlwZW9mIFdlYWtSZWYgIT09IFwidW5kZWZpbmVkXCIgPyBXZWFrUmVmIDogU3Ryb25nUmVmO1xudmFyIFVOVEVSTUlOQVRFRCA9IDA7XG52YXIgVEVSTUlOQVRFRCA9IDE7XG5mdW5jdGlvbiBjcmVhdGVDYWNoZU5vZGUoKSB7XG4gIHJldHVybiB7XG4gICAgczogVU5URVJNSU5BVEVELFxuICAgIHY6IHZvaWQgMCxcbiAgICBvOiBudWxsLFxuICAgIHA6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHdlYWtNYXBNZW1vaXplKGZ1bmMsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZm5Ob2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gIGNvbnN0IHsgcmVzdWx0RXF1YWxpdHlDaGVjayB9ID0gb3B0aW9ucztcbiAgbGV0IGxhc3RSZXN1bHQ7XG4gIGxldCByZXN1bHRzQ291bnQgPSAwO1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICBsZXQgY2FjaGVOb2RlID0gZm5Ob2RlO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhcmd1bWVudHM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIiAmJiBhcmcgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IG9iamVjdENhY2hlID0gY2FjaGVOb2RlLm87XG4gICAgICAgIGlmIChvYmplY3RDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhY2hlTm9kZS5vID0gb2JqZWN0Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3ROb2RlID0gb2JqZWN0Q2FjaGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChvYmplY3ROb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICAgICAgICBvYmplY3RDYWNoZS5zZXQoYXJnLCBjYWNoZU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IG9iamVjdE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcmltaXRpdmVDYWNoZSA9IGNhY2hlTm9kZS5wO1xuICAgICAgICBpZiAocHJpbWl0aXZlQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjYWNoZU5vZGUucCA9IHByaW1pdGl2ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmltaXRpdmVOb2RlID0gcHJpbWl0aXZlQ2FjaGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChwcmltaXRpdmVOb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjYWNoZU5vZGUgPSBjcmVhdGVDYWNoZU5vZGUoKTtcbiAgICAgICAgICBwcmltaXRpdmVDYWNoZS5zZXQoYXJnLCBjYWNoZU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlTm9kZSA9IHByaW1pdGl2ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRlZE5vZGUgPSBjYWNoZU5vZGU7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoY2FjaGVOb2RlLnMgPT09IFRFUk1JTkFURUQpIHtcbiAgICAgIHJlc3VsdCA9IGNhY2hlTm9kZS52O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICByZXN1bHRzQ291bnQrKztcbiAgICAgIGlmIChyZXN1bHRFcXVhbGl0eUNoZWNrKSB7XG4gICAgICAgIGNvbnN0IGxhc3RSZXN1bHRWYWx1ZSA9IGxhc3RSZXN1bHQ/LmRlcmVmPy4oKSA/PyBsYXN0UmVzdWx0O1xuICAgICAgICBpZiAobGFzdFJlc3VsdFZhbHVlICE9IG51bGwgJiYgcmVzdWx0RXF1YWxpdHlDaGVjayhsYXN0UmVzdWx0VmFsdWUsIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBsYXN0UmVzdWx0VmFsdWU7XG4gICAgICAgICAgcmVzdWx0c0NvdW50ICE9PSAwICYmIHJlc3VsdHNDb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lZWRzV2Vha1JlZiA9IHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgcmVzdWx0ICE9PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgbGFzdFJlc3VsdCA9IG5lZWRzV2Vha1JlZiA/IG5ldyBSZWYocmVzdWx0KSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGVybWluYXRlZE5vZGUucyA9IFRFUk1JTkFURUQ7XG4gICAgdGVybWluYXRlZE5vZGUudiA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG1lbW9pemVkLmNsZWFyQ2FjaGUgPSAoKSA9PiB7XG4gICAgZm5Ob2RlID0gY3JlYXRlQ2FjaGVOb2RlKCk7XG4gICAgbWVtb2l6ZWQucmVzZXRSZXN1bHRzQ291bnQoKTtcbiAgfTtcbiAgbWVtb2l6ZWQucmVzdWx0c0NvdW50ID0gKCkgPT4gcmVzdWx0c0NvdW50O1xuICBtZW1vaXplZC5yZXNldFJlc3VsdHNDb3VudCA9ICgpID0+IHtcbiAgICByZXN1bHRzQ291bnQgPSAwO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIHNyYy9jcmVhdGVTZWxlY3RvckNyZWF0b3IudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcihtZW1vaXplT3JPcHRpb25zLCAuLi5tZW1vaXplT3B0aW9uc0Zyb21BcmdzKSB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvck9wdGlvbnMgPSB0eXBlb2YgbWVtb2l6ZU9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8ge1xuICAgIG1lbW9pemU6IG1lbW9pemVPck9wdGlvbnMsXG4gICAgbWVtb2l6ZU9wdGlvbnM6IG1lbW9pemVPcHRpb25zRnJvbUFyZ3NcbiAgfSA6IG1lbW9pemVPck9wdGlvbnM7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9ICguLi5jcmVhdGVTZWxlY3RvckFyZ3MpID0+IHtcbiAgICBsZXQgcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgIGxldCBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnMgPSAwO1xuICAgIGxldCBsYXN0UmVzdWx0O1xuICAgIGxldCBkaXJlY3RseVBhc3NlZE9wdGlvbnMgPSB7fTtcbiAgICBsZXQgcmVzdWx0RnVuYyA9IGNyZWF0ZVNlbGVjdG9yQXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdEZ1bmMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGRpcmVjdGx5UGFzc2VkT3B0aW9ucyA9IHJlc3VsdEZ1bmM7XG4gICAgICByZXN1bHRGdW5jID0gY3JlYXRlU2VsZWN0b3JBcmdzLnBvcCgpO1xuICAgIH1cbiAgICBhc3NlcnRJc0Z1bmN0aW9uKFxuICAgICAgcmVzdWx0RnVuYyxcbiAgICAgIGBjcmVhdGVTZWxlY3RvciBleHBlY3RzIGFuIG91dHB1dCBmdW5jdGlvbiBhZnRlciB0aGUgaW5wdXRzLCBidXQgcmVjZWl2ZWQ6IFske3R5cGVvZiByZXN1bHRGdW5jfV1gXG4gICAgKTtcbiAgICBjb25zdCBjb21iaW5lZE9wdGlvbnMgPSB7XG4gICAgICAuLi5jcmVhdGVTZWxlY3RvckNyZWF0b3JPcHRpb25zLFxuICAgICAgLi4uZGlyZWN0bHlQYXNzZWRPcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBtZW1vaXplLFxuICAgICAgbWVtb2l6ZU9wdGlvbnMgPSBbXSxcbiAgICAgIGFyZ3NNZW1vaXplID0gd2Vha01hcE1lbW9pemUsXG4gICAgICBhcmdzTWVtb2l6ZU9wdGlvbnMgPSBbXSxcbiAgICAgIGRldk1vZGVDaGVja3MgPSB7fVxuICAgIH0gPSBjb21iaW5lZE9wdGlvbnM7XG4gICAgY29uc3QgZmluYWxNZW1vaXplT3B0aW9ucyA9IGVuc3VyZUlzQXJyYXkobWVtb2l6ZU9wdGlvbnMpO1xuICAgIGNvbnN0IGZpbmFsQXJnc01lbW9pemVPcHRpb25zID0gZW5zdXJlSXNBcnJheShhcmdzTWVtb2l6ZU9wdGlvbnMpO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGdldERlcGVuZGVuY2llcyhjcmVhdGVTZWxlY3RvckFyZ3MpO1xuICAgIGNvbnN0IG1lbW9pemVkUmVzdWx0RnVuYyA9IG1lbW9pemUoZnVuY3Rpb24gcmVjb21wdXRhdGlvbldyYXBwZXIoKSB7XG4gICAgICByZWNvbXB1dGF0aW9ucysrO1xuICAgICAgcmV0dXJuIHJlc3VsdEZ1bmMuYXBwbHkoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgKTtcbiAgICB9LCAuLi5maW5hbE1lbW9pemVPcHRpb25zKTtcbiAgICBsZXQgZmlyc3RSdW4gPSB0cnVlO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYXJnc01lbW9pemUoZnVuY3Rpb24gZGVwZW5kZW5jaWVzQ2hlY2tlcigpIHtcbiAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucysrO1xuICAgICAgY29uc3QgaW5wdXRTZWxlY3RvclJlc3VsdHMgPSBjb2xsZWN0SW5wdXRTZWxlY3RvclJlc3VsdHMoXG4gICAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICAgYXJndW1lbnRzXG4gICAgICApO1xuICAgICAgbGFzdFJlc3VsdCA9IG1lbW9pemVkUmVzdWx0RnVuYy5hcHBseShudWxsLCBpbnB1dFNlbGVjdG9yUmVzdWx0cyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLCBpbnB1dFN0YWJpbGl0eUNoZWNrIH0gPSBnZXREZXZNb2RlQ2hlY2tzRXhlY3V0aW9uSW5mbyhmaXJzdFJ1biwgZGV2TW9kZUNoZWNrcyk7XG4gICAgICAgIGlmIChpZGVudGl0eUZ1bmN0aW9uQ2hlY2suc2hvdWxkUnVuKSB7XG4gICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrLnJ1bihcbiAgICAgICAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICAgICAgICBpbnB1dFNlbGVjdG9yUmVzdWx0cyxcbiAgICAgICAgICAgIGxhc3RSZXN1bHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dFN0YWJpbGl0eUNoZWNrLnNob3VsZFJ1bikge1xuICAgICAgICAgIGNvbnN0IGlucHV0U2VsZWN0b3JSZXN1bHRzQ29weSA9IGNvbGxlY3RJbnB1dFNlbGVjdG9yUmVzdWx0cyhcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgaW5wdXRTdGFiaWxpdHlDaGVjay5ydW4oXG4gICAgICAgICAgICB7IGlucHV0U2VsZWN0b3JSZXN1bHRzLCBpbnB1dFNlbGVjdG9yUmVzdWx0c0NvcHkgfSxcbiAgICAgICAgICAgIHsgbWVtb2l6ZSwgbWVtb2l6ZU9wdGlvbnM6IGZpbmFsTWVtb2l6ZU9wdGlvbnMgfSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0UnVuKVxuICAgICAgICAgIGZpcnN0UnVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9LCAuLi5maW5hbEFyZ3NNZW1vaXplT3B0aW9ucyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc2VsZWN0b3IsIHtcbiAgICAgIHJlc3VsdEZ1bmMsXG4gICAgICBtZW1vaXplZFJlc3VsdEZ1bmMsXG4gICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICBkZXBlbmRlbmN5UmVjb21wdXRhdGlvbnM6ICgpID0+IGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyxcbiAgICAgIHJlc2V0RGVwZW5kZW5jeVJlY29tcHV0YXRpb25zOiAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVuY3lSZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgICB9LFxuICAgICAgbGFzdFJlc3VsdDogKCkgPT4gbGFzdFJlc3VsdCxcbiAgICAgIHJlY29tcHV0YXRpb25zOiAoKSA9PiByZWNvbXB1dGF0aW9ucyxcbiAgICAgIHJlc2V0UmVjb21wdXRhdGlvbnM6ICgpID0+IHtcbiAgICAgICAgcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgICAgfSxcbiAgICAgIG1lbW9pemUsXG4gICAgICBhcmdzTWVtb2l6ZVxuICAgIH0pO1xuICB9O1xuICBPYmplY3QuYXNzaWduKGNyZWF0ZVNlbGVjdG9yMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlU2VsZWN0b3IyO1xufVxudmFyIGNyZWF0ZVNlbGVjdG9yID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9jcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IudHNcbnZhciBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgPSBPYmplY3QuYXNzaWduKFxuICAoaW5wdXRTZWxlY3RvcnNPYmplY3QsIHNlbGVjdG9yQ3JlYXRvciA9IGNyZWF0ZVNlbGVjdG9yKSA9PiB7XG4gICAgYXNzZXJ0SXNPYmplY3QoXG4gICAgICBpbnB1dFNlbGVjdG9yc09iamVjdCxcbiAgICAgIGBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgZXhwZWN0cyBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yLCBpbnN0ZWFkIHJlY2VpdmVkIGEgJHt0eXBlb2YgaW5wdXRTZWxlY3RvcnNPYmplY3R9YFxuICAgICk7XG4gICAgY29uc3QgaW5wdXRTZWxlY3RvcktleXMgPSBPYmplY3Qua2V5cyhpbnB1dFNlbGVjdG9yc09iamVjdCk7XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gaW5wdXRTZWxlY3RvcktleXMubWFwKFxuICAgICAgKGtleSkgPT4gaW5wdXRTZWxlY3RvcnNPYmplY3Rba2V5XVxuICAgICk7XG4gICAgY29uc3Qgc3RydWN0dXJlZFNlbGVjdG9yID0gc2VsZWN0b3JDcmVhdG9yKFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgKC4uLmlucHV0U2VsZWN0b3JSZXN1bHRzKSA9PiB7XG4gICAgICAgIHJldHVybiBpbnB1dFNlbGVjdG9yUmVzdWx0cy5yZWR1Y2UoKGNvbXBvc2l0aW9uLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb21wb3NpdGlvbltpbnB1dFNlbGVjdG9yS2V5c1tpbmRleF1dID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGNvbXBvc2l0aW9uO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gc3RydWN0dXJlZFNlbGVjdG9yO1xuICB9LFxuICB7IHdpdGhUeXBlczogKCkgPT4gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yIH1cbik7XG5leHBvcnQge1xuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IsXG4gIGxydU1lbW9pemUsXG4gIHJlZmVyZW5jZUVxdWFsaXR5Q2hlY2ssXG4gIHNldEdsb2JhbERldk1vZGVDaGVja3MsXG4gIGF1dG90cmFja01lbW9pemUgYXMgdW5zdGFibGVfYXV0b3RyYWNrTWVtb2l6ZSxcbiAgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNlbGVjdC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/reselect/dist/reselect.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = __webpack_require__(/*! react */ \"(pages-dir-browser)/../../node_modules/react/index.js\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = React.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0NBQXdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXG5vZGVfbW9kdWxlc1xcdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmVcXGNqc1xcdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAgIHJldHVybiAoeCA9PT0geSAmJiAoMCAhPT0geCB8fCAxIC8geCA9PT0gMSAvIHkpKSB8fCAoeCAhPT0geCAmJiB5ICE9PSB5KTtcbiAgICB9XG4gICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChFcnJvcigpKTtcbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIiksXG4gICAgICBvYmplY3RJcyA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IGlzLFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgICAgIHVzZVJlZiA9IFJlYWN0LnVzZVJlZixcbiAgICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG4gICAgZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvciA9IGZ1bmN0aW9uIChcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICBzZWxlY3RvcixcbiAgICAgIGlzRXF1YWxcbiAgICApIHtcbiAgICAgIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgICAgaWYgKG51bGwgPT09IGluc3RSZWYuY3VycmVudCkge1xuICAgICAgICB2YXIgaW5zdCA9IHsgaGFzVmFsdWU6ICExLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0O1xuICAgICAgfSBlbHNlIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gICAgICBpbnN0UmVmID0gdXNlTWVtbyhcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVkU2VsZWN0b3IobmV4dFNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoIWhhc01lbW8pIHtcbiAgICAgICAgICAgICAgaGFzTWVtbyA9ICEwO1xuICAgICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgICAgICAgICBuZXh0U25hcHNob3QgPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBpc0VxdWFsICYmIGluc3QuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwoY3VycmVudFNlbGVjdGlvbiwgbmV4dFNuYXBzaG90KSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiAobWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChvYmplY3RJcyhtZW1vaXplZFNuYXBzaG90LCBuZXh0U25hcHNob3QpKVxuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGlzRXF1YWwgJiYgaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgcmV0dXJuIChtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90KSwgY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICAgICAgICByZXR1cm4gKG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoYXNNZW1vID0gITEsXG4gICAgICAgICAgICBtZW1vaXplZFNuYXBzaG90LFxuICAgICAgICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICBtYXliZUdldFNlcnZlclNuYXBzaG90ID1cbiAgICAgICAgICAgICAgdm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsID09PSBtYXliZUdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICAgICAgID8gdm9pZCAwXG4gICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdXG4gICAgICApO1xuICAgICAgdmFyIHZhbHVlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBpbnN0UmVmWzBdLCBpbnN0UmVmWzFdKTtcbiAgICAgIHVzZUVmZmVjdChcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3QuaGFzVmFsdWUgPSAhMDtcbiAgICAgICAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFt2YWx1ZV1cbiAgICAgICk7XG4gICAgICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gJiZcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCAmJlxuICAgICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKEVycm9yKCkpO1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../../node_modules/use-sync-external-store/with-selector.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/with-selector.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/use-sync-external-store-with-selector.development.js */ \"(pages-dir-browser)/../../node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvd2l0aC1zZWxlY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsaU9BQXNGO0FBQ3hGIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxub2RlX21vZHVsZXNcXHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlXFx3aXRoLXNlbGVjdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../../node_modules/use-sync-external-store/with-selector.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MyApp)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-redux */ \"(pages-dir-browser)/../../node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _app_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/app/store */ \"(pages-dir-browser)/./src/app/store/index.ts\");\n/* harmony import */ var _app_globals_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/app/globals.css */ \"(pages-dir-browser)/./src/app/globals.css\");\n/* harmony import */ var _app_globals_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_app_globals_css__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_app_store__WEBPACK_IMPORTED_MODULE_1__]);\n_app_store__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* eslint-disable @conarti/feature-sliced/layers-slices */ \n\n\n\nfunction MyApp(param) {\n    let { Component, pageProps } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_redux__WEBPACK_IMPORTED_MODULE_3__.Provider, {\n                store: _app_store__WEBPACK_IMPORTED_MODULE_1__.store,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                    ...pageProps\n                }, void 0, false, {\n                    fileName: \"D:\\\\projects\\\\comment-atlatl\\\\apps\\\\web\\\\pages\\\\_app.tsx\",\n                    lineNumber: 11,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"D:\\\\projects\\\\comment-atlatl\\\\apps\\\\web\\\\pages\\\\_app.tsx\",\n                lineNumber: 10,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"script\", {\n                async: true,\n                src: \"https://cdn.jsdelivr.net/npm/@skyway-sdk/room/dist/skyway_room-latest.js\"\n            }, void 0, false, {\n                fileName: \"D:\\\\projects\\\\comment-atlatl\\\\apps\\\\web\\\\pages\\\\_app.tsx\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_c = MyApp;\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL19hcHAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLHdEQUF3RDtBQUVqQjtBQUNIO0FBQ1Q7QUFFWixTQUFTRSxNQUFNLEtBQWtDO1FBQWxDLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFZLEdBQWxDO0lBQzVCLHFCQUNFOzswQkFDRSw4REFBQ0osaURBQVFBO2dCQUFDQyxPQUFPQSw2Q0FBS0E7MEJBQ3BCLDRFQUFDRTtvQkFBVyxHQUFHQyxTQUFTOzs7Ozs7Ozs7OzswQkFFMUIsOERBQUNDO2dCQUNDQyxLQUFLO2dCQUNMQyxLQUFJOzs7Ozs7OztBQUlaO0tBWndCTCIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcYXBwc1xcd2ViXFxwYWdlc1xcX2FwcC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQGNvbmFydGkvZmVhdHVyZS1zbGljZWQvbGF5ZXJzLXNsaWNlcyAqL1xyXG5pbXBvcnQgeyBBcHBQcm9wcyB9IGZyb20gJ25leHQvYXBwJztcclxuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1yZWR1eCc7XHJcbmltcG9ydCB7IHN0b3JlIH0gZnJvbSAnQC9hcHAvc3RvcmUnO1xyXG5pbXBvcnQgJ0AvYXBwL2dsb2JhbHMuY3NzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE15QXBwKHsgQ29tcG9uZW50LCBwYWdlUHJvcHMgfTogQXBwUHJvcHMpIHtcclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgICAgPFByb3ZpZGVyIHN0b3JlPXtzdG9yZX0+XHJcbiAgICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxyXG4gICAgICA8L1Byb3ZpZGVyPlxyXG4gICAgICA8c2NyaXB0XHJcbiAgICAgICAgYXN5bmNcclxuICAgICAgICBzcmM9XCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0Bza3l3YXktc2RrL3Jvb20vZGlzdC9za3l3YXlfcm9vbS1sYXRlc3QuanNcIlxyXG4gICAgICA+PC9zY3JpcHQ+XHJcbiAgICA8Lz5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJQcm92aWRlciIsInN0b3JlIiwiTXlBcHAiLCJDb21wb25lbnQiLCJwYWdlUHJvcHMiLCJzY3JpcHQiLCJhc3luYyIsInNyYyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/_app.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./globals.css */ \"(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./src/app/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./globals.css */ \"(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./src/app/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./globals.css */ \"(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[13].oneOf[12].use[2]!./src/app/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLHFQQUFpSDtBQUNuSSwwQkFBMEIsbUJBQU8sQ0FBQyw4aEJBQXFROztBQUV2Uzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sOGhCQUFxUTtBQUMzUTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhoQkFBcVE7O0FBRS9SOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTNdLm9uZU9mWzEyXS51c2VbMV0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzEzXS5vbmVPZlsxMl0udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzEzXS5vbmVPZlsxMl0udXNlWzFdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxM10ub25lT2ZbMTJdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxM10ub25lT2ZbMTJdLnVzZVsxXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTNdLm9uZU9mWzEyXS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/app/store/index.ts":
/*!********************************!*\
  !*** ./src/app/store/index.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   store: () => (/* binding */ store)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _rootReducer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rootReducer */ \"(pages-dir-browser)/./src/app/store/rootReducer.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rootReducer__WEBPACK_IMPORTED_MODULE_0__]);\n_rootReducer__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\nconst store = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.configureStore)({\n    reducer: _rootReducer__WEBPACK_IMPORTED_MODULE_0__.rootReducer,\n    middleware: (getDefaultMiddleware)=>getDefaultMiddleware()\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9hcHAvc3RvcmUvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtEO0FBQ047QUFFckMsTUFBTUUsUUFBUUYsZ0VBQWNBLENBQUM7SUFDbENHLFNBQVNGLHFEQUFXQTtJQUNwQkcsWUFBWSxDQUFDQyx1QkFBeUJBO0FBQ3hDLEdBQUciLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXGFwcHNcXHdlYlxcc3JjXFxhcHBcXHN0b3JlXFxpbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWd1cmVTdG9yZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5pbXBvcnQgeyByb290UmVkdWNlciB9IGZyb20gJy4vcm9vdFJlZHVjZXInO1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0b3JlID0gY29uZmlndXJlU3RvcmUoe1xyXG4gIHJlZHVjZXI6IHJvb3RSZWR1Y2VyLFxyXG4gIG1pZGRsZXdhcmU6IChnZXREZWZhdWx0TWlkZGxld2FyZSkgPT4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUoKSxcclxufSk7XHJcblxyXG4vLyDku6XkuIvjga7vvJLjgaTjga7lnovjga9gdHlwZXMvYXBwLmQudHNg44KS57WM44Gm44CB5pqX6buZ55qE44GrIGBzaGFyZS9zdG9yZS9pbmRleC50c2Ag44Gq44Gp44Gn5Yip55So44GV44KM44KLIDogaHR0cHM6Ly9mZWF0dXJlLXNsaWNlZC5kZXNpZ24vZG9jcy9ndWlkZXMvZXhhbXBsZXMvdHlwZXNcclxuLyogc2FtZSBjb250ZW50IGFzIGluIHRoZSBjb2RlIGJsb2NrIGJlZm9yZeKApiAqL1xyXG4vLyB0c2NvbmZpZ+OBpyBzdHJpY3Q6IGZhbHNlIOOBq+OBmeOCi+OBqFJvb3RTdGF0ZeOBjGFueeOBq+OBquOCi1xyXG5leHBvcnQgdHlwZSBSb290U3RhdGUgPSBSZXR1cm5UeXBlPHR5cGVvZiBzdG9yZS5nZXRTdGF0ZT47XHJcbmV4cG9ydCB0eXBlIEFwcERpc3BhdGNoID0gdHlwZW9mIHN0b3JlLmRpc3BhdGNoO1xyXG4iXSwibmFtZXMiOlsiY29uZmlndXJlU3RvcmUiLCJyb290UmVkdWNlciIsInN0b3JlIiwicmVkdWNlciIsIm1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/app/store/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/app/store/rootReducer.ts":
/*!**************************************!*\
  !*** ./src/app/store/rootReducer.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rootReducer: () => (/* binding */ rootReducer)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var _entities_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/entities/graph */ \"(pages-dir-browser)/./src/entities/graph/index.ts\");\n/* harmony import */ var _entities_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/entities/message */ \"(pages-dir-browser)/./src/entities/message/index.ts\");\n/* harmony import */ var _entities_p2p__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/entities/p2p */ \"(pages-dir-browser)/./src/entities/p2p/index.ts\");\n/* harmony import */ var _entities_simulator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/entities/simulator */ \"(pages-dir-browser)/./src/entities/simulator/index.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_entities_simulator__WEBPACK_IMPORTED_MODULE_3__]);\n_entities_simulator__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\nconst combinedReducer = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_4__.combineReducers)({\n    [_entities_message__WEBPACK_IMPORTED_MODULE_1__.messageSlice.reducerPath]: _entities_message__WEBPACK_IMPORTED_MODULE_1__.messageSlice.reducer,\n    [_entities_simulator__WEBPACK_IMPORTED_MODULE_3__.simulatorSlice.reducerPath]: _entities_simulator__WEBPACK_IMPORTED_MODULE_3__.simulatorSlice.reducer,\n    [_entities_p2p__WEBPACK_IMPORTED_MODULE_2__.p2pSlice.reducerPath]: _entities_p2p__WEBPACK_IMPORTED_MODULE_2__.p2pSlice.reducer,\n    [_entities_graph__WEBPACK_IMPORTED_MODULE_0__.graphSlice.reducerPath]: _entities_graph__WEBPACK_IMPORTED_MODULE_0__.graphSlice.reducer\n});\nconst rootReducer = (state, action)=>{\n    return combinedReducer(state, action);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9hcHAvc3RvcmUvcm9vdFJlZHVjZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW1EO0FBQ0w7QUFDSTtBQUNSO0FBQ1k7QUFHdEQsTUFBTUssa0JBQWtCTCxpRUFBZUEsQ0FBQztJQUN0QyxDQUFDRSwyREFBWUEsQ0FBQ0ksV0FBVyxDQUFDLEVBQUVKLDJEQUFZQSxDQUFDSyxPQUFPO0lBQ2hELENBQUNILCtEQUFjQSxDQUFDRSxXQUFXLENBQUMsRUFBRUYsK0RBQWNBLENBQUNHLE9BQU87SUFDcEQsQ0FBQ0osbURBQVFBLENBQUNHLFdBQVcsQ0FBQyxFQUFFSCxtREFBUUEsQ0FBQ0ksT0FBTztJQUN4QyxDQUFDTix1REFBVUEsQ0FBQ0ssV0FBVyxDQUFDLEVBQUVMLHVEQUFVQSxDQUFDTSxPQUFPO0FBQzlDO0FBSU8sTUFBTUMsY0FBYyxDQUFDQyxPQUFrQ0M7SUFDNUQsT0FBT0wsZ0JBQWdCSSxPQUFPQztBQUNoQyxFQUFFIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcYXBwXFxzdG9yZVxccm9vdFJlZHVjZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XHJcbmltcG9ydCB7IGdyYXBoU2xpY2UgfSBmcm9tICdAL2VudGl0aWVzL2dyYXBoJztcclxuaW1wb3J0IHsgbWVzc2FnZVNsaWNlIH0gZnJvbSAnQC9lbnRpdGllcy9tZXNzYWdlJztcclxuaW1wb3J0IHsgcDJwU2xpY2UgfSBmcm9tICdAL2VudGl0aWVzL3AycCc7XHJcbmltcG9ydCB7IHNpbXVsYXRvclNsaWNlIH0gZnJvbSAnQC9lbnRpdGllcy9zaW11bGF0b3InO1xyXG5pbXBvcnQgdHlwZSB7IFVua25vd25BY3Rpb24gfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcclxuXHJcbmNvbnN0IGNvbWJpbmVkUmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XHJcbiAgW21lc3NhZ2VTbGljZS5yZWR1Y2VyUGF0aF06IG1lc3NhZ2VTbGljZS5yZWR1Y2VyLFxyXG4gIFtzaW11bGF0b3JTbGljZS5yZWR1Y2VyUGF0aF06IHNpbXVsYXRvclNsaWNlLnJlZHVjZXIsXHJcbiAgW3AycFNsaWNlLnJlZHVjZXJQYXRoXTogcDJwU2xpY2UucmVkdWNlcixcclxuICBbZ3JhcGhTbGljZS5yZWR1Y2VyUGF0aF06IGdyYXBoU2xpY2UucmVkdWNlcixcclxufSk7XHJcblxyXG50eXBlIENvbWJpbmVkU3RhdGUgPSBSZXR1cm5UeXBlPHR5cGVvZiBjb21iaW5lZFJlZHVjZXI+O1xyXG5cclxuZXhwb3J0IGNvbnN0IHJvb3RSZWR1Y2VyID0gKHN0YXRlOiBDb21iaW5lZFN0YXRlIHwgdW5kZWZpbmVkLCBhY3Rpb246IFVua25vd25BY3Rpb24pID0+IHtcclxuICByZXR1cm4gY29tYmluZWRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUm9vdFJlZHVjZXIgPSB0eXBlb2Ygcm9vdFJlZHVjZXI7XHJcbiJdLCJuYW1lcyI6WyJjb21iaW5lUmVkdWNlcnMiLCJncmFwaFNsaWNlIiwibWVzc2FnZVNsaWNlIiwicDJwU2xpY2UiLCJzaW11bGF0b3JTbGljZSIsImNvbWJpbmVkUmVkdWNlciIsInJlZHVjZXJQYXRoIiwicmVkdWNlciIsInJvb3RSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/app/store/rootReducer.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/graph/index.ts":
/*!*************************************!*\
  !*** ./src/entities/graph/index.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   graphSelector: () => (/* reexport safe */ _model_graphSlice__WEBPACK_IMPORTED_MODULE_0__.graphSelector),\n/* harmony export */   graphSlice: () => (/* reexport safe */ _model_graphSlice__WEBPACK_IMPORTED_MODULE_0__.graphSlice)\n/* harmony export */ });\n/* harmony import */ var _model_graphSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/graphSlice */ \"(pages-dir-browser)/./src/entities/graph/model/graphSlice.ts\");\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9ncmFwaC9pbmRleC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0QiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXGFwcHNcXHdlYlxcc3JjXFxlbnRpdGllc1xcZ3JhcGhcXGluZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGdyYXBoU2VsZWN0b3IsIGdyYXBoU2xpY2UgfSBmcm9tICcuL21vZGVsL2dyYXBoU2xpY2UnO1xyXG5leHBvcnQgdHlwZSB7IEdyYXBoRGF0YUZyb21LdXp1IH0gZnJvbSAnLi9tb2RlbC9ncmFwaFNsaWNlJztcclxuIl0sIm5hbWVzIjpbImdyYXBoU2VsZWN0b3IiLCJncmFwaFNsaWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/graph/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/graph/model/graphSlice.ts":
/*!************************************************!*\
  !*** ./src/entities/graph/model/graphSlice.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   graphSelector: () => (/* binding */ graphSelector),\n/* harmony export */   graphSlice: () => (/* binding */ graphSlice)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/reselect/dist/reselect.mjs\");\n\nconst initialState = {\n    graph: [],\n    selectedId: null\n};\nconst graphSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: 'graphState',\n    initialState,\n    reducers: {\n        setGraph: (state, action)=>{\n            state.graph = action.payload;\n        },\n        setSelectedId: (state, action)=>{\n            state.selectedId = action.payload;\n        }\n    }\n});\nconst stateSelector = (state)=>state[graphSlice.reducerPath];\nconst graphSelector = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSelector)(stateSelector, (c)=>{\n    return c.graph;\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9ncmFwaC9tb2RlbC9ncmFwaFNsaWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0Q7QUFrQi9ELE1BQU1FLGVBQXNCO0lBQzFCQyxPQUFPLEVBQUU7SUFDVEMsWUFBWTtBQUNkO0FBRU8sTUFBTUMsYUFBYUosNkRBQVdBLENBQUM7SUFDcENLLE1BQU07SUFDTko7SUFDQUssVUFBVTtRQUNSQyxVQUFVLENBQUNDLE9BQU9DO1lBQ2hCRCxNQUFNTixLQUFLLEdBQUdPLE9BQU9DLE9BQU87UUFDOUI7UUFDQUMsZUFBZSxDQUFDSCxPQUFPQztZQUNyQkQsTUFBTUwsVUFBVSxHQUFHTSxPQUFPQyxPQUFPO1FBQ25DO0lBQ0Y7QUFDRixHQUFHO0FBRUgsTUFBTUUsZ0JBQWdCLENBQUNKLFFBQXFCQSxLQUFLLENBQUNKLFdBQVdTLFdBQVcsQ0FBQztBQUVsRSxNQUFNQyxnQkFBZ0JmLGdFQUFjQSxDQUFDYSxlQUFlLENBQUNHO0lBQzFELE9BQU9BLEVBQUViLEtBQUs7QUFDaEIsR0FBRyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcYXBwc1xcd2ViXFxzcmNcXGVudGl0aWVzXFxncmFwaFxcbW9kZWxcXGdyYXBoU2xpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IsIGNyZWF0ZVNsaWNlIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XHJcbmltcG9ydCB0eXBlIHsgUGF5bG9hZEFjdGlvbiB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5cclxuZXhwb3J0IHR5cGUgR3JhcGhEYXRhRnJvbUt1enUgPSB7XHJcbiAgZGF0YToge1xyXG4gICAgaWQ/OiBzdHJpbmc7XHJcbiAgICBzb3VyY2U/OiBzdHJpbmc7XHJcbiAgICB0YXJnZXQ/OiBzdHJpbmc7XHJcbiAgICBsYWJlbD86IHN0cmluZztcclxuICAgIHR5cGU6IHN0cmluZztcclxuICAgIHBlZXJJZD86IHN0cmluZztcclxuICB9O1xyXG59O1xyXG5pbnRlcmZhY2UgU3RhdGUge1xyXG4gIGdyYXBoOiBHcmFwaERhdGFGcm9tS3V6dVtdO1xyXG4gIHNlbGVjdGVkSWQ6IHN0cmluZyB8IG51bGw7XHJcbn1cclxuXHJcbmNvbnN0IGluaXRpYWxTdGF0ZTogU3RhdGUgPSB7XHJcbiAgZ3JhcGg6IFtdLFxyXG4gIHNlbGVjdGVkSWQ6IG51bGwsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ3JhcGhTbGljZSA9IGNyZWF0ZVNsaWNlKHtcclxuICBuYW1lOiAnZ3JhcGhTdGF0ZScsXHJcbiAgaW5pdGlhbFN0YXRlLFxyXG4gIHJlZHVjZXJzOiB7XHJcbiAgICBzZXRHcmFwaDogKHN0YXRlLCBhY3Rpb246IFBheWxvYWRBY3Rpb248R3JhcGhEYXRhRnJvbUt1enVbXT4pID0+IHtcclxuICAgICAgc3RhdGUuZ3JhcGggPSBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH0sXHJcbiAgICBzZXRTZWxlY3RlZElkOiAoc3RhdGUsIGFjdGlvbjogUGF5bG9hZEFjdGlvbjxzdHJpbmcgfCBudWxsPikgPT4ge1xyXG4gICAgICBzdGF0ZS5zZWxlY3RlZElkID0gYWN0aW9uLnBheWxvYWQ7XHJcbiAgICB9LFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuY29uc3Qgc3RhdGVTZWxlY3RvciA9IChzdGF0ZTogUm9vdFN0YXRlKSA9PiBzdGF0ZVtncmFwaFNsaWNlLnJlZHVjZXJQYXRoXTtcclxuXHJcbmV4cG9ydCBjb25zdCBncmFwaFNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3Ioc3RhdGVTZWxlY3RvciwgKGMpID0+IHtcclxuICByZXR1cm4gYy5ncmFwaDtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVTZWxlY3RvciIsImNyZWF0ZVNsaWNlIiwiaW5pdGlhbFN0YXRlIiwiZ3JhcGgiLCJzZWxlY3RlZElkIiwiZ3JhcGhTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInNldEdyYXBoIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIiwic2V0U2VsZWN0ZWRJZCIsInN0YXRlU2VsZWN0b3IiLCJyZWR1Y2VyUGF0aCIsImdyYXBoU2VsZWN0b3IiLCJjIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/graph/model/graphSlice.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/message/index.ts":
/*!***************************************!*\
  !*** ./src/entities/message/index.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMessage: () => (/* reexport safe */ _model_messageSlice__WEBPACK_IMPORTED_MODULE_0__.addMessage),\n/* harmony export */   addMessages: () => (/* reexport safe */ _model_messageSlice__WEBPACK_IMPORTED_MODULE_0__.addMessages),\n/* harmony export */   deleteMessage: () => (/* reexport safe */ _model_messageSlice__WEBPACK_IMPORTED_MODULE_0__.deleteMessage),\n/* harmony export */   deleteMessages: () => (/* reexport safe */ _model_messageSlice__WEBPACK_IMPORTED_MODULE_0__.deleteMessages),\n/* harmony export */   messageSelector: () => (/* reexport safe */ _model_messageSelector__WEBPACK_IMPORTED_MODULE_1__.messageSelector),\n/* harmony export */   messageSlice: () => (/* reexport safe */ _model_messageSlice__WEBPACK_IMPORTED_MODULE_0__.messageSlice),\n/* harmony export */   updateMessage: () => (/* reexport safe */ _model_messageSlice__WEBPACK_IMPORTED_MODULE_0__.updateMessage)\n/* harmony export */ });\n/* harmony import */ var _model_messageSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/messageSlice */ \"(pages-dir-browser)/./src/entities/message/model/messageSlice.ts\");\n/* harmony import */ var _model_messageSelector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/messageSelector */ \"(pages-dir-browser)/./src/entities/message/model/messageSelector.ts\");\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9tZXNzYWdlL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQU84QjtBQUM0QiIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcYXBwc1xcd2ViXFxzcmNcXGVudGl0aWVzXFxtZXNzYWdlXFxpbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge1xyXG4gIG1lc3NhZ2VTbGljZSxcclxuICBhZGRNZXNzYWdlLFxyXG4gIGFkZE1lc3NhZ2VzLFxyXG4gIHVwZGF0ZU1lc3NhZ2UsXHJcbiAgZGVsZXRlTWVzc2FnZSxcclxuICBkZWxldGVNZXNzYWdlcyxcclxufSBmcm9tICcuL21vZGVsL21lc3NhZ2VTbGljZSc7XHJcbmV4cG9ydCB7IG1lc3NhZ2VTZWxlY3RvciB9IGZyb20gJy4vbW9kZWwvbWVzc2FnZVNlbGVjdG9yJztcclxuZXhwb3J0IHR5cGUgeyBNZXNzYWdlUGF5bGFkIH0gZnJvbSAnLi9tb2RlbC9tZXNzYWdlU2xpY2UnO1xyXG4iXSwibmFtZXMiOlsibWVzc2FnZVNsaWNlIiwiYWRkTWVzc2FnZSIsImFkZE1lc3NhZ2VzIiwidXBkYXRlTWVzc2FnZSIsImRlbGV0ZU1lc3NhZ2UiLCJkZWxldGVNZXNzYWdlcyIsIm1lc3NhZ2VTZWxlY3RvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/message/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/message/model/messageSelector.ts":
/*!*******************************************************!*\
  !*** ./src/entities/message/model/messageSelector.ts ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   messageSelector: () => (/* binding */ messageSelector)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/reselect/dist/reselect.mjs\");\n\nconst stateSelector = (state)=>state.message;\nconst messageSelector = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSelector)(stateSelector, (c)=>{\n    const ret = c.ids.map((id)=>c.entities[id]);\n    return ret;\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9tZXNzYWdlL21vZGVsL21lc3NhZ2VTZWxlY3Rvci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDtBQUVsRCxNQUFNQyxnQkFBZ0IsQ0FBQ0MsUUFBcUJBLE1BQU1DLE9BQU87QUFFbEQsTUFBTUMsa0JBQWtCSixnRUFBY0EsQ0FBQ0MsZUFBZSxDQUFDSTtJQUM1RCxNQUFNQyxNQUFNRCxFQUFFRSxHQUFHLENBQUNDLEdBQUcsQ0FBQyxDQUFDQyxLQUFPSixFQUFFSyxRQUFRLENBQUNELEdBQUc7SUFDNUMsT0FBT0g7QUFDVCxHQUFHIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXG1lc3NhZ2VcXG1vZGVsXFxtZXNzYWdlU2VsZWN0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcclxuXHJcbmNvbnN0IHN0YXRlU2VsZWN0b3IgPSAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gc3RhdGUubWVzc2FnZTtcclxuXHJcbmV4cG9ydCBjb25zdCBtZXNzYWdlU2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvcihzdGF0ZVNlbGVjdG9yLCAoYykgPT4ge1xyXG4gIGNvbnN0IHJldCA9IGMuaWRzLm1hcCgoaWQpID0+IGMuZW50aXRpZXNbaWRdKTtcclxuICByZXR1cm4gcmV0O1xyXG59KTtcclxuIl0sIm5hbWVzIjpbImNyZWF0ZVNlbGVjdG9yIiwic3RhdGVTZWxlY3RvciIsInN0YXRlIiwibWVzc2FnZSIsIm1lc3NhZ2VTZWxlY3RvciIsImMiLCJyZXQiLCJpZHMiLCJtYXAiLCJpZCIsImVudGl0aWVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/message/model/messageSelector.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/message/model/messageSlice.ts":
/*!****************************************************!*\
  !*** ./src/entities/message/model/messageSlice.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMessage: () => (/* binding */ addMessage),\n/* harmony export */   addMessages: () => (/* binding */ addMessages),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   deleteMessage: () => (/* binding */ deleteMessage),\n/* harmony export */   deleteMessages: () => (/* binding */ deleteMessages),\n/* harmony export */   messageAdapter: () => (/* binding */ messageAdapter),\n/* harmony export */   messageSlice: () => (/* binding */ messageSlice),\n/* harmony export */   updateMessage: () => (/* binding */ updateMessage)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n\n// メッセージエンティティアダプターを作成\nconst messageAdapter = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createEntityAdapter)({\n    selectId: (a)=>a.id,\n    // メッセージエンティティのソート基準としてtimestampを使用。降順\n    sortComparer: (a, b)=>b.timestamp.localeCompare(a.timestamp)\n});\n// 初期状態を設定\nconst initialState = messageAdapter.getInitialState();\n// メッセージスライスを作成\nconst messageSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: 'message',\n    initialState,\n    reducers: {\n        // メッセージを追加するためのアクション\n        addMessage: messageAdapter.addOne,\n        // メッセージを一括追加するためのアクション\n        addMessages: messageAdapter.addMany,\n        // メッセージを更新するためのアクション\n        updateMessage: messageAdapter.updateOne,\n        // メッセージを削除するためのアクション\n        deleteMessage: messageAdapter.removeOne,\n        // 複数のメッセージを削除するためのアクション\n        deleteMessages: messageAdapter.removeMany\n    }\n});\n// アクションクリエーターをエクスポート\nconst { addMessage, addMessages, updateMessage, deleteMessage, deleteMessages } = messageSlice.actions;\n// リデューサーをエクスポート\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (messageSlice.reducer);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9tZXNzYWdlL21vZGVsL21lc3NhZ2VTbGljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBb0U7QUFHcEUsc0JBQXNCO0FBQ2YsTUFBTUUsaUJBQWlCRCxxRUFBbUJBLENBQUM7SUFDaERFLFVBQVUsQ0FBQ0MsSUFBZUEsRUFBRUMsRUFBRTtJQUM5QixzQ0FBc0M7SUFDdENDLGNBQWMsQ0FBQ0YsR0FBR0csSUFBTUEsRUFBRUMsU0FBUyxDQUFDQyxhQUFhLENBQUNMLEVBQUVJLFNBQVM7QUFDL0QsR0FBRztBQUVILFVBQVU7QUFDVixNQUFNRSxlQUFlUixlQUFlUyxlQUFlO0FBRW5ELGVBQWU7QUFDUixNQUFNQyxlQUFlWiw2REFBV0EsQ0FBQztJQUN0Q2EsTUFBTTtJQUNOSDtJQUNBSSxVQUFVO1FBQ1IscUJBQXFCO1FBQ3JCQyxZQUFZYixlQUFlYyxNQUFNO1FBQ2pDLHVCQUF1QjtRQUN2QkMsYUFBYWYsZUFBZWdCLE9BQU87UUFDbkMscUJBQXFCO1FBQ3JCQyxlQUFlakIsZUFBZWtCLFNBQVM7UUFDdkMscUJBQXFCO1FBQ3JCQyxlQUFlbkIsZUFBZW9CLFNBQVM7UUFDdkMsd0JBQXdCO1FBQ3hCQyxnQkFBZ0JyQixlQUFlc0IsVUFBVTtJQUMzQztBQUNGLEdBQUc7QUFFSCxxQkFBcUI7QUFDZCxNQUFNLEVBQUVULFVBQVUsRUFBRUUsV0FBVyxFQUFFRSxhQUFhLEVBQUVFLGFBQWEsRUFBRUUsY0FBYyxFQUFFLEdBQ3BGWCxhQUFhYSxPQUFPLENBQUM7QUFFdkIsZ0JBQWdCO0FBQ2hCLGlFQUFlYixhQUFhYyxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXGFwcHNcXHdlYlxcc3JjXFxlbnRpdGllc1xcbWVzc2FnZVxcbW9kZWxcXG1lc3NhZ2VTbGljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSwgY3JlYXRlRW50aXR5QWRhcHRlciB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5leHBvcnQgdHlwZSBNZXNzYWdlID0geyB0aW1lc3RhbXA6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nOyBpZDogc3RyaW5nIH07XHJcbmV4cG9ydCB0eXBlIE1lc3NhZ2VQYXlsYWQgPSBNZXNzYWdlICYgeyBwZWVySWQ6IHN0cmluZzsgdG9Db21tZW50SWQ/OiBzdHJpbmcgfCBudWxsIH07XHJcbi8vIOODoeODg+OCu+ODvOOCuOOCqOODs+ODhuOCo+ODhuOCo+OCouODgOODl+OCv+ODvOOCkuS9nOaIkFxyXG5leHBvcnQgY29uc3QgbWVzc2FnZUFkYXB0ZXIgPSBjcmVhdGVFbnRpdHlBZGFwdGVyKHtcclxuICBzZWxlY3RJZDogKGE6IE1lc3NhZ2UpID0+IGEuaWQsXHJcbiAgLy8g44Oh44OD44K744O844K444Ko44Oz44OG44Kj44OG44Kj44Gu44K944O844OI5Z+65rqW44Go44GX44GmdGltZXN0YW1w44KS5L2/55So44CC6ZmN6aCGXHJcbiAgc29ydENvbXBhcmVyOiAoYSwgYikgPT4gYi50aW1lc3RhbXAubG9jYWxlQ29tcGFyZShhLnRpbWVzdGFtcCksXHJcbn0pO1xyXG5cclxuLy8g5Yid5pyf54q25oWL44KS6Kit5a6aXHJcbmNvbnN0IGluaXRpYWxTdGF0ZSA9IG1lc3NhZ2VBZGFwdGVyLmdldEluaXRpYWxTdGF0ZSgpO1xyXG5cclxuLy8g44Oh44OD44K744O844K444K544Op44Kk44K544KS5L2c5oiQXHJcbmV4cG9ydCBjb25zdCBtZXNzYWdlU2xpY2UgPSBjcmVhdGVTbGljZSh7XHJcbiAgbmFtZTogJ21lc3NhZ2UnLFxyXG4gIGluaXRpYWxTdGF0ZSxcclxuICByZWR1Y2Vyczoge1xyXG4gICAgLy8g44Oh44OD44K744O844K444KS6L+95Yqg44GZ44KL44Gf44KB44Gu44Ki44Kv44K344On44OzXHJcbiAgICBhZGRNZXNzYWdlOiBtZXNzYWdlQWRhcHRlci5hZGRPbmUsXHJcbiAgICAvLyDjg6Hjg4Pjgrvjg7zjgrjjgpLkuIDmi6zov73liqDjgZnjgovjgZ/jgoHjga7jgqLjgq/jgrfjg6fjg7NcclxuICAgIGFkZE1lc3NhZ2VzOiBtZXNzYWdlQWRhcHRlci5hZGRNYW55LFxyXG4gICAgLy8g44Oh44OD44K744O844K444KS5pu05paw44GZ44KL44Gf44KB44Gu44Ki44Kv44K344On44OzXHJcbiAgICB1cGRhdGVNZXNzYWdlOiBtZXNzYWdlQWRhcHRlci51cGRhdGVPbmUsXHJcbiAgICAvLyDjg6Hjg4Pjgrvjg7zjgrjjgpLliYrpmaTjgZnjgovjgZ/jgoHjga7jgqLjgq/jgrfjg6fjg7NcclxuICAgIGRlbGV0ZU1lc3NhZ2U6IG1lc3NhZ2VBZGFwdGVyLnJlbW92ZU9uZSxcclxuICAgIC8vIOikh+aVsOOBruODoeODg+OCu+ODvOOCuOOCkuWJiumZpOOBmeOCi+OBn+OCgeOBruOCouOCr+OCt+ODp+ODs1xyXG4gICAgZGVsZXRlTWVzc2FnZXM6IG1lc3NhZ2VBZGFwdGVyLnJlbW92ZU1hbnksXHJcbiAgfSxcclxufSk7XHJcblxyXG4vLyDjgqLjgq/jgrfjg6fjg7Pjgq/jg6rjgqjjg7zjgr/jg7zjgpLjgqjjgq/jgrnjg53jg7zjg4hcclxuZXhwb3J0IGNvbnN0IHsgYWRkTWVzc2FnZSwgYWRkTWVzc2FnZXMsIHVwZGF0ZU1lc3NhZ2UsIGRlbGV0ZU1lc3NhZ2UsIGRlbGV0ZU1lc3NhZ2VzIH0gPVxyXG4gIG1lc3NhZ2VTbGljZS5hY3Rpb25zO1xyXG5cclxuLy8g44Oq44OH44Ol44O844K144O844KS44Ko44Kv44K544Od44O844OIXHJcbmV4cG9ydCBkZWZhdWx0IG1lc3NhZ2VTbGljZS5yZWR1Y2VyO1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlU2xpY2UiLCJjcmVhdGVFbnRpdHlBZGFwdGVyIiwibWVzc2FnZUFkYXB0ZXIiLCJzZWxlY3RJZCIsImEiLCJpZCIsInNvcnRDb21wYXJlciIsImIiLCJ0aW1lc3RhbXAiLCJsb2NhbGVDb21wYXJlIiwiaW5pdGlhbFN0YXRlIiwiZ2V0SW5pdGlhbFN0YXRlIiwibWVzc2FnZVNsaWNlIiwibmFtZSIsInJlZHVjZXJzIiwiYWRkTWVzc2FnZSIsImFkZE9uZSIsImFkZE1lc3NhZ2VzIiwiYWRkTWFueSIsInVwZGF0ZU1lc3NhZ2UiLCJ1cGRhdGVPbmUiLCJkZWxldGVNZXNzYWdlIiwicmVtb3ZlT25lIiwiZGVsZXRlTWVzc2FnZXMiLCJyZW1vdmVNYW55IiwiYWN0aW9ucyIsInJlZHVjZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/message/model/messageSlice.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/p2p/index.ts":
/*!***********************************!*\
  !*** ./src/entities/p2p/index.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   joinRoom: () => (/* reexport safe */ _model_skyway_room__WEBPACK_IMPORTED_MODULE_1__.joinRoom),\n/* harmony export */   p2pSlice: () => (/* reexport safe */ _model_p2pSlice__WEBPACK_IMPORTED_MODULE_0__.p2pSlice),\n/* harmony export */   peerIdSelector: () => (/* reexport safe */ _model_p2pSlice__WEBPACK_IMPORTED_MODULE_0__.peerIdSelector),\n/* harmony export */   sendMessage: () => (/* reexport safe */ _model_skyway_repository__WEBPACK_IMPORTED_MODULE_2__.sendMessage)\n/* harmony export */ });\n/* harmony import */ var _model_p2pSlice__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/p2pSlice */ \"(pages-dir-browser)/./src/entities/p2p/model/p2pSlice.ts\");\n/* harmony import */ var _model_skyway_room__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/skyway/room */ \"(pages-dir-browser)/./src/entities/p2p/model/skyway/room.ts\");\n/* harmony import */ var _model_skyway_repository__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/skyway/repository */ \"(pages-dir-browser)/./src/entities/p2p/model/skyway/repository.ts\");\n\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9wMnAvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE0RDtBQUNiO0FBQ1MiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXGFwcHNcXHdlYlxcc3JjXFxlbnRpdGllc1xccDJwXFxpbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBwMnBTbGljZSwgcGVlcklkU2VsZWN0b3IgfSBmcm9tICcuL21vZGVsL3AycFNsaWNlJztcclxuZXhwb3J0IHsgam9pblJvb20gfSBmcm9tICcuL21vZGVsL3NreXdheS9yb29tJztcclxuZXhwb3J0IHsgc2VuZE1lc3NhZ2UgfSBmcm9tICcuL21vZGVsL3NreXdheS9yZXBvc2l0b3J5JztcclxuIl0sIm5hbWVzIjpbInAycFNsaWNlIiwicGVlcklkU2VsZWN0b3IiLCJqb2luUm9vbSIsInNlbmRNZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/p2p/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/p2p/model/p2pSlice.ts":
/*!********************************************!*\
  !*** ./src/entities/p2p/model/p2pSlice.ts ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p2pSlice: () => (/* binding */ p2pSlice),\n/* harmony export */   peerIdSelector: () => (/* binding */ peerIdSelector)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/reselect/dist/reselect.mjs\");\n\nconst initialState = {\n    peerId: ''\n};\nconst p2pSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: 'p2p',\n    initialState,\n    reducers: {\n        setPeerId: (state, action)=>{\n            state.peerId = action.payload;\n        }\n    }\n});\nconst stateSelector = (state)=>state[p2pSlice.reducerPath];\nconst peerIdSelector = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSelector)(stateSelector, (c)=>{\n    return c.peerId;\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9wMnAvbW9kZWwvcDJwU2xpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRDtBQU0vRCxNQUFNRSxlQUF5QjtJQUM3QkMsUUFBUTtBQUNWO0FBRU8sTUFBTUMsV0FBV0gsNkRBQVdBLENBQUM7SUFDbENJLE1BQU07SUFDTkg7SUFDQUksVUFBVTtRQUNSQyxXQUFXLENBQUNDLE9BQU9DO1lBQ2pCRCxNQUFNTCxNQUFNLEdBQUdNLE9BQU9DLE9BQU87UUFDL0I7SUFDRjtBQUNGLEdBQUc7QUFFSCxNQUFNQyxnQkFBZ0IsQ0FBQ0gsUUFBcUJBLEtBQUssQ0FBQ0osU0FBU1EsV0FBVyxDQUFDO0FBRWhFLE1BQU1DLGlCQUFpQmIsZ0VBQWNBLENBQUNXLGVBQWUsQ0FBQ0c7SUFDM0QsT0FBT0EsRUFBRVgsTUFBTTtBQUNqQixHQUFHIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHAycFxcbW9kZWxcXHAycFNsaWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTbGljZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5cclxuaW50ZXJmYWNlIFAyUFN0YXRlIHtcclxuICBwZWVySWQ6IHN0cmluZztcclxufVxyXG5cclxuY29uc3QgaW5pdGlhbFN0YXRlOiBQMlBTdGF0ZSA9IHtcclxuICBwZWVySWQ6ICcnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHAycFNsaWNlID0gY3JlYXRlU2xpY2Uoe1xyXG4gIG5hbWU6ICdwMnAnLFxyXG4gIGluaXRpYWxTdGF0ZSxcclxuICByZWR1Y2Vyczoge1xyXG4gICAgc2V0UGVlcklkOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xyXG4gICAgICBzdGF0ZS5wZWVySWQgPSBhY3Rpb24ucGF5bG9hZDtcclxuICAgIH0sXHJcbiAgfSxcclxufSk7XHJcblxyXG5jb25zdCBzdGF0ZVNlbGVjdG9yID0gKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlW3AycFNsaWNlLnJlZHVjZXJQYXRoXTtcclxuXHJcbmV4cG9ydCBjb25zdCBwZWVySWRTZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yKHN0YXRlU2VsZWN0b3IsIChjKSA9PiB7XHJcbiAgcmV0dXJuIGMucGVlcklkO1xyXG59KTtcclxuIl0sIm5hbWVzIjpbImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2xpY2UiLCJpbml0aWFsU3RhdGUiLCJwZWVySWQiLCJwMnBTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInNldFBlZXJJZCIsInN0YXRlIiwiYWN0aW9uIiwicGF5bG9hZCIsInN0YXRlU2VsZWN0b3IiLCJyZWR1Y2VyUGF0aCIsInBlZXJJZFNlbGVjdG9yIiwiYyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/p2p/model/p2pSlice.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/p2p/model/skyway/constants.ts":
/*!****************************************************!*\
  !*** ./src/entities/p2p/model/skyway/constants.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   authToken: () => (/* binding */ authToken),\n/* harmony export */   roomName: () => (/* binding */ roomName)\n/* harmony export */ });\nconst params = __webpack_require__.g.window == null ? undefined : new URLSearchParams(window.location.search);\nvar _params_get;\nconst roomName = (_params_get = params === null || params === void 0 ? void 0 : params.get('room')) !== null && _params_get !== void 0 ? _params_get : 'lt';\nvar _params_get1;\nconst authToken = (_params_get1 = params === null || params === void 0 ? void 0 : params.get('token')) !== null && _params_get1 !== void 0 ? _params_get1 : '';\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9wMnAvbW9kZWwvc2t5d2F5L2NvbnN0YW50cy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLE1BQU1BLFNBQVNDLHFCQUFNQSxDQUFDQyxNQUFNLElBQUksT0FBT0MsWUFBWSxJQUFJQyxnQkFBZ0JGLE9BQU9HLFFBQVEsQ0FBQ0MsTUFBTTtJQUNyRU47QUFBakIsTUFBTU8sV0FBV1AsQ0FBQUEsY0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRUSxHQUFHLENBQUMscUJBQVpSLHlCQUFBQSxjQUF1QixLQUFLO0lBQzNCQTtBQUFsQixNQUFNUyxZQUFZVCxDQUFBQSxlQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFRLEdBQUcsQ0FBQyxzQkFBWlIsMEJBQUFBLGVBQXdCLEdBQUciLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXGFwcHNcXHdlYlxcc3JjXFxlbnRpdGllc1xccDJwXFxtb2RlbFxcc2t5d2F5XFxjb25zdGFudHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGFyYW1zID0gZ2xvYmFsLndpbmRvdyA9PSBudWxsID8gdW5kZWZpbmVkIDogbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcclxuZXhwb3J0IGNvbnN0IHJvb21OYW1lID0gcGFyYW1zPy5nZXQoJ3Jvb20nKSA/PyAnbHQnO1xyXG5leHBvcnQgY29uc3QgYXV0aFRva2VuID0gcGFyYW1zPy5nZXQoJ3Rva2VuJykgPz8gJyc7XHJcbiJdLCJuYW1lcyI6WyJwYXJhbXMiLCJnbG9iYWwiLCJ3aW5kb3ciLCJ1bmRlZmluZWQiLCJVUkxTZWFyY2hQYXJhbXMiLCJsb2NhdGlvbiIsInNlYXJjaCIsInJvb21OYW1lIiwiZ2V0IiwiYXV0aFRva2VuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/p2p/model/skyway/constants.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/p2p/model/skyway/repository.ts":
/*!*****************************************************!*\
  !*** ./src/entities/p2p/model/skyway/repository.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDataStream: () => (/* binding */ getDataStream),\n/* harmony export */   sendMessage: () => (/* binding */ sendMessage),\n/* harmony export */   subscribeAndAttach: () => (/* binding */ subscribeAndAttach)\n/* harmony export */ });\nlet stream = null;\nconst getDataStream = async ()=>{\n    if (!window) return null;\n    const { SkyWayStreamFactory } = window.skyway_room;\n    if (stream) return stream;\n    stream = await SkyWayStreamFactory.createDataStream();\n    return stream;\n};\nconst sendMessage = async (message)=>{\n    const dataStream = await getDataStream();\n    if (!dataStream) return;\n    console.log('send message', message);\n    dataStream.write(message);\n};\nconst subscribeAndAttach = async (publication, me, handler)=>{\n    if (publication.publisher.id === me.id) return;\n    const { stream } = await me.subscribe(publication.id);\n    const dataStream = stream;\n    console.log('publication.publisher.id', publication.publisher.id);\n    dataStream.onData.add((data)=>{\n        console.log('receive data', data);\n        console.log('publisher.id', publication.publisher.id);\n        handler(data.toString());\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9wMnAvbW9kZWwvc2t5d2F5L3JlcG9zaXRvcnkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsSUFBSUEsU0FBaUM7QUFFOUIsTUFBTUMsZ0JBQWdCO0lBQzNCLElBQUksQ0FBQ0MsUUFBUSxPQUFPO0lBQ3BCLE1BQU0sRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0QsT0FBT0UsV0FBVztJQUNsRCxJQUFJSixRQUFRLE9BQU9BO0lBQ25CQSxTQUFTLE1BQU1HLG9CQUFvQkUsZ0JBQWdCO0lBQ25ELE9BQU9MO0FBQ1QsRUFBRTtBQUNLLE1BQU1NLGNBQWMsT0FBT0M7SUFDaEMsTUFBTUMsYUFBYSxNQUFNUDtJQUN6QixJQUFJLENBQUNPLFlBQVk7SUFDakJDLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JIO0lBQzVCQyxXQUFXRyxLQUFLLENBQUNKO0FBQ25CLEVBQUU7QUFFSyxNQUFNSyxxQkFBcUIsT0FDaENDLGFBQ0FDLElBQ0FDO0lBRUEsSUFBSUYsWUFBWUcsU0FBUyxDQUFDQyxFQUFFLEtBQUtILEdBQUdHLEVBQUUsRUFBRTtJQUN4QyxNQUFNLEVBQUVqQixNQUFNLEVBQUUsR0FBRyxNQUFNYyxHQUFHSSxTQUFTLENBQUNMLFlBQVlJLEVBQUU7SUFDcEQsTUFBTVQsYUFBYVI7SUFDbkJTLFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEJHLFlBQVlHLFNBQVMsQ0FBQ0MsRUFBRTtJQUNoRVQsV0FBV1csTUFBTSxDQUFDQyxHQUFHLENBQUMsQ0FBQ0M7UUFDckJaLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JXO1FBQzVCWixRQUFRQyxHQUFHLENBQUMsZ0JBQWdCRyxZQUFZRyxTQUFTLENBQUNDLEVBQUU7UUFDcERGLFFBQVFNLEtBQUtDLFFBQVE7SUFDdkI7QUFDRixFQUFFIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHAycFxcbW9kZWxcXHNreXdheVxccmVwb3NpdG9yeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2NhbERhdGFTdHJlYW0sIExvY2FsUDJQUm9vbU1lbWJlciwgUmVtb3RlRGF0YVN0cmVhbSwgUm9vbVB1YmxpY2F0aW9uIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5sZXQgc3RyZWFtOiBudWxsIHwgTG9jYWxEYXRhU3RyZWFtID0gbnVsbDtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXREYXRhU3RyZWFtID0gYXN5bmMgKCkgPT4ge1xyXG4gIGlmICghd2luZG93KSByZXR1cm4gbnVsbDtcclxuICBjb25zdCB7IFNreVdheVN0cmVhbUZhY3RvcnkgfSA9IHdpbmRvdy5za3l3YXlfcm9vbTtcclxuICBpZiAoc3RyZWFtKSByZXR1cm4gc3RyZWFtO1xyXG4gIHN0cmVhbSA9IGF3YWl0IFNreVdheVN0cmVhbUZhY3RvcnkuY3JlYXRlRGF0YVN0cmVhbSgpO1xyXG4gIHJldHVybiBzdHJlYW07XHJcbn07XHJcbmV4cG9ydCBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlOiBzdHJpbmcpID0+IHtcclxuICBjb25zdCBkYXRhU3RyZWFtID0gYXdhaXQgZ2V0RGF0YVN0cmVhbSgpO1xyXG4gIGlmICghZGF0YVN0cmVhbSkgcmV0dXJuO1xyXG4gIGNvbnNvbGUubG9nKCdzZW5kIG1lc3NhZ2UnLCBtZXNzYWdlKTtcclxuICBkYXRhU3RyZWFtLndyaXRlKG1lc3NhZ2UpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN1YnNjcmliZUFuZEF0dGFjaCA9IGFzeW5jIChcclxuICBwdWJsaWNhdGlvbjogUm9vbVB1YmxpY2F0aW9uLFxyXG4gIG1lOiBMb2NhbFAyUFJvb21NZW1iZXIsXHJcbiAgaGFuZGxlcjogKGRhdGE6IHN0cmluZykgPT4gdm9pZCxcclxuKSA9PiB7XHJcbiAgaWYgKHB1YmxpY2F0aW9uLnB1Ymxpc2hlci5pZCA9PT0gbWUuaWQpIHJldHVybjtcclxuICBjb25zdCB7IHN0cmVhbSB9ID0gYXdhaXQgbWUuc3Vic2NyaWJlKHB1YmxpY2F0aW9uLmlkKTtcclxuICBjb25zdCBkYXRhU3RyZWFtID0gc3RyZWFtIGFzIFJlbW90ZURhdGFTdHJlYW07XHJcbiAgY29uc29sZS5sb2coJ3B1YmxpY2F0aW9uLnB1Ymxpc2hlci5pZCcsIHB1YmxpY2F0aW9uLnB1Ymxpc2hlci5pZCk7XHJcbiAgZGF0YVN0cmVhbS5vbkRhdGEuYWRkKChkYXRhKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygncmVjZWl2ZSBkYXRhJywgZGF0YSk7XHJcbiAgICBjb25zb2xlLmxvZygncHVibGlzaGVyLmlkJywgcHVibGljYXRpb24ucHVibGlzaGVyLmlkKTtcclxuICAgIGhhbmRsZXIoZGF0YS50b1N0cmluZygpKTtcclxuICB9KTtcclxufTtcclxuIl0sIm5hbWVzIjpbInN0cmVhbSIsImdldERhdGFTdHJlYW0iLCJ3aW5kb3ciLCJTa3lXYXlTdHJlYW1GYWN0b3J5Iiwic2t5d2F5X3Jvb20iLCJjcmVhdGVEYXRhU3RyZWFtIiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwiZGF0YVN0cmVhbSIsImNvbnNvbGUiLCJsb2ciLCJ3cml0ZSIsInN1YnNjcmliZUFuZEF0dGFjaCIsInB1YmxpY2F0aW9uIiwibWUiLCJoYW5kbGVyIiwicHVibGlzaGVyIiwiaWQiLCJzdWJzY3JpYmUiLCJvbkRhdGEiLCJhZGQiLCJkYXRhIiwidG9TdHJpbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/p2p/model/skyway/repository.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/p2p/model/skyway/room.ts":
/*!***********************************************!*\
  !*** ./src/entities/p2p/model/skyway/room.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   joinRoom: () => (/* binding */ joinRoom)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./src/entities/p2p/model/skyway/constants.ts\");\n/* harmony import */ var _repository__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./repository */ \"(pages-dir-browser)/./src/entities/p2p/model/skyway/repository.ts\");\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./token */ \"(pages-dir-browser)/./src/entities/p2p/model/skyway/token.ts\");\n\n\n\nconst joinRoom = async function(receiveHandler) {\n    let token = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (0,_token__WEBPACK_IMPORTED_MODULE_2__.getToken)(), name = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _constants__WEBPACK_IMPORTED_MODULE_0__.roomName;\n    // トークンがないときはSkyWayに繋がない\n    if (!token) return null;\n    // 既に開いているデータストリームへ再度アタッチすることはできない\n    const dataStream = await (0,_repository__WEBPACK_IMPORTED_MODULE_1__.getDataStream)();\n    if (!dataStream || dataStream.published) return null;\n    console.log('token', token);\n    // SSRの時にwindowにアクセスするとエラーになるのでブロック\n    if (!window) return null;\n    const { SkyWayContext, SkyWayRoom } = window.skyway_room;\n    const context = await SkyWayContext.Create(token);\n    const room = await SkyWayRoom.FindOrCreate(context, {\n        type: 'p2p',\n        name\n    });\n    const me = await room.join();\n    // 自分のデータを publish する\n    me.publish(dataStream);\n    // 相手のデータをsubscribeする\n    console.log(room.publications);\n    room.publications.forEach((pub)=>{\n        (0,_repository__WEBPACK_IMPORTED_MODULE_1__.subscribeAndAttach)(pub, me, receiveHandler);\n    });\n    room.onStreamPublished.add((e)=>{\n        (0,_repository__WEBPACK_IMPORTED_MODULE_1__.subscribeAndAttach)(e.publication, me, receiveHandler);\n    });\n    room.onMemberJoined.add((e)=>{\n        console.log(e.member);\n    });\n    return me.id;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9wMnAvbW9kZWwvc2t5d2F5L3Jvb20udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1QztBQUMwQjtBQUM5QjtBQUU1QixNQUFNSSxXQUFXLGVBQ3RCQztRQUNBQyx5RUFBUUgsZ0RBQVFBLElBQ2hCSSx3RUFBT1AsZ0RBQVFBO0lBRWYsd0JBQXdCO0lBQ3hCLElBQUksQ0FBQ00sT0FBTyxPQUFPO0lBQ25CLGtDQUFrQztJQUNsQyxNQUFNRSxhQUFhLE1BQU1QLDBEQUFhQTtJQUN0QyxJQUFJLENBQUNPLGNBQWNBLFdBQVdDLFNBQVMsRUFBRSxPQUFPO0lBRWhEQyxRQUFRQyxHQUFHLENBQUMsU0FBU0w7SUFFckIsbUNBQW1DO0lBQ25DLElBQUksQ0FBQ00sUUFBUSxPQUFPO0lBQ3BCLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxVQUFVLEVBQUUsR0FBR0YsT0FBT0csV0FBVztJQUN4RCxNQUFNQyxVQUFVLE1BQU1ILGNBQWNJLE1BQU0sQ0FBQ1g7SUFDM0MsTUFBTVksT0FBTyxNQUFNSixXQUFXSyxZQUFZLENBQUNILFNBQVM7UUFBRUksTUFBTTtRQUFPYjtJQUFLO0lBQ3hFLE1BQU1jLEtBQUssTUFBTUgsS0FBS0ksSUFBSTtJQUUxQixxQkFBcUI7SUFDckJELEdBQUdFLE9BQU8sQ0FBQ2Y7SUFFWCxxQkFBcUI7SUFDckJFLFFBQVFDLEdBQUcsQ0FBQ08sS0FBS00sWUFBWTtJQUM3Qk4sS0FBS00sWUFBWSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0M7UUFDekJ4QiwrREFBa0JBLENBQUN3QixLQUFLTCxJQUFJaEI7SUFDOUI7SUFDQWEsS0FBS1MsaUJBQWlCLENBQUNDLEdBQUcsQ0FBQyxDQUFDQztRQUMxQjNCLCtEQUFrQkEsQ0FBQzJCLEVBQUVDLFdBQVcsRUFBRVQsSUFBSWhCO0lBQ3hDO0lBQ0FhLEtBQUthLGNBQWMsQ0FBQ0gsR0FBRyxDQUFDLENBQUNDO1FBQ3ZCbkIsUUFBUUMsR0FBRyxDQUFDa0IsRUFBRUcsTUFBTTtJQUN0QjtJQUVBLE9BQU9YLEdBQUdZLEVBQUU7QUFDZCxFQUFFIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHAycFxcbW9kZWxcXHNreXdheVxccm9vbS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByb29tTmFtZSB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgZ2V0RGF0YVN0cmVhbSwgc3Vic2NyaWJlQW5kQXR0YWNoIH0gZnJvbSAnLi9yZXBvc2l0b3J5JztcclxuaW1wb3J0IHsgZ2V0VG9rZW4gfSBmcm9tICcuL3Rva2VuJztcclxuXHJcbmV4cG9ydCBjb25zdCBqb2luUm9vbSA9IGFzeW5jIChcclxuICByZWNlaXZlSGFuZGxlcjogKHM6IHN0cmluZykgPT4gdm9pZCxcclxuICB0b2tlbiA9IGdldFRva2VuKCksXHJcbiAgbmFtZSA9IHJvb21OYW1lLFxyXG4pID0+IHtcclxuICAvLyDjg4jjg7zjgq/jg7PjgYzjgarjgYTjgajjgY3jga9Ta3lXYXnjgavnuYvjgYzjgarjgYRcclxuICBpZiAoIXRva2VuKSByZXR1cm4gbnVsbDtcclxuICAvLyDml6LjgavplovjgYTjgabjgYTjgovjg4fjg7zjgr/jgrnjg4jjg6rjg7zjg6Djgbjlho3luqbjgqLjgr/jg4Pjg4HjgZnjgovjgZPjgajjga/jgafjgY3jgarjgYRcclxuICBjb25zdCBkYXRhU3RyZWFtID0gYXdhaXQgZ2V0RGF0YVN0cmVhbSgpO1xyXG4gIGlmICghZGF0YVN0cmVhbSB8fCBkYXRhU3RyZWFtLnB1Ymxpc2hlZCkgcmV0dXJuIG51bGw7XHJcblxyXG4gIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuKTtcclxuXHJcbiAgLy8gU1NS44Gu5pmC44Grd2luZG9344Gr44Ki44Kv44K744K544GZ44KL44Go44Ko44Op44O844Gr44Gq44KL44Gu44Gn44OW44Ot44OD44KvXHJcbiAgaWYgKCF3aW5kb3cpIHJldHVybiBudWxsO1xyXG4gIGNvbnN0IHsgU2t5V2F5Q29udGV4dCwgU2t5V2F5Um9vbSB9ID0gd2luZG93LnNreXdheV9yb29tO1xyXG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBTa3lXYXlDb250ZXh0LkNyZWF0ZSh0b2tlbik7XHJcbiAgY29uc3Qgcm9vbSA9IGF3YWl0IFNreVdheVJvb20uRmluZE9yQ3JlYXRlKGNvbnRleHQsIHsgdHlwZTogJ3AycCcsIG5hbWUgfSk7XHJcbiAgY29uc3QgbWUgPSBhd2FpdCByb29tLmpvaW4oKTtcclxuXHJcbiAgLy8g6Ieq5YiG44Gu44OH44O844K/44KSIHB1Ymxpc2gg44GZ44KLXHJcbiAgbWUucHVibGlzaChkYXRhU3RyZWFtKTtcclxuXHJcbiAgLy8g55u45omL44Gu44OH44O844K/44KSc3Vic2NyaWJl44GZ44KLXHJcbiAgY29uc29sZS5sb2cocm9vbS5wdWJsaWNhdGlvbnMpO1xyXG4gIHJvb20ucHVibGljYXRpb25zLmZvckVhY2goKHB1YikgPT4ge1xyXG4gICAgc3Vic2NyaWJlQW5kQXR0YWNoKHB1YiwgbWUsIHJlY2VpdmVIYW5kbGVyKTtcclxuICB9KTtcclxuICByb29tLm9uU3RyZWFtUHVibGlzaGVkLmFkZCgoZSkgPT4ge1xyXG4gICAgc3Vic2NyaWJlQW5kQXR0YWNoKGUucHVibGljYXRpb24sIG1lLCByZWNlaXZlSGFuZGxlcik7XHJcbiAgfSk7XHJcbiAgcm9vbS5vbk1lbWJlckpvaW5lZC5hZGQoKGUpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKGUubWVtYmVyKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG1lLmlkO1xyXG59O1xyXG4iXSwibmFtZXMiOlsicm9vbU5hbWUiLCJnZXREYXRhU3RyZWFtIiwic3Vic2NyaWJlQW5kQXR0YWNoIiwiZ2V0VG9rZW4iLCJqb2luUm9vbSIsInJlY2VpdmVIYW5kbGVyIiwidG9rZW4iLCJuYW1lIiwiZGF0YVN0cmVhbSIsInB1Ymxpc2hlZCIsImNvbnNvbGUiLCJsb2ciLCJ3aW5kb3ciLCJTa3lXYXlDb250ZXh0IiwiU2t5V2F5Um9vbSIsInNreXdheV9yb29tIiwiY29udGV4dCIsIkNyZWF0ZSIsInJvb20iLCJGaW5kT3JDcmVhdGUiLCJ0eXBlIiwibWUiLCJqb2luIiwicHVibGlzaCIsInB1YmxpY2F0aW9ucyIsImZvckVhY2giLCJwdWIiLCJvblN0cmVhbVB1Ymxpc2hlZCIsImFkZCIsImUiLCJwdWJsaWNhdGlvbiIsIm9uTWVtYmVySm9pbmVkIiwibWVtYmVyIiwiaWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/p2p/model/skyway/room.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/p2p/model/skyway/token.ts":
/*!************************************************!*\
  !*** ./src/entities/p2p/model/skyway/token.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getToken: () => (/* binding */ getToken)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./src/entities/p2p/model/skyway/constants.ts\");\n\nconst getToken = ()=>{\n    if (_constants__WEBPACK_IMPORTED_MODULE_0__.authToken) return _constants__WEBPACK_IMPORTED_MODULE_0__.authToken;\n    if (!window) return '';\n    return '';\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9wMnAvbW9kZWwvc2t5d2F5L3Rva2VuLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBRWpDLE1BQU1DLFdBQVc7SUFDdEIsSUFBSUQsaURBQVNBLEVBQUUsT0FBT0EsaURBQVNBO0lBQy9CLElBQUksQ0FBQ0UsUUFBUSxPQUFPO0lBQ3BCLE9BQU87QUFDVCxFQUFFIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHAycFxcbW9kZWxcXHNreXdheVxcdG9rZW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXV0aFRva2VuIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRva2VuID0gKCkgPT4ge1xyXG4gIGlmIChhdXRoVG9rZW4pIHJldHVybiBhdXRoVG9rZW47XHJcbiAgaWYgKCF3aW5kb3cpIHJldHVybiAnJztcclxuICByZXR1cm4gJyc7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJhdXRoVG9rZW4iLCJnZXRUb2tlbiIsIndpbmRvdyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/p2p/model/skyway/token.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/index.ts":
/*!*****************************************!*\
  !*** ./src/entities/simulator/index.ts ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayerHeight: () => (/* reexport safe */ _model_domain_constants__WEBPACK_IMPORTED_MODULE_5__.LayerHeight),\n/* harmony export */   LayerWidth: () => (/* reexport safe */ _model_domain_constants__WEBPACK_IMPORTED_MODULE_5__.LayerWidth),\n/* harmony export */   convertTextPropsRapierToViewer: () => (/* reexport safe */ _model_domain_converter__WEBPACK_IMPORTED_MODULE_6__.convertTextPropsRapierToViewer),\n/* harmony export */   formatText: () => (/* reexport safe */ _model_domain_format__WEBPACK_IMPORTED_MODULE_1__.formatText),\n/* harmony export */   getForce: () => (/* reexport safe */ _model_domain_force__WEBPACK_IMPORTED_MODULE_2__.getForce),\n/* harmony export */   simulateLoop: () => (/* reexport safe */ _model_domain_index__WEBPACK_IMPORTED_MODULE_0__.simulateLoop),\n/* harmony export */   simulaterProps: () => (/* reexport safe */ _model_domain_constants__WEBPACK_IMPORTED_MODULE_5__.simulaterProps),\n/* harmony export */   simulator: () => (/* reexport safe */ _model_domain_index__WEBPACK_IMPORTED_MODULE_0__.simulator),\n/* harmony export */   simulatorSlice: () => (/* reexport safe */ _model_simulatorSlice__WEBPACK_IMPORTED_MODULE_3__.simulatorSlice),\n/* harmony export */   textsSelector: () => (/* reexport safe */ _model_simulatorSelector__WEBPACK_IMPORTED_MODULE_4__.textsSelector)\n/* harmony export */ });\n/* harmony import */ var _model_domain_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model/domain */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/index.ts\");\n/* harmony import */ var _model_domain_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/domain/format */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/format.ts\");\n/* harmony import */ var _model_domain_force__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/domain/force */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/force.ts\");\n/* harmony import */ var _model_simulatorSlice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/simulatorSlice */ \"(pages-dir-browser)/./src/entities/simulator/model/simulatorSlice.ts\");\n/* harmony import */ var _model_simulatorSelector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/simulatorSelector */ \"(pages-dir-browser)/./src/entities/simulator/model/simulatorSelector.ts\");\n/* harmony import */ var _model_domain_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./model/domain/constants */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/constants.ts\");\n/* harmony import */ var _model_domain_converter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./model/domain/converter */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/converter.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_model_domain_index__WEBPACK_IMPORTED_MODULE_0__]);\n_model_domain_index__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDRTtBQUNIO0FBQ0Y7QUFDVTtBQUNFO0FBTXhCO0FBQ3dDIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHNpbXVsYXRvclxcaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgc2ltdWxhdG9yIH0gZnJvbSAnLi9tb2RlbC9kb21haW4vaW5kZXgnO1xyXG5leHBvcnQgeyBmb3JtYXRUZXh0IH0gZnJvbSAnLi9tb2RlbC9kb21haW4vZm9ybWF0JztcclxuZXhwb3J0IHsgZ2V0Rm9yY2UgfSBmcm9tICcuL21vZGVsL2RvbWFpbi9mb3JjZSc7XHJcbmV4cG9ydCB7IHNpbXVsYXRlTG9vcCB9IGZyb20gJy4vbW9kZWwvZG9tYWluJztcclxuZXhwb3J0IHsgc2ltdWxhdG9yU2xpY2UgfSBmcm9tICcuL21vZGVsL3NpbXVsYXRvclNsaWNlJztcclxuZXhwb3J0IHsgdGV4dHNTZWxlY3RvciB9IGZyb20gJy4vbW9kZWwvc2ltdWxhdG9yU2VsZWN0b3InO1xyXG5leHBvcnQge1xyXG4gIHNpbXVsYXRlclByb3BzLFxyXG4gIExheWVySGVpZ2h0LFxyXG4gIExheWVyV2lkdGgsXHJcbiAgdHlwZSBTaW11bGF0ZXJQcm9wcyxcclxufSBmcm9tICcuL21vZGVsL2RvbWFpbi9jb25zdGFudHMnO1xyXG5leHBvcnQgeyBjb252ZXJ0VGV4dFByb3BzUmFwaWVyVG9WaWV3ZXIgfSBmcm9tICcuL21vZGVsL2RvbWFpbi9jb252ZXJ0ZXInO1xyXG5leHBvcnQgdHlwZSB7IFRleHRQcm9wcyB9IGZyb20gJy4vbW9kZWwvZG9tYWluL3R5cGVzJztcclxuIl0sIm5hbWVzIjpbInNpbXVsYXRvciIsImZvcm1hdFRleHQiLCJnZXRGb3JjZSIsInNpbXVsYXRlTG9vcCIsInNpbXVsYXRvclNsaWNlIiwidGV4dHNTZWxlY3RvciIsInNpbXVsYXRlclByb3BzIiwiTGF5ZXJIZWlnaHQiLCJMYXllcldpZHRoIiwiY29udmVydFRleHRQcm9wc1JhcGllclRvVmlld2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/model/domain/calc.ts":
/*!*****************************************************!*\
  !*** ./src/entities/simulator/model/domain/calc.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   positionToScale: () => (/* binding */ positionToScale),\n/* harmony export */   toDegree: () => (/* binding */ toDegree),\n/* harmony export */   toRadian: () => (/* binding */ toRadian)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/constants.ts\");\n\nconst toRadian = (degree)=>degree * (Math.PI / 180);\nconst toDegree = (radian)=>radian * (180 / Math.PI);\n// SCALEで小さくしてシミュレーションした結果を描画用に引き延ばす\nconst positionToScale = (i)=>Math.floor(i * _constants__WEBPACK_IMPORTED_MODULE_0__.SCALE);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvbW9kZWwvZG9tYWluL2NhbGMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvQztBQUU3QixNQUFNQyxXQUFXLENBQUNDLFNBQW1CQSxTQUFVQyxDQUFBQSxLQUFLQyxFQUFFLEdBQUcsR0FBRSxFQUFHO0FBQzlELE1BQU1DLFdBQVcsQ0FBQ0MsU0FBbUJBLFNBQVUsT0FBTUgsS0FBS0MsRUFBRSxFQUFFO0FBRXJFLG9DQUFvQztBQUM3QixNQUFNRyxrQkFBa0IsQ0FBQ0MsSUFBY0wsS0FBS00sS0FBSyxDQUFDRCxJQUFJUiw2Q0FBS0EsRUFBRSIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcYXBwc1xcd2ViXFxzcmNcXGVudGl0aWVzXFxzaW11bGF0b3JcXG1vZGVsXFxkb21haW5cXGNhbGMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0NBTEUgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcblxyXG5leHBvcnQgY29uc3QgdG9SYWRpYW4gPSAoZGVncmVlOiBudW1iZXIpID0+IGRlZ3JlZSAqIChNYXRoLlBJIC8gMTgwKTtcclxuZXhwb3J0IGNvbnN0IHRvRGVncmVlID0gKHJhZGlhbjogbnVtYmVyKSA9PiByYWRpYW4gKiAoMTgwIC8gTWF0aC5QSSk7XHJcblxyXG4vLyBTQ0FMReOBp+Wwj+OBleOBj+OBl+OBpuOCt+ODn+ODpeODrOODvOOCt+ODp+ODs+OBl+OBn+e1kOaenOOCkuaPj+eUu+eUqOOBq+W8leOBjeW7tuOBsOOBmVxyXG5leHBvcnQgY29uc3QgcG9zaXRpb25Ub1NjYWxlID0gKGk6IG51bWJlcikgPT4gTWF0aC5mbG9vcihpICogU0NBTEUpO1xyXG4iXSwibmFtZXMiOlsiU0NBTEUiLCJ0b1JhZGlhbiIsImRlZ3JlZSIsIk1hdGgiLCJQSSIsInRvRGVncmVlIiwicmFkaWFuIiwicG9zaXRpb25Ub1NjYWxlIiwiaSIsImZsb29yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/model/domain/calc.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/model/domain/constants.ts":
/*!**********************************************************!*\
  !*** ./src/entities/simulator/model/domain/constants.ts ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayerHeight: () => (/* binding */ LayerHeight),\n/* harmony export */   LayerWidth: () => (/* binding */ LayerWidth),\n/* harmony export */   SCALE: () => (/* binding */ SCALE),\n/* harmony export */   deviderProps: () => (/* binding */ deviderProps),\n/* harmony export */   forceVector: () => (/* binding */ forceVector),\n/* harmony export */   gravity: () => (/* binding */ gravity),\n/* harmony export */   simulaterProps: () => (/* binding */ simulaterProps)\n/* harmony export */ });\nconst SCALE = 100;\nconst LayerWidth = 500;\nconst LayerHeight = 500;\n// 重力ベクトル (yのマイナス方向にかかる力)\nconst gravity = {\n    x: 0,\n    y: -1.81\n};\n// テキスト追加時にかける力\nconst forceVector = {\n    x: -2,\n    y: 1\n};\n// 壁の設定\nconst deviderProps = {\n    height: 40,\n    width: LayerWidth,\n    mass: 1,\n    rotate: 0\n};\nconst simulaterProps = {\n    textFrame: {\n        fontSize: 16,\n        width: 200,\n        height: 50,\n        density: 1,\n        mass: 1,\n        text: ''\n    },\n    deviders: [\n        // 床\n        {\n            ...deviderProps,\n            position: {\n                x: 0,\n                y: -deviderProps.width / 2 - deviderProps.height / 2\n            }\n        },\n        // 左の壁\n        {\n            ...deviderProps,\n            position: {\n                x: deviderProps.width / 2,\n                y: 0\n            },\n            rotate: -90\n        },\n        // 右の壁\n        {\n            ...deviderProps,\n            position: {\n                x: -deviderProps.width / 2,\n                y: 0\n            },\n            rotate: 90\n        }\n    ]\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvbW9kZWwvZG9tYWluL2NvbnN0YW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU8sTUFBTUEsUUFBUSxJQUFJO0FBQ2xCLE1BQU1DLGFBQWEsSUFBSTtBQUN2QixNQUFNQyxjQUFjLElBQUk7QUFDL0IseUJBQXlCO0FBQ2xCLE1BQU1DLFVBQVU7SUFBRUMsR0FBRztJQUFHQyxHQUFHLENBQUM7QUFBSyxFQUFFO0FBRTFDLGVBQWU7QUFDUixNQUFNQyxjQUFjO0lBQUVGLEdBQUcsQ0FBQztJQUFHQyxHQUFHO0FBQUUsRUFBRTtBQUUzQyxPQUFPO0FBQ0EsTUFBTUUsZUFBZTtJQUMxQkMsUUFBUTtJQUNSQyxPQUFPUjtJQUNQUyxNQUFNO0lBQ05DLFFBQVE7QUFDVixFQUFXO0FBRUosTUFBTUMsaUJBQWlCO0lBQzVCQyxXQUFXO1FBQ1RDLFVBQVU7UUFDVkwsT0FBTztRQUNQRCxRQUFRO1FBQ1JPLFNBQVM7UUFDVEwsTUFBTTtRQUNOTSxNQUFNO0lBQ1I7SUFDQUMsVUFBVTtRQUNSLElBQUk7UUFDSjtZQUNFLEdBQUdWLFlBQVk7WUFDZlcsVUFBVTtnQkFBRWQsR0FBRztnQkFBR0MsR0FBRyxDQUFDRSxhQUFhRSxLQUFLLEdBQUcsSUFBSUYsYUFBYUMsTUFBTSxHQUFHO1lBQUU7UUFDekU7UUFDQSxNQUFNO1FBQ047WUFDRSxHQUFHRCxZQUFZO1lBQ2ZXLFVBQVU7Z0JBQUVkLEdBQUdHLGFBQWFFLEtBQUssR0FBRztnQkFBR0osR0FBRztZQUFFO1lBQzVDTSxRQUFRLENBQUM7UUFDWDtRQUNBLE1BQU07UUFDTjtZQUNFLEdBQUdKLFlBQVk7WUFDZlcsVUFBVTtnQkFBRWQsR0FBRyxDQUFDRyxhQUFhRSxLQUFLLEdBQUc7Z0JBQUdKLEdBQUc7WUFBRTtZQUM3Q00sUUFBUTtRQUNWO0tBQ0Q7QUFDSCxFQUFFIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHNpbXVsYXRvclxcbW9kZWxcXGRvbWFpblxcY29uc3RhbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBTQ0FMRSA9IDEwMDtcclxuZXhwb3J0IGNvbnN0IExheWVyV2lkdGggPSA1MDA7XHJcbmV4cG9ydCBjb25zdCBMYXllckhlaWdodCA9IDUwMDtcclxuLy8g6YeN5Yqb44OZ44Kv44OI44OrICh544Gu44Oe44Kk44OK44K55pa55ZCR44Gr44GL44GL44KL5YqbKVxyXG5leHBvcnQgY29uc3QgZ3Jhdml0eSA9IHsgeDogMCwgeTogLTEuODEgfTtcclxuXHJcbi8vIOODhuOCreOCueODiOi/veWKoOaZguOBq+OBi+OBkeOCi+WKm1xyXG5leHBvcnQgY29uc3QgZm9yY2VWZWN0b3IgPSB7IHg6IC0yLCB5OiAxIH07XHJcblxyXG4vLyDlo4Hjga7oqK3lrppcclxuZXhwb3J0IGNvbnN0IGRldmlkZXJQcm9wcyA9IHtcclxuICBoZWlnaHQ6IDQwLFxyXG4gIHdpZHRoOiBMYXllcldpZHRoLFxyXG4gIG1hc3M6IDEsXHJcbiAgcm90YXRlOiAwLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNpbXVsYXRlclByb3BzID0ge1xyXG4gIHRleHRGcmFtZToge1xyXG4gICAgZm9udFNpemU6IDE2LFxyXG4gICAgd2lkdGg6IDIwMCxcclxuICAgIGhlaWdodDogNTAsXHJcbiAgICBkZW5zaXR5OiAxLFxyXG4gICAgbWFzczogMSxcclxuICAgIHRleHQ6ICcnLFxyXG4gIH0sXHJcbiAgZGV2aWRlcnM6IFtcclxuICAgIC8vIOW6ilxyXG4gICAge1xyXG4gICAgICAuLi5kZXZpZGVyUHJvcHMsXHJcbiAgICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IC1kZXZpZGVyUHJvcHMud2lkdGggLyAyIC0gZGV2aWRlclByb3BzLmhlaWdodCAvIDIgfSxcclxuICAgIH0sXHJcbiAgICAvLyDlt6bjga7lo4FcclxuICAgIHtcclxuICAgICAgLi4uZGV2aWRlclByb3BzLFxyXG4gICAgICBwb3NpdGlvbjogeyB4OiBkZXZpZGVyUHJvcHMud2lkdGggLyAyLCB5OiAwIH0sXHJcbiAgICAgIHJvdGF0ZTogLTkwLFxyXG4gICAgfSxcclxuICAgIC8vIOWPs+OBruWjgVxyXG4gICAge1xyXG4gICAgICAuLi5kZXZpZGVyUHJvcHMsXHJcbiAgICAgIHBvc2l0aW9uOiB7IHg6IC1kZXZpZGVyUHJvcHMud2lkdGggLyAyLCB5OiAwIH0sXHJcbiAgICAgIHJvdGF0ZTogOTAsXHJcbiAgICB9LFxyXG4gIF0sXHJcbn07XHJcbmV4cG9ydCB0eXBlIFNpbXVsYXRlclByb3BzID0gdHlwZW9mIHNpbXVsYXRlclByb3BzO1xyXG4iXSwibmFtZXMiOlsiU0NBTEUiLCJMYXllcldpZHRoIiwiTGF5ZXJIZWlnaHQiLCJncmF2aXR5IiwieCIsInkiLCJmb3JjZVZlY3RvciIsImRldmlkZXJQcm9wcyIsImhlaWdodCIsIndpZHRoIiwibWFzcyIsInJvdGF0ZSIsInNpbXVsYXRlclByb3BzIiwidGV4dEZyYW1lIiwiZm9udFNpemUiLCJkZW5zaXR5IiwidGV4dCIsImRldmlkZXJzIiwicG9zaXRpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/model/domain/constants.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/model/domain/converter.ts":
/*!**********************************************************!*\
  !*** ./src/entities/simulator/model/domain/converter.ts ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertTextPropsRapierToViewer: () => (/* binding */ convertTextPropsRapierToViewer)\n/* harmony export */ });\n/* harmony import */ var _calc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calc */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/calc.ts\");\n\nconst convertTextPropsRapierToViewer = (item)=>({\n        ...item,\n        width: (0,_calc__WEBPACK_IMPORTED_MODULE_0__.positionToScale)(item.width),\n        height: (0,_calc__WEBPACK_IMPORTED_MODULE_0__.positionToScale)(item.height),\n        position: {\n            x: (0,_calc__WEBPACK_IMPORTED_MODULE_0__.positionToScale)(item.position.x),\n            y: (0,_calc__WEBPACK_IMPORTED_MODULE_0__.positionToScale)(item.position.y)\n        },\n        rotation: (0,_calc__WEBPACK_IMPORTED_MODULE_0__.toDegree)(item.rotation)\n    });\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvbW9kZWwvZG9tYWluL2NvbnZlcnRlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFtRDtBQUc1QyxNQUFNRSxpQ0FBaUMsQ0FBQ0MsT0FBZ0M7UUFDN0UsR0FBR0EsSUFBSTtRQUNQQyxPQUFPSixzREFBZUEsQ0FBQ0csS0FBS0MsS0FBSztRQUNqQ0MsUUFBUUwsc0RBQWVBLENBQUNHLEtBQUtFLE1BQU07UUFDbkNDLFVBQVU7WUFDUkMsR0FBR1Asc0RBQWVBLENBQUNHLEtBQUtHLFFBQVEsQ0FBQ0MsQ0FBQztZQUNsQ0MsR0FBR1Isc0RBQWVBLENBQUNHLEtBQUtHLFFBQVEsQ0FBQ0UsQ0FBQztRQUNwQztRQUNBQyxVQUFVUiwrQ0FBUUEsQ0FBQ0UsS0FBS00sUUFBUTtJQUNsQyxHQUFHIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHNpbXVsYXRvclxcbW9kZWxcXGRvbWFpblxcY29udmVydGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBvc2l0aW9uVG9TY2FsZSwgdG9EZWdyZWUgfSBmcm9tICcuL2NhbGMnO1xyXG5pbXBvcnQgeyBUZXh0UHJvcHMgfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbmV4cG9ydCBjb25zdCBjb252ZXJ0VGV4dFByb3BzUmFwaWVyVG9WaWV3ZXIgPSAoaXRlbTogVGV4dFByb3BzKTogVGV4dFByb3BzID0+ICh7XHJcbiAgLi4uaXRlbSxcclxuICB3aWR0aDogcG9zaXRpb25Ub1NjYWxlKGl0ZW0ud2lkdGgpLFxyXG4gIGhlaWdodDogcG9zaXRpb25Ub1NjYWxlKGl0ZW0uaGVpZ2h0KSxcclxuICBwb3NpdGlvbjoge1xyXG4gICAgeDogcG9zaXRpb25Ub1NjYWxlKGl0ZW0ucG9zaXRpb24ueCksXHJcbiAgICB5OiBwb3NpdGlvblRvU2NhbGUoaXRlbS5wb3NpdGlvbi55KSxcclxuICB9LFxyXG4gIHJvdGF0aW9uOiB0b0RlZ3JlZShpdGVtLnJvdGF0aW9uKSxcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJwb3NpdGlvblRvU2NhbGUiLCJ0b0RlZ3JlZSIsImNvbnZlcnRUZXh0UHJvcHNSYXBpZXJUb1ZpZXdlciIsIml0ZW0iLCJ3aWR0aCIsImhlaWdodCIsInBvc2l0aW9uIiwieCIsInkiLCJyb3RhdGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/model/domain/converter.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/model/domain/force.ts":
/*!******************************************************!*\
  !*** ./src/entities/simulator/model/domain/force.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getForce: () => (/* binding */ getForce)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/constants.ts\");\n\nconst getForce = (text)=>{\n    // @はここに来るまでに大文字の＠に置換されている前提\n    if (text.includes('＠倍速')) {\n        const count = (text.match(/＠倍速/g) || []).length;\n        return {\n            ..._constants__WEBPACK_IMPORTED_MODULE_0__.forceVector,\n            x: _constants__WEBPACK_IMPORTED_MODULE_0__.forceVector.x * (count + 1)\n        };\n    }\n    return undefined;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvbW9kZWwvZG9tYWluL2ZvcmNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBRW5DLE1BQU1DLFdBQVcsQ0FBQ0M7SUFDdkIsNEJBQTRCO0lBQzVCLElBQUlBLEtBQUtDLFFBQVEsQ0FBQyxRQUFRO1FBQ3hCLE1BQU1DLFFBQVEsQ0FBQ0YsS0FBS0csS0FBSyxDQUFDLFdBQVcsRUFBRSxFQUFFQyxNQUFNO1FBQy9DLE9BQU87WUFBRSxHQUFHTixtREFBVztZQUFFTyxHQUFHUCxtREFBV0EsQ0FBQ08sQ0FBQyxHQUFJSCxDQUFBQSxRQUFRO1FBQUc7SUFDMUQ7SUFDQSxPQUFPSTtBQUNULEVBQUUiLCJzb3VyY2VzIjpbIkQ6XFxwcm9qZWN0c1xcY29tbWVudC1hdGxhdGxcXGFwcHNcXHdlYlxcc3JjXFxlbnRpdGllc1xcc2ltdWxhdG9yXFxtb2RlbFxcZG9tYWluXFxmb3JjZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JjZVZlY3RvciB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRGb3JjZSA9ICh0ZXh0OiBzdHJpbmcpID0+IHtcclxuICAvLyBA44Gv44GT44GT44Gr5p2l44KL44G+44Gn44Gr5aSn5paH5a2X44Gu77yg44Gr572u5o+b44GV44KM44Gm44GE44KL5YmN5o+QXHJcbiAgaWYgKHRleHQuaW5jbHVkZXMoJ++8oOWAjemAnycpKSB7XHJcbiAgICBjb25zdCBjb3VudCA9ICh0ZXh0Lm1hdGNoKC/vvKDlgI3pgJ8vZykgfHwgW10pLmxlbmd0aDtcclxuICAgIHJldHVybiB7IC4uLmZvcmNlVmVjdG9yLCB4OiBmb3JjZVZlY3Rvci54ICogKGNvdW50ICsgMSkgfTtcclxuICB9XHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuIl0sIm5hbWVzIjpbImZvcmNlVmVjdG9yIiwiZ2V0Rm9yY2UiLCJ0ZXh0IiwiaW5jbHVkZXMiLCJjb3VudCIsIm1hdGNoIiwibGVuZ3RoIiwieCIsInVuZGVmaW5lZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/model/domain/force.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/model/domain/format.ts":
/*!*******************************************************!*\
  !*** ./src/entities/simulator/model/domain/format.ts ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatText: () => (/* binding */ formatText)\n/* harmony export */ });\nconst formatText = (text)=>text.replace(/@/g, '＠');\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvbW9kZWwvZG9tYWluL2Zvcm1hdC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsYUFBYSxDQUFDQyxPQUFpQkEsS0FBS0MsT0FBTyxDQUFDLE1BQU0sS0FBSyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcYXBwc1xcd2ViXFxzcmNcXGVudGl0aWVzXFxzaW11bGF0b3JcXG1vZGVsXFxkb21haW5cXGZvcm1hdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZm9ybWF0VGV4dCA9ICh0ZXh0OiBzdHJpbmcpID0+IHRleHQucmVwbGFjZSgvQC9nLCAn77ygJyk7XHJcbiJdLCJuYW1lcyI6WyJmb3JtYXRUZXh0IiwidGV4dCIsInJlcGxhY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/model/domain/format.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/model/domain/index.ts":
/*!******************************************************!*\
  !*** ./src/entities/simulator/model/domain/index.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   simulateLoop: () => (/* binding */ simulateLoop),\n/* harmony export */   simulator: () => (/* binding */ simulator)\n/* harmony export */ });\n/* harmony import */ var _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dimforge/rapier2d */ \"(pages-dir-browser)/../../node_modules/@dimforge/rapier2d/rapier.js\");\n/* harmony import */ var _calc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calc */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/calc.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(pages-dir-browser)/./src/entities/simulator/model/domain/constants.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__]);\n_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst world = new _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__[\"default\"].World(_constants__WEBPACK_IMPORTED_MODULE_1__.gravity);\n// scale: 計算を早くするために除算する係数\nconst createSimulator = (scale, props)=>{\n    //  壁と床を作る\n    props.deviders.forEach((devider)=>{\n        world.createCollider(_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ColliderDesc.cuboid(devider.width / 2 / scale, devider.height / 2 / scale).setMass(devider.mass).setTranslation(devider.position.x / scale, devider.position.y / scale).setRotation((0,_calc__WEBPACK_IMPORTED_MODULE_0__.toRadian)(devider.rotate)));\n    });\n    const texts = [];\n    return {\n        getTexts: ()=>texts,\n        addText: (param)=>{\n            let { text, position, force = _constants__WEBPACK_IMPORTED_MODULE_1__.forceVector } = param;\n            const b = world.createRigidBody(_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__[\"default\"].RigidBodyDesc.dynamic().setTranslation(position.x / scale, position.y / scale).setAngvel(0).setLinvel(force.x, force.y));\n            // cuboidは長さ・高さを半分にして作成\n            const hw = props.textFrame.fontSize * text.length / 2 / scale;\n            const hh = props.textFrame.fontSize / 2 / scale;\n            const c = _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ColliderDesc.cuboid(hw, hh).setMass(props.textFrame.mass).setDensity(props.textFrame.density).setRestitution(0.7).setActiveEvents(_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ActiveEvents.COLLISION_EVENTS);\n            // シミュレーション開始\n            world.createCollider(c, b);\n            texts.push({\n                rigid: b,\n                collider: c,\n                text\n            });\n        }\n    };\n};\nconst simulator = createSimulator(_constants__WEBPACK_IMPORTED_MODULE_1__.SCALE, _constants__WEBPACK_IMPORTED_MODULE_1__.simulaterProps);\nconst eventQueue = new _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EventQueue(true);\nconst simulateLoop = ()=>{\n    world.step(eventQueue);\n    const items = simulator.getTexts().map((obj)=>{\n        const trans = obj.rigid.translation();\n        return {\n            position: {\n                x: trans.x,\n                y: trans.y\n            },\n            rotation: obj.rigid.rotation(),\n            width: obj.collider.shape.halfExtents.x * 2,\n            height: obj.collider.shape.halfExtents.y * 2,\n            text: \"\".concat(obj.text)\n        };\n    });\n    // eventQueue.drainCollisionEventsはCOLLISION_EVENTSを有効にしていないので、発生しない\n    // eventQueue.drainContactForceEventsはCONTACT_FORCE_EVENTSを有効にしていないので、発生しない\n    return items;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvbW9kZWwvZG9tYWluL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ2xCO0FBQ3dEO0FBRTFGLE1BQU1NLFFBQVEsSUFBSU4sZ0VBQVksQ0FBQ0ksK0NBQU9BO0FBRXRDLDBCQUEwQjtBQUMxQixNQUFNSSxrQkFBa0IsQ0FBQ0MsT0FBZUM7SUFDdEMsVUFBVTtJQUNWQSxNQUFNQyxRQUFRLENBQUNDLE9BQU8sQ0FBQyxDQUFDQztRQUN0QlAsTUFBTVEsY0FBYyxDQUNsQmQsdUVBQW1CLENBQUNnQixNQUFNLENBQUNILFFBQVFJLEtBQUssR0FBRyxJQUFJUixPQUFPSSxRQUFRSyxNQUFNLEdBQUcsSUFBSVQsT0FDeEVVLE9BQU8sQ0FBQ04sUUFBUU8sSUFBSSxFQUNwQkMsY0FBYyxDQUFDUixRQUFRUyxRQUFRLENBQUNDLENBQUMsR0FBR2QsT0FBT0ksUUFBUVMsUUFBUSxDQUFDRSxDQUFDLEdBQUdmLE9BQ2hFZ0IsV0FBVyxDQUFDeEIsK0NBQVFBLENBQUNZLFFBQVFhLE1BQU07SUFFMUM7SUFFQSxNQUFNQyxRQUFvRixFQUFFO0lBQzVGLE9BQU87UUFDTEMsVUFBVSxJQUFNRDtRQUNoQkUsU0FBUztnQkFBQyxFQUNSQyxJQUFJLEVBQ0pSLFFBQVEsRUFDUlMsUUFBUTVCLG1EQUFXLEVBS3BCO1lBQ0MsTUFBTTZCLElBQUkxQixNQUFNMkIsZUFBZSxDQUM3QmpDLHdFQUFvQixDQUFDbUMsT0FBTyxHQUN6QmQsY0FBYyxDQUFDQyxTQUFTQyxDQUFDLEdBQUdkLE9BQU9hLFNBQVNFLENBQUMsR0FBR2YsT0FDaEQyQixTQUFTLENBQUMsR0FDVkMsU0FBUyxDQUFDTixNQUFNUixDQUFDLEVBQUVRLE1BQU1QLENBQUM7WUFFL0IsdUJBQXVCO1lBQ3ZCLE1BQU1jLEtBQUssTUFBT0MsU0FBUyxDQUFDQyxRQUFRLEdBQUdWLEtBQUtXLE1BQU0sR0FBSSxJQUFJaEM7WUFDMUQsTUFBTWlDLEtBQUtoQyxNQUFNNkIsU0FBUyxDQUFDQyxRQUFRLEdBQUcsSUFBSS9CO1lBQzFDLE1BQU1rQyxJQUFJM0MsdUVBQW1CLENBQUNnQixNQUFNLENBQUNzQixJQUFJSSxJQUN0Q3ZCLE9BQU8sQ0FBQ1QsTUFBTTZCLFNBQVMsQ0FBQ25CLElBQUksRUFDNUJ3QixVQUFVLENBQUNsQyxNQUFNNkIsU0FBUyxDQUFDTSxPQUFPLEVBQ2xDQyxjQUFjLENBQUMsS0FDZkMsZUFBZSxDQUFDL0MsdUVBQW1CLENBQUNpRCxnQkFBZ0I7WUFDdkQsYUFBYTtZQUNiM0MsTUFBTVEsY0FBYyxDQUFDNkIsR0FBR1g7WUFFeEJMLE1BQU11QixJQUFJLENBQUM7Z0JBQUVDLE9BQU9uQjtnQkFBR29CLFVBQVVUO2dCQUFHYjtZQUFLO1FBQzNDO0lBQ0Y7QUFDRjtBQUVPLE1BQU11QixZQUFZN0MsZ0JBQWdCTiw2Q0FBS0EsRUFBRUcsc0RBQWNBLEVBQUU7QUFDaEUsTUFBTWlELGFBQWEsSUFBSXRELHFFQUFpQixDQUFDO0FBRWxDLE1BQU13RCxlQUFlO0lBQzFCbEQsTUFBTW1ELElBQUksQ0FBQ0g7SUFFWCxNQUFNSSxRQUFRTCxVQUFVekIsUUFBUSxHQUFHK0IsR0FBRyxDQUFDLENBQUNDO1FBQ3RDLE1BQU1DLFFBQVFELElBQUlULEtBQUssQ0FBQ1csV0FBVztRQUNuQyxPQUFPO1lBQ0x4QyxVQUFVO2dCQUFFQyxHQUFHc0MsTUFBTXRDLENBQUM7Z0JBQUVDLEdBQUdxQyxNQUFNckMsQ0FBQztZQUFDO1lBQ25DdUMsVUFBVUgsSUFBSVQsS0FBSyxDQUFDWSxRQUFRO1lBQzVCOUMsT0FBTyxJQUFLbUMsUUFBUSxDQUFDWSxLQUFLLENBQVlDLFdBQVcsQ0FBQzFDLENBQUMsR0FBRztZQUN0REwsUUFBUSxJQUFLa0MsUUFBUSxDQUFDWSxLQUFLLENBQVlDLFdBQVcsQ0FBQ3pDLENBQUMsR0FBRztZQUN2RE0sTUFBTSxHQUFZLE9BQVQ4QixJQUFJOUIsSUFBSTtRQUNuQjtJQUNGO0lBRUEsb0VBQW9FO0lBQ3BFLDJFQUEyRTtJQUMzRSxPQUFPNEI7QUFDVCxFQUFFIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHNpbXVsYXRvclxcbW9kZWxcXGRvbWFpblxcaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJBUElFUiwgeyBDdWJvaWQgfSBmcm9tICdAZGltZm9yZ2UvcmFwaWVyMmQnO1xyXG5pbXBvcnQgeyB0b1JhZGlhbiB9IGZyb20gJy4vY2FsYyc7XHJcbmltcG9ydCB7IFNDQUxFLCBTaW11bGF0ZXJQcm9wcywgZm9yY2VWZWN0b3IsIGdyYXZpdHksIHNpbXVsYXRlclByb3BzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5cclxuY29uc3Qgd29ybGQgPSBuZXcgUkFQSUVSLldvcmxkKGdyYXZpdHkpO1xyXG5cclxuLy8gc2NhbGU6IOioiOeul+OCkuaXqeOBj+OBmeOCi+OBn+OCgeOBq+mZpOeul+OBmeOCi+S/guaVsFxyXG5jb25zdCBjcmVhdGVTaW11bGF0b3IgPSAoc2NhbGU6IG51bWJlciwgcHJvcHM6IFNpbXVsYXRlclByb3BzKSA9PiB7XHJcbiAgLy8gIOWjgeOBqOW6iuOCkuS9nOOCi1xyXG4gIHByb3BzLmRldmlkZXJzLmZvckVhY2goKGRldmlkZXIpID0+IHtcclxuICAgIHdvcmxkLmNyZWF0ZUNvbGxpZGVyKFxyXG4gICAgICBSQVBJRVIuQ29sbGlkZXJEZXNjLmN1Ym9pZChkZXZpZGVyLndpZHRoIC8gMiAvIHNjYWxlLCBkZXZpZGVyLmhlaWdodCAvIDIgLyBzY2FsZSlcclxuICAgICAgICAuc2V0TWFzcyhkZXZpZGVyLm1hc3MpXHJcbiAgICAgICAgLnNldFRyYW5zbGF0aW9uKGRldmlkZXIucG9zaXRpb24ueCAvIHNjYWxlLCBkZXZpZGVyLnBvc2l0aW9uLnkgLyBzY2FsZSlcclxuICAgICAgICAuc2V0Um90YXRpb24odG9SYWRpYW4oZGV2aWRlci5yb3RhdGUpKSxcclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IHRleHRzOiB7IHJpZ2lkOiBSQVBJRVIuUmlnaWRCb2R5OyBjb2xsaWRlcjogUkFQSUVSLkNvbGxpZGVyRGVzYzsgdGV4dDogc3RyaW5nIH1bXSA9IFtdO1xyXG4gIHJldHVybiB7XHJcbiAgICBnZXRUZXh0czogKCkgPT4gdGV4dHMsXHJcbiAgICBhZGRUZXh0OiAoe1xyXG4gICAgICB0ZXh0LFxyXG4gICAgICBwb3NpdGlvbixcclxuICAgICAgZm9yY2UgPSBmb3JjZVZlY3RvcixcclxuICAgIH06IHtcclxuICAgICAgdGV4dDogc3RyaW5nO1xyXG4gICAgICBwb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xyXG4gICAgICBmb3JjZT86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfTtcclxuICAgIH0pID0+IHtcclxuICAgICAgY29uc3QgYiA9IHdvcmxkLmNyZWF0ZVJpZ2lkQm9keShcclxuICAgICAgICBSQVBJRVIuUmlnaWRCb2R5RGVzYy5keW5hbWljKClcclxuICAgICAgICAgIC5zZXRUcmFuc2xhdGlvbihwb3NpdGlvbi54IC8gc2NhbGUsIHBvc2l0aW9uLnkgLyBzY2FsZSlcclxuICAgICAgICAgIC5zZXRBbmd2ZWwoMClcclxuICAgICAgICAgIC5zZXRMaW52ZWwoZm9yY2UueCwgZm9yY2UueSksXHJcbiAgICAgICk7XHJcbiAgICAgIC8vIGN1Ym9pZOOBr+mVt+OBleODu+mrmOOBleOCkuWNiuWIhuOBq+OBl+OBpuS9nOaIkFxyXG4gICAgICBjb25zdCBodyA9IChwcm9wcy50ZXh0RnJhbWUuZm9udFNpemUgKiB0ZXh0Lmxlbmd0aCkgLyAyIC8gc2NhbGU7XHJcbiAgICAgIGNvbnN0IGhoID0gcHJvcHMudGV4dEZyYW1lLmZvbnRTaXplIC8gMiAvIHNjYWxlO1xyXG4gICAgICBjb25zdCBjID0gUkFQSUVSLkNvbGxpZGVyRGVzYy5jdWJvaWQoaHcsIGhoKVxyXG4gICAgICAgIC5zZXRNYXNzKHByb3BzLnRleHRGcmFtZS5tYXNzKVxyXG4gICAgICAgIC5zZXREZW5zaXR5KHByb3BzLnRleHRGcmFtZS5kZW5zaXR5KVxyXG4gICAgICAgIC5zZXRSZXN0aXR1dGlvbigwLjcpXHJcbiAgICAgICAgLnNldEFjdGl2ZUV2ZW50cyhSQVBJRVIuQWN0aXZlRXZlbnRzLkNPTExJU0lPTl9FVkVOVFMpO1xyXG4gICAgICAvLyDjgrfjg5/jg6Xjg6zjg7zjgrfjg6fjg7Pplovlp4tcclxuICAgICAgd29ybGQuY3JlYXRlQ29sbGlkZXIoYywgYik7XHJcblxyXG4gICAgICB0ZXh0cy5wdXNoKHsgcmlnaWQ6IGIsIGNvbGxpZGVyOiBjLCB0ZXh0IH0pO1xyXG4gICAgfSxcclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNpbXVsYXRvciA9IGNyZWF0ZVNpbXVsYXRvcihTQ0FMRSwgc2ltdWxhdGVyUHJvcHMpO1xyXG5jb25zdCBldmVudFF1ZXVlID0gbmV3IFJBUElFUi5FdmVudFF1ZXVlKHRydWUpO1xyXG5cclxuZXhwb3J0IGNvbnN0IHNpbXVsYXRlTG9vcCA9ICgpID0+IHtcclxuICB3b3JsZC5zdGVwKGV2ZW50UXVldWUpO1xyXG5cclxuICBjb25zdCBpdGVtcyA9IHNpbXVsYXRvci5nZXRUZXh0cygpLm1hcCgob2JqKSA9PiB7XHJcbiAgICBjb25zdCB0cmFucyA9IG9iai5yaWdpZC50cmFuc2xhdGlvbigpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcG9zaXRpb246IHsgeDogdHJhbnMueCwgeTogdHJhbnMueSB9LFxyXG4gICAgICByb3RhdGlvbjogb2JqLnJpZ2lkLnJvdGF0aW9uKCksXHJcbiAgICAgIHdpZHRoOiAob2JqLmNvbGxpZGVyLnNoYXBlIGFzIEN1Ym9pZCkuaGFsZkV4dGVudHMueCAqIDIsXHJcbiAgICAgIGhlaWdodDogKG9iai5jb2xsaWRlci5zaGFwZSBhcyBDdWJvaWQpLmhhbGZFeHRlbnRzLnkgKiAyLFxyXG4gICAgICB0ZXh0OiBgJHtvYmoudGV4dH1gLFxyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gZXZlbnRRdWV1ZS5kcmFpbkNvbGxpc2lvbkV2ZW50c+OBr0NPTExJU0lPTl9FVkVOVFPjgpLmnInlirnjgavjgZfjgabjgYTjgarjgYTjga7jgafjgIHnmbrnlJ/jgZfjgarjgYRcclxuICAvLyBldmVudFF1ZXVlLmRyYWluQ29udGFjdEZvcmNlRXZlbnRz44GvQ09OVEFDVF9GT1JDRV9FVkVOVFPjgpLmnInlirnjgavjgZfjgabjgYTjgarjgYTjga7jgafjgIHnmbrnlJ/jgZfjgarjgYRcclxuICByZXR1cm4gaXRlbXM7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSQVBJRVIiLCJ0b1JhZGlhbiIsIlNDQUxFIiwiZm9yY2VWZWN0b3IiLCJncmF2aXR5Iiwic2ltdWxhdGVyUHJvcHMiLCJ3b3JsZCIsIldvcmxkIiwiY3JlYXRlU2ltdWxhdG9yIiwic2NhbGUiLCJwcm9wcyIsImRldmlkZXJzIiwiZm9yRWFjaCIsImRldmlkZXIiLCJjcmVhdGVDb2xsaWRlciIsIkNvbGxpZGVyRGVzYyIsImN1Ym9pZCIsIndpZHRoIiwiaGVpZ2h0Iiwic2V0TWFzcyIsIm1hc3MiLCJzZXRUcmFuc2xhdGlvbiIsInBvc2l0aW9uIiwieCIsInkiLCJzZXRSb3RhdGlvbiIsInJvdGF0ZSIsInRleHRzIiwiZ2V0VGV4dHMiLCJhZGRUZXh0IiwidGV4dCIsImZvcmNlIiwiYiIsImNyZWF0ZVJpZ2lkQm9keSIsIlJpZ2lkQm9keURlc2MiLCJkeW5hbWljIiwic2V0QW5ndmVsIiwic2V0TGludmVsIiwiaHciLCJ0ZXh0RnJhbWUiLCJmb250U2l6ZSIsImxlbmd0aCIsImhoIiwiYyIsInNldERlbnNpdHkiLCJkZW5zaXR5Iiwic2V0UmVzdGl0dXRpb24iLCJzZXRBY3RpdmVFdmVudHMiLCJBY3RpdmVFdmVudHMiLCJDT0xMSVNJT05fRVZFTlRTIiwicHVzaCIsInJpZ2lkIiwiY29sbGlkZXIiLCJzaW11bGF0b3IiLCJldmVudFF1ZXVlIiwiRXZlbnRRdWV1ZSIsInNpbXVsYXRlTG9vcCIsInN0ZXAiLCJpdGVtcyIsIm1hcCIsIm9iaiIsInRyYW5zIiwidHJhbnNsYXRpb24iLCJyb3RhdGlvbiIsInNoYXBlIiwiaGFsZkV4dGVudHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/model/domain/index.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/model/simulatorSelector.ts":
/*!***********************************************************!*\
  !*** ./src/entities/simulator/model/simulatorSelector.ts ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   textsSelector: () => (/* binding */ textsSelector)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/reselect/dist/reselect.mjs\");\n\nconst stateSelector = (state)=>state.simulator;\nconst textsSelector = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSelector)(stateSelector, (c)=>{\n    return c.texts;\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvbW9kZWwvc2ltdWxhdG9yU2VsZWN0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFFbEQsTUFBTUMsZ0JBQWdCLENBQUNDLFFBQXFCQSxNQUFNQyxTQUFTO0FBRXBELE1BQU1DLGdCQUFnQkosZ0VBQWNBLENBQUNDLGVBQWUsQ0FBQ0k7SUFDMUQsT0FBT0EsRUFBRUMsS0FBSztBQUNoQixHQUFHIiwic291cmNlcyI6WyJEOlxccHJvamVjdHNcXGNvbW1lbnQtYXRsYXRsXFxhcHBzXFx3ZWJcXHNyY1xcZW50aXRpZXNcXHNpbXVsYXRvclxcbW9kZWxcXHNpbXVsYXRvclNlbGVjdG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XHJcblxyXG5jb25zdCBzdGF0ZVNlbGVjdG9yID0gKHN0YXRlOiBSb290U3RhdGUpID0+IHN0YXRlLnNpbXVsYXRvcjtcclxuXHJcbmV4cG9ydCBjb25zdCB0ZXh0c1NlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3Ioc3RhdGVTZWxlY3RvciwgKGMpID0+IHtcclxuICByZXR1cm4gYy50ZXh0cztcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVTZWxlY3RvciIsInN0YXRlU2VsZWN0b3IiLCJzdGF0ZSIsInNpbXVsYXRvciIsInRleHRzU2VsZWN0b3IiLCJjIiwidGV4dHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/model/simulatorSelector.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/entities/simulator/model/simulatorSlice.ts":
/*!********************************************************!*\
  !*** ./src/entities/simulator/model/simulatorSlice.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   simulatorSlice: () => (/* binding */ simulatorSlice)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(pages-dir-browser)/../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n\nconst initialState = {\n    texts: []\n};\nconst simulatorSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.createSlice)({\n    name: 'simulator',\n    initialState,\n    reducers: {\n        setTexts: (state, action)=>{\n            state.texts = action.payload;\n        }\n    }\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9lbnRpdGllcy9zaW11bGF0b3IvbW9kZWwvc2ltdWxhdG9yU2xpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7QUFRL0MsTUFBTUMsZUFBK0I7SUFDbkNDLE9BQU8sRUFBRTtBQUNYO0FBRU8sTUFBTUMsaUJBQWlCSCw2REFBV0EsQ0FBQztJQUN4Q0ksTUFBTTtJQUNOSDtJQUNBSSxVQUFVO1FBQ1JDLFVBQVUsQ0FBQ0MsT0FBT0M7WUFDaEJELE1BQU1MLEtBQUssR0FBR00sT0FBT0MsT0FBTztRQUM5QjtJQUNGO0FBQ0YsR0FBRyIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxjb21tZW50LWF0bGF0bFxcYXBwc1xcd2ViXFxzcmNcXGVudGl0aWVzXFxzaW11bGF0b3JcXG1vZGVsXFxzaW11bGF0b3JTbGljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5pbXBvcnQgeyBUZXh0UHJvcHMgfSBmcm9tICcuL2RvbWFpbi90eXBlcyc7XHJcbmltcG9ydCB0eXBlIHsgUGF5bG9hZEFjdGlvbiB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5cclxuaW50ZXJmYWNlIFNpbXVsYXRvclN0YXRlIHtcclxuICB0ZXh0czogVGV4dFByb3BzW107XHJcbn1cclxuXHJcbmNvbnN0IGluaXRpYWxTdGF0ZTogU2ltdWxhdG9yU3RhdGUgPSB7XHJcbiAgdGV4dHM6IFtdLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHNpbXVsYXRvclNsaWNlID0gY3JlYXRlU2xpY2Uoe1xyXG4gIG5hbWU6ICdzaW11bGF0b3InLFxyXG4gIGluaXRpYWxTdGF0ZSxcclxuICByZWR1Y2Vyczoge1xyXG4gICAgc2V0VGV4dHM6IChzdGF0ZSwgYWN0aW9uOiBQYXlsb2FkQWN0aW9uPFRleHRQcm9wc1tdPikgPT4ge1xyXG4gICAgICBzdGF0ZS50ZXh0cyA9IGFjdGlvbi5wYXlsb2FkO1xyXG4gICAgfSxcclxuICB9LFxyXG59KTtcclxuIl0sIm5hbWVzIjpbImNyZWF0ZVNsaWNlIiwiaW5pdGlhbFN0YXRlIiwidGV4dHMiLCJzaW11bGF0b3JTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsInNldFRleHRzIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/entities/simulator/model/simulatorSlice.ts\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main"], () => (__webpack_exec__("(pages-dir-browser)/../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("(pages-dir-browser)/../../node_modules/next/dist/client/router.js")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);